{
  "Macros - The Rust Programming Language": {
    "_translate": "宏 - 《Rust 编程语言》",
    "_note": ""
  },
  "Macros": {
    "_translate": "<a class=\"header\" href=\"#macros\">宏</a>",
    "_note": ""
  },
  "Custom #[derive] macros that specify code added with the derive attribute used on structs and enums": {
    "_translate": "自定义 <code>#[derive]</code> 宏，用于指定通过 <code>derive</code> 属性添加到结构体和枚举上的代码",
    "_note": ""
  },
  "We’ve used macros like println! throughout this book, but we haven’t fully explored what a macro is and how it works. The term macro refers to a family of features in Rust: declarative macros with macro_rules! and three kinds of procedural macros:": {
    "_translate": "我们在这本书中使用了像 <code>println!</code> 这样的宏，但还没有完全探讨宏是什么以及它是如何工作的。术语 <em>宏</em> 指的是 Rust 中的一组特性：<em>声明式</em> 宏使用 <code>macro_rules!</code> 和三种 <em>过程式</em> 宏：",
    "_note": ""
  },
  "Attribute-like macros that define custom attributes usable on any item": {
    "_translate": "定义可用于任何项的自定义属性的属性宏",
    "_note": ""
  },
  "Function-like macros that look like function calls but operate on the tokens specified as their argument": {
    "_translate": "看起来像函数调用但操作其参数指定的标记的函数式宏",
    "_note": ""
  },
  "We’ll talk about each of these in turn, but first, let’s look at why we even need macros when we already have functions.": {
    "_translate": "我们将逐一讨论这些内容，但首先，让我们看看为什么在已经有函数的情况下，我们还需要宏。",
    "_note": ""
  },
  "The Difference Between Macros and Functions": {
    "_translate": "<a class=\"header\" href=\"#the-difference-between-macros-and-functions\">宏和函数之间的区别</a>",
    "_note": ""
  },
  "Metaprogramming is useful for reducing the amount of code you have to write and maintain, which is also one of the roles of functions. However, macros have some additional powers that functions don’t.": {
    "_translate": "元编程有助于减少你需要编写和维护的代码量，这也是函数的作用之一。然而，宏具有一些函数不具备的额外功能。",
    "_note": ""
  },
  "Fundamentally, macros are a way of writing code that writes other code, which is known as metaprogramming. In Appendix C, we discuss the derive attribute, which generates an implementation of various traits for you. We’ve also used the println! and vec! macros throughout the book. All of these macros expand to produce more code than the code you’ve written manually.": {
    "_translate": "从根本上说，宏是一种编写生成其他代码的代码的方式，这被称为<em>元编程</em>。在附录C中，我们讨论了<code>derive</code>属性，它为你生成各种特征的实现。我们还在书中使用了<code>println!</code>和<code>vec!</code>宏。所有这些宏都会<em>扩展</em>以生成比你手动编写的代码更多的代码。",
    "_note": ""
  },
  "The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you’re writing Rust code that writes Rust code. Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.": {
    "_translate": "实现宏而不是函数的缺点是宏定义比函数定义更复杂，因为您编写的Rust代码会生成Rust代码。由于这种间接性，宏定义通常比函数定义更难以阅读、理解和维护。",
    "_note": ""
  },
  "A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: we can call println!(\"hello\") with one argument or println!(\"hello {}\", name) with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can’t, because it gets called at runtime and a trait needs to be implemented at compile time.": {
    "_translate": "函数签名必须声明函数的参数数量和类型。另一方面，宏可以接受可变数量的参数：我们可以用一个参数调用<code>println!(\"hello\")</code>，或者用两个参数调用<code>println!(\"hello {}\", name)</code>。此外，宏在编译器解释代码含义之前就会展开，因此宏可以例如在给定类型上实现一个特质。函数则不行，因为函数是在运行时被调用的，而特质需要在编译时实现。",
    "_note": ""
  },
  "Another important difference between macros and functions is that you must define macros or bring them into scope before you call them in a file, as opposed to functions you can define anywhere and call anywhere.": {
    "_translate": "宏和函数之间的另一个重要区别是，你必须在文件中<em>在调用它们之前</em>定义宏或将它们引入作用域，而函数则可以在任何地方定义并在任何地方调用。",
    "_note": ""
  },
  "Declarative Macros with macro_rules! for General Metaprogramming": {
    "_translate": "<a class=\"header\" href=\"#declarative-macros-with-macro_rules-for-general-metaprogramming\">使用 <code>macro_rules!</code> 进行通用元编程的声明式宏</a>",
    "_note": ""
  },
  "To define a macro, you use the macro_rules! construct. Let’s explore how to use macro_rules! by looking at how the vec! macro is defined. Chapter 8 covered how we can use the vec! macro to create a new vector with particular values. For example, the following macro creates a new vector containing three integers:": {
    "_translate": "要定义一个宏，你使用 <code>macro_rules!</code> 构造。让我们通过查看 <code>vec!</code> 宏是如何定义的来探讨如何使用 <code>macro_rules!</code>。第 8 章介绍了我们如何使用 <code>vec!</code> 宏来创建具有特定值的新向量。例如，以下宏创建了一个包含三个整数的新向量：",
    "_note": ""
  },
  "The most widely used form of macros in Rust is the declarative macro. These are also sometimes referred to as “macros by example,” “macro_rules! macros,” or just plain “macros.” At their core, declarative macros allow you to write something similar to a Rust match expression. As discussed in Chapter 6, match expressions are control structures that take an expression, compare the resulting value of the expression to patterns, and then run the code associated with the matching pattern. Macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.": {
    "_translate": "在 Rust 中最广泛使用的宏形式是<em>声明式宏</em>。这些宏有时也被称为“示例宏”、“<code>macro_rules!</code> 宏”或简单的“宏”。在核心上，声明式宏允许你编写类似于 Rust <code>match</code> 表达式的内容。正如在第 6 章中讨论的，<code>match</code> 表达式是控制结构，它们接受一个表达式，将表达式的结果值与模式进行比较，然后运行与匹配模式相关联的代码。宏也对值进行模式匹配，这些模式与特定代码相关联：在这种情况下，值是传递给宏的字面 Rust 源代码；模式与该源代码的结构进行比较；当匹配到模式时，与每个模式相关联的代码将替换传递给宏的代码。这一切都在编译期间发生。",
    "_note": ""
  },
  "We could also use the vec! macro to make a vector of two integers or a vector of five string slices. We wouldn’t be able to use a function to do the same because we wouldn’t know the number or type of values up front.": {
    "_translate": "我们也可以使用 <code>vec!</code> 宏来创建一个包含两个整数的向量或一个包含五个字符串切片的向量。我们不能使用函数来完成相同的操作，因为我们在一开始不知道值的数量或类型。",
    "_note": ""
  },
  "Listing 20-29 shows a slightly simplified definition of the vec! macro.": {
    "_translate": "列表 20-29 显示了 <code>vec!</code> 宏的一个稍微简化的定义。",
    "_note": ""
  },
  "Note: The actual definition of the vec! macro in the standard library includes code to preallocate the correct amount of memory up front. That code is an optimization that we don’t include here to make the example simpler.": {
    "_translate": "注意：标准库中 <code>vec!</code> 宏的实际定义包括预先分配正确数量的内存的代码。这部分代码是一种优化，我们在这里没有包含，以使示例更简单。",
    "_note": ""
  },
  "The #[macro_export] annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. Without this annotation, the macro can’t be brought into scope.": {
    "_translate": "<code>#[macro_export]</code> 注解表示每当定义该宏的 crate 被引入作用域时，该宏应该被提供。没有这个注解，宏不能被引入作用域。",
    "_note": ""
  },
  "We then start the macro definition with macro_rules! and the name of the macro we’re defining without the exclamation mark. The name, in this case vec, is followed by curly brackets denoting the body of the macro definition.": {
    "_translate": "然后我们用 <code>macro_rules!</code> 和我们定义的宏的名称（<em>不带</em>感叹号）开始宏定义。名称，在这个例子中为 <code>vec</code>，后面跟着表示宏定义主体的大括号。",
    "_note": ""
  },
  "The structure in the vec! body is similar to the structure of a match expression. Here we have one arm with the pattern ( $( $x:expr ),* ), followed by => and the block of code associated with this pattern. If the pattern matches, the associated block of code will be emitted. Given that this is the only pattern in this macro, there is only one valid way to match; any other pattern will result in an error. More complex macros will have more than one arm.": {
    "_translate": "<code>vec!</code> 体内的结构类似于 <code>match</code> 表达式的结构。这里我们有一个带有模式 <code>( $( $x:expr ),* )</code> 的分支，后面跟着 <code>=&gt;</code> 和与此模式关联的代码块。如果模式匹配，将生成关联的代码块。鉴于这是此宏中唯一的模式，只有一种有效的匹配方式；任何其他模式都将导致错误。更复杂的宏将有多个分支。",
    "_note": ""
  },
  "Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 19 because macro patterns are matched against Rust code structure rather than values. Let’s walk through what the pattern pieces in Listing 20-29 mean; for the full macro pattern syntax, see the Rust Reference.": {
    "_translate": "有效的宏定义中的模式语法与第19章中介绍的模式语法不同，因为宏模式是与Rust代码结构匹配，而不是与值匹配。让我们来分析一下列表20-29中的模式片段的含义；有关完整的宏模式语法，请参阅<a href=\"../reference/macros-by-example.html\">Rust参考手册</a>。",
    "_note": ""
  },
  "First, we use a set of parentheses to encompass the whole pattern. We use a dollar sign ($) to declare a variable in the macro system that will contain the Rust code matching the pattern. The dollar sign makes it clear this is a macro variable as opposed to a regular Rust variable. Next comes a set of parentheses that captures values that match the pattern within the parentheses for use in the replacement code. Within $() is $x:expr, which matches any Rust expression and gives the expression the name $x.": {
    "_translate": "首先，我们使用一组括号来包含整个模式。我们使用美元符号(<code>$</code>)在宏系统中声明一个变量，该变量将包含与模式匹配的Rust代码。美元符号使其明确这是一个宏变量，而不是普通的Rust变量。接下来是一组括号，用于捕获与括号内模式匹配的值，以便在替换代码中使用。在<code>$()</code>内是<code>$x:expr</code>，它匹配任何Rust表达式，并将该表达式命名为<code>$x</code>。",
    "_note": ""
  },
  "The comma following $() indicates that a literal comma separator character must appear between each instance of the code that matches the code within $(). The * specifies that the pattern matches zero or more of whatever precedes the *.": {
    "_translate": "跟随 <code>$()</code> 的逗号表示必须在每个与 <code>$()</code> 内部代码匹配的代码实例之间出现一个字面上的逗号分隔符。 <code>*</code> 指定模式匹配零个或多个 <code>*</code> 前面的任何内容。",
    "_note": ""
  },
  "When we call this macro with vec![1, 2, 3];, the $x pattern matches three times with the three expressions 1, 2, and 3.": {
    "_translate": "当我们用 <code>vec![1, 2, 3];</code> 调用这个宏时，<code>$x</code> 模式会与三个表达式 <code>1</code>、<code>2</code> 和 <code>3</code> 匹配三次。",
    "_note": ""
  },
  "We’ve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.": {
    "_translate": "我们定义了一个宏，可以接受任意数量的任意类型的参数，并生成代码以创建包含指定元素的向量。",
    "_note": ""
  },
  "Now let’s look at the pattern in the body of the code associated with this arm: temp_vec.push() within $()* is generated for each part that matches $() in the pattern zero or more times depending on how many times the pattern matches. The $x is replaced with each expression matched. When we call this macro with vec![1, 2, 3];, the code generated that replaces this macro call will be the following:": {
    "_translate": "现在让我们看看与此臂关联的代码主体中的模式：<code>temp_vec.push()</code> 在 <code>$()*</code> 中为每次匹配 <code>$()</code> 的部分生成，根据模式匹配的次数，可以是零次或多次。<code>$x</code> 被每个匹配的表达式替换。当我们用 <code>vec![1, 2, 3];</code> 调用这个宏时，替换此宏调用生成的代码将是以下内容：",
    "_note": ""
  },
  "Procedural Macros for Generating Code from Attributes": {
    "_translate": "<a class=\"header\" href=\"#procedural-macros-for-generating-code-from-attributes\">用于从属性生成代码的过程宏</a>",
    "_note": ""
  },
  "To learn more about how to write macros, consult the online documentation or other resources, such as “The Little Book of Rust Macros” started by Daniel Keep and continued by Lukas Wirth.": {
    "_translate": "要了解更多关于如何编写宏的信息，请参阅在线文档或其他资源，如<a href=\"https://veykril.github.io/tlborm/\">“Rust宏小书”</a>，该书由Daniel Keep发起并由Lukas Wirth继续编写。",
    "_note": ""
  },
  "The second form of macros is the procedural macro, which acts more like a function (and is a type of procedure). Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do. The three kinds of procedural macros are custom derive, attribute-like, and function-like, and all work in a similar fashion.": {
    "_translate": "第二种宏的形式是<em>过程宏</em>，它更像一个函数（并且是一种过程）。过程宏接受一些代码作为输入，对这些代码进行操作，并生成一些代码作为输出，而不是像声明式宏那样通过匹配模式并用其他代码替换这些代码。过程宏的三种类型是自定义派生、属性样式的和函数样式的，它们都以类似的方式工作。",
    "_note": ""
  },
  "When creating procedural macros, the definitions must reside in their own crate with a special crate type. This is for complex technical reasons that we hope to eliminate in the future. In Listing 20-30, we show how to define a procedural macro, where some_attribute is a placeholder for using a specific macro variety.": {
    "_translate": "在创建过程宏时，定义必须位于具有特殊crate类型的独立crate中。这是出于复杂的技\n术原因，我们希望将来能够消除。在清单20-30中，我们展示了如何定义一个过程宏，其中<code>some_attribute</code>是用于特定宏变体的占位符。",
    "_note": ""
  },
  "Let’s look at the different kinds of procedural macros. We’ll start with a custom derive macro and then explain the small dissimilarities that make the other forms different.": {
    "_translate": "让我们看看不同种类的过程宏。我们先从自定义派生宏开始，然后解释使其他形式不同的细微差异。",
    "_note": ""
  },
  "How to Write a Custom derive Macro": {
    "_translate": "<a class=\"header\" href=\"#how-to-write-a-custom-derive-macro\">如何编写自定义<code>derive</code>宏</a>",
    "_note": ""
  },
  "The function that defines a procedural macro takes a TokenStream as an input and produces a TokenStream as an output. The TokenStream type is defined by the proc_macro crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: the source code that the macro is operating on makes up the input TokenStream, and the code the macro produces is the output TokenStream. The function also has an attribute attached to it that specifies which kind of procedural macro we’re creating. We can have multiple kinds of procedural macros in the same crate.": {
    "_translate": "定义过程宏的函数以 <code>TokenStream</code> 作为输入，并生成一个 <code>TokenStream</code> 作为输出。<code>TokenStream</code> 类型由 Rust 包含的 <code>proc_macro</code> crate 定义，表示一个令牌序列。这是宏的核心：宏操作的源代码构成了输入 <code>TokenStream</code>，而宏生成的代码是输出 <code>TokenStream</code>。该函数还附加了一个属性，指定了我们正在创建的过程宏的类型。我们可以在同一个 crate 中有多种类型的过程宏。",
    "_note": ""
  },
  "This code will print Hello, Macro! My name is Pancakes! when we’re done. The first step is to make a new library crate, like this:": {
    "_translate": "这段代码完成后将打印 <code>Hello, Macro! My name is Pancakes!</code>。第一步是创建一个新的库crate，如下所示：",
    "_note": ""
  },
  "Next, we’ll define the HelloMacro trait and its associated function:": {
    "_translate": "接下来，我们将定义 <code>HelloMacro</code> 特性和其关联函数：",
    "_note": ""
  },
  "Let’s create a crate named hello_macro that defines a trait named HelloMacro with one associated function named hello_macro. Rather than making our users implement the HelloMacro trait for each of their types, we’ll provide a procedural macro so users can annotate their type with #[derive(HelloMacro)] to get a default implementation of the hello_macro function. The default implementation will print Hello, Macro! My name is TypeName! where TypeName is the name of the type on which this trait has been defined. In other words, we’ll write a crate that enables another programmer to write code like Listing 20-31 using our crate.": {
    "_translate": "让我们创建一个名为 <code>hello_macro</code> 的 crate，该 crate 定义了一个名为 <code>HelloMacro</code> 的 trait，其中有一个名为 <code>hello_macro</code> 的关联函数。我们不是让用户为他们的每个类型实现 <code>HelloMacro</code> trait，而是提供一个过程宏，以便用户可以通过 <code>#[derive(HelloMacro)]</code> 注解他们的类型来获得 <code>hello_macro</code> 函数的默认实现。默认实现将打印 <code>Hello, Macro! My name is TypeName!</code>，其中 <code>TypeName</code> 是定义此 trait 的类型的名称。换句话说，我们将编写一个 crate，使其他程序员能够使用我们的 crate 编写如清单 20-31 所示的代码。",
    "_note": ""
  },
  "We have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, like so:": {
    "_translate": "我们有一个特质及其函数。此时，我们的 crate 用户可以实现该特质以实现所需的功能，如下所示：",
    "_note": ""
  },
  "However, they would need to write the implementation block for each type they wanted to use with hello_macro; we want to spare them from having to do this work.": {
    "_translate": "但是，他们需要为每个想要与<code>hello_macro</code>一起使用的类型编写实现块；我们希望免除他们做这项工作的需要。",
    "_note": ""
  },
  "Additionally, we can’t yet provide the hello_macro function with default implementation that will print the name of the type the trait is implemented on: Rust doesn’t have reflection capabilities, so it can’t look up the type’s name at runtime. We need a macro to generate code at compile time.": {
    "_translate": "此外，我们还不能为 <code>hello_macro</code> 函数提供默认实现来打印实现该特征的类型的名称：Rust 没有反射功能，因此无法在运行时查找类型的名称。我们需要一个宏在编译时生成代码。",
    "_note": ""
  },
  "The next step is to define the procedural macro. At the time of this writing, procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: for a crate named foo, a custom derive procedural macro crate is called foo_derive. Let’s start a new crate called hello_macro_derive inside our hello_macro project:": {
    "_translate": "下一步是定义过程宏。在撰写本文时，\n过程宏需要位于它们自己的 crate 中。最终，这一限制\n可能会被取消。crate 和宏 crate 的结构约定如下：对于名为 <code>foo</code> 的 crate，自定义派生过程宏 crate\n称为 <code>foo_derive</code>。让我们在 <code>hello_macro</code> 项目中\n开始一个名为 <code>hello_macro_derive</code> 的新 crate：",
    "_note": ""
  },
  "Our two crates are tightly related, so we create the procedural macro crate within the directory of our hello_macro crate. If we change the trait definition in hello_macro, we’ll have to change the implementation of the procedural macro in hello_macro_derive as well. The two crates will need to be published separately, and programmers using these crates will need to add both as dependencies and bring them both into scope. We could instead have the hello_macro crate use hello_macro_derive as a dependency and re-export the procedural macro code. However, the way we’ve structured the project makes it possible for programmers to use hello_macro even if they don’t want the derive functionality.": {
    "_translate": "我们的两个crate紧密相关，因此我们在<code>hello_macro</code> crate的目录内创建了过程宏crate。如果我们更改<code>hello_macro</code>中的trait定义，我们也需要更改<code>hello_macro_derive</code>中的过程宏实现。这两个crate需要分别发布，使用这些crate的程序员需要将它们都添加为依赖项并将它们都引入作用域。我们也可以让<code>hello_macro</code> crate将<code>hello_macro_derive</code>作为依赖项并重新导出过程宏代码。然而，我们这样组织项目的方式使得程序员即使不想要<code>derive</code>功能也可以使用<code>hello_macro</code>。",
    "_note": ""
  },
  "We need to declare the hello_macro_derive crate as a procedural macro crate. We’ll also need functionality from the syn and quote crates, as you’ll see in a moment, so we need to add them as dependencies. Add the following to the Cargo.toml file for hello_macro_derive:": {
    "_translate": "我们需要将<code>hello_macro_derive</code> crate 声明为过程宏 crate。\n我们还需要从<code>syn</code>和<code>quote</code> crate 中获取功能，你将在稍后看到，因此我们需要将它们添加为依赖项。将以下内容添加到<code>hello_macro_derive</code>的<em>Cargo.toml</em>文件中：",
    "_note": ""
  },
  "To start defining the procedural macro, place the code in Listing 20-32 into your src/lib.rs file for the hello_macro_derive crate. Note that this code won’t compile until we add a definition for the impl_hello_macro function.": {
    "_translate": "要开始定义过程宏，请将清单 20-32 中的代码放入 <em>src/lib.rs</em> 文件中，用于 <code>hello_macro_derive</code> crate。请注意，直到我们添加 <code>impl_hello_macro</code> 函数的定义之前，此代码将无法编译。",
    "_note": ""
  },
  "Notice that we’ve split the code into the hello_macro_derive function, which is responsible for parsing the TokenStream, and the impl_hello_macro function, which is responsible for transforming the syntax tree: this makes writing a procedural macro more convenient. The code in the outer function (hello_macro_derive in this case) will be the same for almost every procedural macro crate you see or create. The code you specify in the body of the inner function (impl_hello_macro in this case) will be different depending on your procedural macro’s purpose.": {
    "_translate": "注意，我们将代码分成了 <code>hello_macro_derive</code> 函数，该函数负责解析 <code>TokenStream</code>，以及 <code>impl_hello_macro</code> 函数，该函数负责转换语法树：这使得编写过程宏更加方便。外部函数中的代码（在这种情况下为 <code>hello_macro_derive</code>）对于你看到或创建的几乎所有过程宏 crate 都是相同的。你在内部函数体中指定的代码（在这种情况下为 <code>impl_hello_macro</code>）将根据你的过程宏的目的而不同。",
    "_note": ""
  },
  "We’ve introduced three new crates: proc_macro, syn, and quote. The proc_macro crate comes with Rust, so we didn’t need to add that to the dependencies in Cargo.toml. The proc_macro crate is the compiler’s API that allows us to read and manipulate Rust code from our code.": {
    "_translate": "我们引入了三个新的crate：<code>proc_macro</code>，<a href=\"https://crates.io/crates/syn\"><code>syn</code></a> 和 <a href=\"https://crates.io/crates/quote\"><code>quote</code></a>。<code>proc_macro</code> crate 随 Rust 一起提供，因此我们不需要将其添加到 <em>Cargo.toml</em> 的依赖项中。<code>proc_macro</code> crate 是编译器的 API，允许我们从代码中读取和操作 Rust 代码。",
    "_note": ""
  },
  "The syn crate parses Rust code from a string into a data structure that we can perform operations on. The quote crate turns syn data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task.": {
    "_translate": "<code>syn</code> crate 从字符串中解析 Rust 代码到我们可以操作的数据结构。<code>quote</code> crate 将 <code>syn</code> 数据结构转换回 Rust 代码。这些 crate 使解析我们可能需要处理的任何类型的 Rust 代码变得更加简单：编写一个完整的 Rust 代码解析器绝非易事。",
    "_note": ""
  },
  "The hello_macro_derive function will be called when a user of our library specifies #[derive(HelloMacro)] on a type. This is possible because we’ve annotated the hello_macro_derive function here with proc_macro_derive and specified the name HelloMacro, which matches our trait name; this is the convention most procedural macros follow.": {
    "_translate": "<code>hello_macro_derive</code> 函数将在我们的库的用户在类型上指定 <code>#[derive(HelloMacro)]</code> 时被调用。这是因为我们在这里用 <code>proc_macro_derive</code> 注解了 <code>hello_macro_derive</code> 函数，并指定了名称 <code>HelloMacro</code>，这与我们的特征名称匹配；这是大多数过程宏遵循的惯例。",
    "_note": ""
  },
  "The hello_macro_derive function first converts the input from a TokenStream to a data structure that we can then interpret and perform operations on. This is where syn comes into play. The parse function in syn takes a TokenStream and returns a DeriveInput struct representing the parsed Rust code. Listing 20-33 shows the relevant parts of the DeriveInput struct we get from parsing the struct Pancakes; string:": {
    "_translate": "<code>hello_macro_derive</code> 函数首先将 <code>input</code> 从一个 <code>TokenStream</code> 转换为一个我们可以解释和执行操作的数据结构。这就是 <code>syn</code> 发挥作用的地方。<code>syn</code> 中的 <code>parse</code> 函数接受一个 <code>TokenStream</code> 并返回一个表示解析后的 Rust 代码的 <code>DeriveInput</code> 结构体。列表 20-33 显示了从解析 <code>struct Pancakes;</code> 字符串得到的 <code>DeriveInput</code> 结构体的相关部分：",
    "_note": ""
  },
  "The fields of this struct show that the Rust code we’ve parsed is a unit struct with the ident (identifier, meaning the name) of Pancakes. There are more fields on this struct for describing all sorts of Rust code; check the syn documentation for DeriveInput for more information.": {
    "_translate": "这个结构体的字段显示我们解析的 Rust 代码是一个单元结构体，其 <code>ident</code>（标识符，即名称）为 <code>Pancakes</code>。这个结构体还有更多字段用于描述各种 Rust 代码；有关更多信息，请参阅 <a href=\"https://docs.rs/syn/2.0/syn/struct.DeriveInput.html\"><code>syn</code> 中 <code>DeriveInput</code> 的文档</a>。",
    "_note": ""
  },
  "Soon we’ll define the impl_hello_macro function, which is where we’ll build the new Rust code we want to include. But before we do, note that the output for our derive macro is also a TokenStream. The returned TokenStream is added to the code that our crate users write, so when they compile their crate, they’ll get the extra functionality that we provide in the modified TokenStream.": {
    "_translate": "很快我们将定义<code>impl_hello_macro</code>函数，这将是构建我们想要包含的新Rust代码的地方。但在我们这样做之前，请注意，我们派生宏的输出也是一个<code>TokenStream</code>。返回的<code>TokenStream</code>将添加到我们的crate用户编写的代码中，因此当他们编译他们的crate时，他们将获得我们在修改后的<code>TokenStream</code>中提供的额外功能。",
    "_note": ""
  },
  "Now that we have the code to turn the annotated Rust code from a TokenStream into a DeriveInput instance, let’s generate the code that implements the HelloMacro trait on the annotated type, as shown in Listing 20-34.": {
    "_translate": "现在我们有了将带有注解的 Rust 代码从 <code>TokenStream</code> 转换为 <code>DeriveInput</code> 实例的代码，让我们生成实现 <code>HelloMacro</code> 特性到带有注解的类型的代码，如清单 20-34 所示。",
    "_note": ""
  },
  "You might have noticed that we’re calling unwrap to cause the hello_macro_derive function to panic if the call to the syn::parse function fails here. It’s necessary for our procedural macro to panic on errors because proc_macro_derive functions must return TokenStream rather than Result to conform to the procedural macro API. We’ve simplified this example by using unwrap; in production code, you should provide more specific error messages about what went wrong by using panic! or expect.": {
    "_translate": "你可能已经注意到，我们在这里调用 <code>unwrap</code> 以使 <code>hello_macro_derive</code> 函数在 <code>syn::parse</code> 函数调用失败时引发 panic。我们的过程宏在遇到错误时必须 panic，因为 <code>proc_macro_derive</code> 函数必须返回 <code>TokenStream</code> 而不是 <code>Result</code> 以符合过程宏 API。我们通过使用 <code>unwrap</code> 简化了这个示例；在生产代码中，你应该使用 <code>panic!</code> 或 <code>expect</code> 提供更具体的错误信息。",
    "_note": ""
  },
  "The quote! macro lets us define the Rust code that we want to return. The compiler expects something different to the direct result of the quote! macro’s execution, so we need to convert it to a TokenStream. We do this by calling the into method, which consumes this intermediate representation and returns a value of the required TokenStream type.": {
    "_translate": "<code>quote!</code> 宏让我们定义我们想要返回的 Rust 代码。编译器期望的内容与 <code>quote!</code> 宏执行的直接结果不同，因此我们需要将其转换为 <code>TokenStream</code>。我们通过调用 <code>into</code> 方法来实现这一点，该方法消耗这个中间表示并返回所需 <code>TokenStream</code> 类型的值。",
    "_note": ""
  },
  "We get an Ident struct instance containing the name (identifier) of the annotated type using ast.ident. The struct in Listing 20-33 shows that when we run the impl_hello_macro function on the code in Listing 20-31, the ident we get will have the ident field with a value of \"Pancakes\". Thus, the name variable in Listing 20-34 will contain an Ident struct instance that, when printed, will be the string \"Pancakes\", the name of the struct in Listing 20-31.": {
    "_translate": "我们使用 <code>ast.ident</code> 获取一个包含注解类型名称（标识符）的 <code>Ident</code> 结构体实例。列表 20-33 中的结构体显示，当我们对列表 20-31 中的代码运行 <code>impl_hello_macro</code> 函数时，我们得到的 <code>ident</code> 将具有值为 <code>\"Pancakes\"</code> 的 <code>ident</code> 字段。因此，列表 20-34 中的 <code>name</code> 变量将包含一个 <code>Ident</code> 结构体实例，当打印时，它将是字符串 <code>\"Pancakes\"</code>，即列表 20-31 中结构体的名称。",
    "_note": ""
  },
  "The quote! macro also provides some very cool templating mechanics: we can enter #name, and quote! will replace it with the value in the variable name. You can even do some repetition similar to the way regular macros work. Check out the quote crate’s docs for a thorough introduction.": {
    "_translate": "<code>quote!</code> 宏还提供了一些非常酷的模板机制：我们可以输入 <code>#name</code>，<code>quote!</code> 会将其替换为变量 <code>name</code> 中的值。你甚至可以像普通宏那样进行一些重复操作。查看 <a href=\"https://docs.rs/quote\">the <code>quote</code> crate’s docs</a> 以获得详细的介绍。",
    "_note": ""
  },
  "We want our procedural macro to generate an implementation of our HelloMacro trait for the type the user annotated, which we can get by using #name. The trait implementation has the one function hello_macro, whose body contains the functionality we want to provide: printing Hello, Macro! My name is and then the name of the annotated type.": {
    "_translate": "我们希望我们的过程宏为用户注解的类型生成一个<code>HelloMacro</code>特性的实现，这可以通过使用<code>#name</code>来获得。特性的实现包含一个函数<code>hello_macro</code>，其函数体包含我们想要提供的功能：打印<code>Hello, Macro! My name is</code>，然后是注解类型的名称。",
    "_note": ""
  },
  "The stringify! macro used here is built into Rust. It takes a Rust expression, such as 1 + 2, and at compile time turns the expression into a string literal, such as \"1 + 2\". This is different than format! or println!, macros which evaluate the expression and then turn the result into a String. There is a possibility that the #name input might be an expression to print literally, so we use stringify!. Using stringify! also saves an allocation by converting #name to a string literal at compile time.": {
    "_translate": "这里使用的 <code>stringify!</code> 宏是 Rust 内置的。它接受一个 Rust 表达式，例如 <code>1 + 2</code>，并在编译时将表达式转换为字符串字面量，例如 <code>\"1 + 2\"</code>。这与 <code>format!</code> 或 <code>println!</code> 宏不同，后者会先评估表达式，然后将结果转换为 <code>String</code>。有可能 <code>#name</code> 输入是一个需要字面打印的表达式，因此我们使用 <code>stringify!</code>。使用 <code>stringify!</code> 还可以通过在编译时将 <code>#name</code> 转换为字符串字面量来节省分配。",
    "_note": ""
  },
  "At this point, cargo build should complete successfully in both hello_macro and hello_macro_derive. Let’s hook up these crates to the code in Listing 20-31 to see the procedural macro in action! Create a new binary project in your projects directory using cargo new pancakes. We need to add hello_macro and hello_macro_derive as dependencies in the pancakes crate’s Cargo.toml. If you’re publishing your versions of hello_macro and hello_macro_derive to crates.io, they would be regular dependencies; if not, you can specify them as path dependencies as follows:": {
    "_translate": "此时，<code>cargo build</code> 应该在 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 中都成功完成。让我们将这些 crates 连接到列表 20-31 中的代码，看看过程宏如何工作！在 <em>projects</em> 目录中使用 <code>cargo new pancakes</code> 创建一个新的二进制项目。我们需要在 <code>pancakes</code> crate 的 <em>Cargo.toml</em> 中添加 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 作为依赖项。如果你将 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 的版本发布到 <a href=\"https://crates.io/\">crates.io</a>，它们将是常规依赖项；如果不是，你可以将它们指定为 <code>path</code> 依赖项，如下所示：",
    "_note": ""
  },
  "Next, let’s explore how the other kinds of procedural macros differ from custom derive macros.": {
    "_translate": "接下来，让我们探讨其他种类的过程宏与自定义派生宏有何不同。",
    "_note": ""
  },
  "Put the code in Listing 20-31 into src/main.rs, and run cargo run: it should print Hello, Macro! My name is Pancakes! The implementation of the HelloMacro trait from the procedural macro was included without the pancakes crate needing to implement it; the #[derive(HelloMacro)] added the trait implementation.": {
    "_translate": "将清单 20-31 中的代码放入 <em>src/main.rs</em>，并运行 <code>cargo run</code>：它应该打印 <code>Hello, Macro! My name is Pancakes!</code> 从过程宏实现的 <code>HelloMacro</code> 特性被包含进来，而无需 <code>pancakes</code> crate 自身实现它；<code>#[derive(HelloMacro)]</code> 添加了特性实现。",
    "_note": ""
  },
  "Attribute-like macros": {
    "_translate": "<a class=\"header\" href=\"#attribute-like-macros\">属性宏</a>",
    "_note": ""
  },
  "This #[route] attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:": {
    "_translate": "这个 <code>#[route]</code> 属性将由框架定义为过程宏。宏定义函数的签名将如下所示：",
    "_note": ""
  },
  "Attribute-like macros are similar to custom derive macros, but instead of generating code for the derive attribute, they allow you to create new attributes. They’re also more flexible: derive only works for structs and enums; attributes can be applied to other items as well, such as functions. Here’s an example of using an attribute-like macro: say you have an attribute named route that annotates functions when using a web application framework:": {
    "_translate": "属性宏类似于自定义派生宏，但它们不是为 <code>derive</code> 属性生成代码，而是允许你创建新的属性。它们也更加灵活：<code>derive</code> 仅适用于结构体和枚举；属性可以应用于其他项目，例如函数。以下是一个使用属性宏的示例：假设你有一个名为 <code>route</code> 的属性，用于在使用 Web 应用程序框架时标注函数：",
    "_note": ""
  },
  "Here, we have two parameters of type TokenStream. The first is for the contents of the attribute: the GET, \"/\" part. The second is the body of the item the attribute is attached to: in this case, fn index() {} and the rest of the function’s body.": {
    "_translate": "这里，我们有两个类型为<code>TokenStream</code>的参数。第一个是属性的内容：<code>GET, \"/\"</code> 部分。第二个是属性附加到的项的主体：在这种情况下，是<code>fn index() {}</code>及其余的函数主体。",
    "_note": ""
  },
  "Other than that, attribute-like macros work the same way as custom derive macros: you create a crate with the proc-macro crate type and implement a function that generates the code you want!": {
    "_translate": "除此之外，属性宏的工作方式与自定义派生宏相同：您需要创建一个<code>proc-macro</code>类型的crate，并实现一个生成所需代码的函数！",
    "_note": ""
  },
  "Function-like macros": {
    "_translate": "<a class=\"header\" href=\"#function-like-macros\">函数式宏</a>",
    "_note": ""
  },
  "This macro would parse the SQL statement inside it and check that it’s syntactically correct, which is much more complex processing than a macro_rules! macro can do. The sql! macro would be defined like this:": {
    "_translate": "这个宏会解析其内部的 SQL 语句并检查其语法是否正确，这比 <code>macro_rules!</code> 宏能做的处理要复杂得多。<code>sql!</code> 宏的定义如下：",
    "_note": ""
  },
  "Function-like macros define macros that look like function calls. Similarly to macro_rules! macros, they’re more flexible than functions; for example, they can take an unknown number of arguments. However, macro_rules! macros can be defined only using the match-like syntax we discussed in the section “Declarative Macros with macro_rules! for General Metaprogramming” earlier. Function-like macros take a TokenStream parameter and their definition manipulates that TokenStream using Rust code as the other two types of procedural macros do. An example of a function-like macro is an sql! macro that might be called like so:": {
    "_translate": "函数式宏定义了看起来像函数调用的宏。类似于<code>macro_rules!</code>宏，它们比函数更灵活；例如，它们可以接受未知数量的参数。然而，<code>macro_rules!</code>宏只能使用我们在<a href=\"#declarative-macros-with-macro_rules-for-general-metaprogramming\">“使用<code>macro_rules!</code>的声明式宏进行通用元编程”</a>部分讨论的匹配语法来定义。函数式宏接受一个<code>TokenStream</code>参数，并且它们的定义使用Rust代码来操作这个<code>TokenStream</code>，就像其他两种过程宏一样。一个函数式宏的例子是<code>sql!</code>宏，它可能被这样调用：",
    "_note": ""
  },
  "This definition is similar to the custom derive macro’s signature: we receive the tokens that are inside the parentheses and return the code we wanted to generate.": {
    "_translate": "这个定义与自定义派生宏的签名类似：我们接收括号内的标记并返回我们想要生成的代码。",
    "_note": ""
  },
  "Summary": {
    "_translate": "<a class=\"header\" href=\"#summary\">摘要</a>",
    "_note": ""
  },
  "Next, we’ll put everything we’ve discussed throughout the book into practice and do one more project!": {
    "_translate": "接下来，我们将把本书中讨论的所有内容付诸实践，并再做一个项目！",
    "_note": ""
  },
  "Whew! Now you have some Rust features in your toolbox that you likely won’t use often, but you’ll know they’re available in very particular circumstances. We’ve introduced several complex topics so that when you encounter them in error message suggestions or in other peoples’ code, you’ll be able to recognize these concepts and syntax. Use this chapter as a reference to guide you to solutions.": {
    "_translate": "呼！现在你已经掌握了一些你可能不常使用，但在特定情况下会知道它们可用的 Rust 特性。我们介绍了几个复杂的话题，这样当你在错误消息建议或其他人的代码中遇到它们时，你能够识别这些概念和语法。使用本章作为参考，引导你找到解决方案。",
    "_note": ""
  },
  "Attribute-Like macros": {
    "_translate": "<a class=\"header\" href=\"#attribute-like-macros\">属性宏</a>",
    "_note": ""
  },
  "Function-Like macros": {
    "_translate": "<a class=\"header\" href=\"#function-like-macros\">函数式宏</a>",
    "_note": ""
  },
  "Function-like macros define macros that look like function calls. Similarly to macro_rules! macros, they’re more flexible than functions; for example, they can take an unknown number of arguments. However, macro_rules! macros can only be defined using the match-like syntax we discussed in “Declarative Macros with macro_rules! for General Metaprogramming” earlier. Function-like macros take a TokenStream parameter and their definition manipulates that TokenStream using Rust code as the other two types of procedural macros do. An example of a function-like macro is an sql! macro that might be called like so:": {
    "_translate": "函数式宏定义了看起来像函数调用的宏。类似于<code>macro_rules!</code>宏，它们比函数更灵活；例如，它们可以接受未知数量的参数。然而，<code>macro_rules!</code>宏只能使用我们在<a href=\"#declarative-macros-with-macro_rules-for-general-metaprogramming\">“使用<code>macro_rules!</code>进行一般元编程的声明式宏”</a>中讨论的匹配语法来定义。函数式宏接受一个<code>TokenStream</code>参数，并且它们的定义使用Rust代码来操作这个<code>TokenStream</code>，就像其他两种过程宏一样。一个函数式宏的例子是<code>sql!</code>宏，它可能被这样调用：",
    "_note": ""
  },
  "Metaprogramming is useful for reducing the amount of code you have to write and maintain, which is also one of the roles of functions. However, macros have some additional powers that functions don’t have.": {
    "_translate": "元编程有助于减少你需要编写和维护的代码量，这也是函数的作用之一。然而，宏具有一些函数不具备的额外功能。",
    "_note": ""
  },
  "Listing 20-35 shows a slightly simplified definition of the vec! macro.": {
    "_translate": "列表 20-35 显示了 <code>vec!</code> 宏的一个稍微简化的定义。",
    "_note": ""
  },
  "Note: The actual definition of the vec! macro in the standard library includes code to pre-allocate the correct amount of memory up front. That code is an optimization that we don’t include here, to make the example simpler.": {
    "_translate": "注意：标准库中 <code>vec!</code> 宏的实际定义包括预先分配正确数量的内存的代码。这部分代码是一种优化，我们在这里没有包含，以使示例更简单。",
    "_note": ""
  },
  "The most widely used form of macros in Rust is the declarative macro. These are also sometimes referred to as “macros by example,” “macro_rules! macros,” or just plain “macros.” At their core, declarative macros allow you to write something similar to a Rust match expression. As discussed in Chapter 6, match expressions are control structures that take an expression, compare the resultant value of the expression to patterns, and then run the code associated with the matching pattern. Macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.": {
    "_translate": "在 Rust 中最广泛使用的宏形式是<em>声明式宏</em>。这些宏有时也被称为“示例宏”，“<code>macro_rules!</code> 宏”，或简称为“宏”。在核心上，声明式宏允许你编写类似于 Rust <code>match</code> 表达式的内容。正如在第 6 章中讨论的，<code>match</code> 表达式是控制结构，它们接受一个表达式，将表达式的结果值与模式进行比较，然后运行与匹配模式相关联的代码。宏也对值进行模式匹配：在这种情况下，值是传递给宏的字面 Rust 源代码；模式与该源代码的结构进行比较；当匹配到模式时，与每个模式相关联的代码将替换传递给宏的代码。这一切都在编译期间发生。",
    "_note": ""
  },
  "First we use a set of parentheses to encompass the whole pattern. We use a dollar sign ($) to declare a variable in the macro system that will contain the Rust code matching the pattern. The dollar sign makes it clear this is a macro variable as opposed to a regular Rust variable. Next comes a set of parentheses that captures values that match the pattern within the parentheses for use in the replacement code. Within $() is $x:expr, which matches any Rust expression and gives the expression the name $x.": {
    "_translate": "首先，我们使用一组括号来包含整个模式。我们使用美元符号(<code>$</code>)在宏系统中声明一个变量，该变量将包含与模式匹配的Rust代码。美元符号明确表示这是一个宏变量，而不是普通的Rust变量。接下来是一组括号，用于捕获与括号内模式匹配的值，以便在替换代码中使用。在<code>$()</code>内是<code>$x:expr</code>，它匹配任何Rust表达式，并将该表达式命名为<code>$x</code>。",
    "_note": ""
  },
  "Valid pattern syntax in macro definitions is different from the pattern syntax covered in Chapter 19 because macro patterns are matched against Rust code structure rather than values. Let’s walk through what the pattern pieces in Listing 20-29 mean; for the full macro pattern syntax, see the Rust Reference.": {
    "_translate": "有效的宏定义中的模式语法与第19章中介绍的模式语法不同，因为宏模式是与Rust代码结构匹配，而不是与值匹配。让我们来分析一下列表20-29中的模式片段的含义；有关完整的宏模式语法，请参阅<a href=\"../reference/macros-by-example.html\">Rust参考手册</a>。",
    "_note": ""
  },
  "When creating procedural macros, the definitions must reside in their own crate with a special crate type. This is for complex technical reasons that we hope to eliminate in the future. In Listing 20-36, we show how to define a procedural macro, where some_attribute is a placeholder for using a specific macro variety.": {
    "_translate": "在创建过程宏时，定义必须位于具有特殊crate类型的独立crate中。这是出于复杂的技\n术原因，我们希望将来能够消除。在清单20-36中，我们展示了如何定义一个过程宏，其中<code>some_attribute</code>是用于特定宏变体的占位符。",
    "_note": ""
  },
  "Let’s create a crate named hello_macro that defines a trait named HelloMacro with one associated function named hello_macro. Rather than making our users implement the HelloMacro trait for each of their types, we’ll provide a procedural macro so users can annotate their type with #[derive(HelloMacro)] to get a default implementation of the hello_macro function. The default implementation will print Hello, Macro! My name is TypeName! where TypeName is the name of the type on which this trait has been defined. In other words, we’ll write a crate that enables another programmer to write code like Listing 20-37 using our crate.": {
    "_translate": "让我们创建一个名为 <code>hello_macro</code> 的 crate，该 crate 定义了一个名为 <code>HelloMacro</code> 的 trait，其中有一个关联函数名为 <code>hello_macro</code>。我们不是让用户为每个类型实现 <code>HelloMacro</code> trait，而是提供一个过程宏，使用户可以通过 <code>#[derive(HelloMacro)]</code> 注解他们的类型来获得 <code>hello_macro</code> 函数的默认实现。默认实现将打印 <code>Hello, Macro! My name is TypeName!</code>，其中 <code>TypeName</code> 是定义此 trait 的类型的名称。换句话说，我们将编写一个 crate，使其他程序员能够使用我们的 crate 编写如清单 20-37 所示的代码。",
    "_note": ""
  },
  "We have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, as in Listing 20-39.": {
    "_translate": "我们有一个特质及其函数。此时，我们的 crate 用户可以通过实现该特质来实现所需的功能，如清单 20-39 所示。",
    "_note": ""
  },
  "To start defining the procedural macro, place the code in Listing 20-40 into your src/lib.rs file for the hello_macro_derive crate. Note that this code won’t compile until we add a definition for the impl_hello_macro function.": {
    "_translate": "要开始定义过程宏，请将清单 20-40 中的代码放入 <em>src/lib.rs</em> 文件中，用于 <code>hello_macro_derive</code> crate。请注意，此代码在我们添加 <code>impl_hello_macro</code> 函数的定义之前将无法编译。",
    "_note": ""
  },
  "The hello_macro_derive function first converts the input from a TokenStream to a data structure that we can then interpret and perform operations on. This is where syn comes into play. The parse function in syn takes a TokenStream and returns a DeriveInput struct representing the parsed Rust code. Listing 20-41 shows the relevant parts of the DeriveInput struct we get from parsing the struct Pancakes; string.": {
    "_translate": "<code>hello_macro_derive</code> 函数首先将 <code>input</code> 从一个 <code>TokenStream</code> 转换为一个我们可以解释和执行操作的数据结构。这就是 <code>syn</code> 发挥作用的地方。<code>syn</code> 中的 <code>parse</code> 函数接受一个 <code>TokenStream</code> 并返回一个表示解析后的 Rust 代码的 <code>DeriveInput</code> 结构体。列表 20-41 显示了从解析 <code>struct Pancakes;</code> 字符串得到的 <code>DeriveInput</code> 结构体的相关部分。",
    "_note": ""
  },
  "Now that we have the code to turn the annotated Rust code from a TokenStream into a DeriveInput instance, let’s generate the code that implements the HelloMacro trait on the annotated type, as shown in Listing 20-42.": {
    "_translate": "现在我们有了将带有注解的 Rust 代码从 <code>TokenStream</code> 转换为 <code>DeriveInput</code> 实例的代码，让我们生成实现 <code>HelloMacro</code> 特性到带有注解的类型的代码，如清单 20-42 所示。",
    "_note": ""
  },
  "We get an Ident struct instance containing the name (identifier) of the annotated type using ast.ident. The struct in Listing 20-33 shows that when we run the impl_hello_macro function on the code in Listing 20-31, the ident we get will have the ident field with a value of \"Pancakes\". Thus, the name variable in Listing 20-34 will contain an Ident struct instance that, when printed, will be the string \"Pancakes\", the name of the struct in Listing 20-37.": {
    "_translate": "我们使用 <code>ast.ident</code> 获取一个包含注解类型名称（标识符）的 <code>Ident</code> 结构体实例。列表 20-33 中的结构体显示，当我们对列表 20-31 中的代码运行 <code>impl_hello_macro</code> 函数时，我们得到的 <code>ident</code> 将具有值为 <code>\"Pancakes\"</code> 的 <code>ident</code> 字段。因此，列表 20-34 中的 <code>name</code> 变量将包含一个 <code>Ident</code> 结构体实例，当打印时，它将是字符串 <code>\"Pancakes\"</code>，即列表 20-37 中结构体的名称。",
    "_note": ""
  },
  "The stringify! macro used here is built into Rust. It takes a Rust expression, such as 1 + 2, and at compile time turns the expression into a string literal, such as \"1 + 2\". This is different from format! or println!, macros which evaluate the expression and then turn the result into a String. There is a possibility that the #name input might be an expression to print literally, so we use stringify!. Using stringify! also saves an allocation by converting #name to a string literal at compile time.": {
    "_translate": "这里使用的 <code>stringify!</code> 宏是 Rust 内置的。它接受一个 Rust 表达式，例如 <code>1 + 2</code>，并在编译时将该表达式转换为字符串字面量，例如 <code>\"1 + 2\"</code>。这与 <code>format!</code> 或 <code>println!</code> 宏不同，后者会先评估表达式，然后将结果转换为 <code>String</code>。有可能 <code>#name</code> 输入是一个需要字面打印的表达式，因此我们使用 <code>stringify!</code>。使用 <code>stringify!</code> 还可以通过在编译时将 <code>#name</code> 转换为字符串字面量来节省分配。",
    "_note": ""
  },
  "Put the code in Listing 20-37 into src/main.rs, and run cargo run: it should print Hello, Macro! My name is Pancakes! The implementation of the HelloMacro trait from the procedural macro was included without the pancakes crate needing to implement it; the #[derive(HelloMacro)] added the trait implementation.": {
    "_translate": "将清单 20-37 中的代码放入 <em>src/main.rs</em>，并运行 <code>cargo run</code>：它应该打印 <code>Hello, Macro! My name is Pancakes!</code> 从过程宏实现的 <code>HelloMacro</code> 特性被包含进来，而无需 <code>pancakes</code> crate 自身实现它；<code>#[derive(HelloMacro)]</code> 添加了特性实现。",
    "_note": ""
  },
  "Attribute-like macros are similar to custom derive macros, but instead of generating code for the derive attribute, they allow you to create new attributes. They’re also more flexible: derive only works for structs and enums; attributes can be applied to other items as well, such as functions. Here’s an example of using an attribute-like macro. Say you have an attribute named route that annotates functions when using a web application framework:": {
    "_translate": "属性宏类似于自定义<code>derive</code>宏，但它们不是为<code>derive</code>属性生成代码，而是允许你创建新的属性。它们也更加灵活：<code>derive</code>仅适用于结构体和枚举；而属性可以应用于其他项目，例如函数。以下是一个使用属性宏的示例。假设你有一个名为<code>route</code>的属性，用于在使用Web应用程序框架时注解函数：",
    "_note": ""
  },
  "Whew! Now you have some Rust features in your toolbox that you likely won’t use often, but you’ll know they’re available in very particular circumstances. We’ve introduced several complex topics so that when you encounter them in error message suggestions or in other people’s code, you’ll be able to recognize these concepts and syntax. Use this chapter as a reference to guide you to solutions.": {
    "_translate": "呼！现在你已经掌握了一些你可能不会经常使用，但在特定情况下会知道它们可用的 Rust 特性。我们介绍了几个复杂的话题，这样当你在错误消息建议或其他人的代码中遇到它们时，你能够识别这些概念和语法。将本章作为参考，引导你找到解决方案。",
    "_note": ""
  },
  "The comma following $() indicates that a literal comma separator character must appear between each instance of the code that matches the code in $(). The * specifies that the pattern matches zero or more of whatever precedes the *.": {
    "_translate": "逗号跟随在 <code>$()</code> 之后表示必须在每个与 <code>$()</code> 中的代码匹配的代码实例之间出现一个字面上的逗号分隔符。\n<code>*</code> 指定模式匹配零个或多个 <code>*</code> 前面的任何内容。",
    "_note": ""
  },
  "Next, in Listing 20-38, we’ll define the HelloMacro trait and its associated function.": {
    "_translate": "接下来，在清单 20-38 中，我们将定义 <code>HelloMacro</code> 特性和其关联的函数。",
    "_note": ""
  },
  "We get an Ident struct instance containing the name (identifier) of the annotated type using ast.ident. The struct in Listing 20-41 shows that when we run the impl_hello_macro function on the code in Listing 20-37, the ident we get will have the ident field with a value of \"Pancakes\". Thus the name variable in Listing 20-42 will contain an Ident struct instance that, when printed, will be the string \"Pancakes\", the name of the struct in Listing 20-37.": {
    "_translate": "我们使用 <code>ast.ident</code> 获取一个包含注解类型名称（标识符）的 <code>Ident</code> 结构体实例。列表 20-41 中的结构体显示，当我们对列表 20-37 中的代码运行 <code>impl_hello_macro</code> 函数时，我们得到的 <code>ident</code> 将具有值为 <code>\"Pancakes\"</code> 的 <code>ident</code> 字段。因此，列表 20-42 中的 <code>name</code> 变量将包含一个 <code>Ident</code> 结构体实例，当打印时，它将是字符串 <code>\"Pancakes\"</code>，即列表 20-37 中结构体的名称。",
    "_note": ""
  },
  "Attribute-Like Macros": {
    "_translate": "<a class=\"header\" href=\"#attribute-like-macros\">类似属性的宏</a>",
    "_note": ""
  },
  "At this point, cargo build should complete successfully in both hello_macro and hello_macro_derive. Let’s hook up these crates to the code in Listing 20-37 to see the procedural macro in action! Create a new binary project in your projects directory using cargo new pancakes. We need to add hello_macro and hello_macro_derive as dependencies in the pancakes crate’s Cargo.toml. If you’re publishing your versions of hello_macro and hello_macro_derive to crates.io, they would be regular dependencies; if not, you can specify them as path dependencies as follows:": {
    "_translate": "此时，<code>cargo build</code> 应该在 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 中都成功完成。让我们将这些 crates 连接到列表 20-37 中的代码，看看过程宏如何工作！在 <em>projects</em> 目录中使用 <code>cargo new pancakes</code> 创建一个新的二进制项目。我们需要在 <code>pancakes</code> crate 的 <em>Cargo.toml</em> 中添加 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 作为依赖项。如果你将 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 的版本发布到 <a href=\"https://crates.io/\">crates.io</a><!-- ignore -->，它们将是常规依赖项；如果不是，你可以将它们指定为 <code>path</code> 依赖项，如下所示：",
    "_note": ""
  },
  "Function-Like Macros": {
    "_translate": "<a class=\"header\" href=\"#function-like-macros\">函数式宏</a>",
    "_note": ""
  },
  "Function-like macros define macros that look like function calls. Similarly to macro_rules! macros, they’re more flexible than functions; for example, they can take an unknown number of arguments. However, macro_rules! macros can only be defined using the match-like syntax we discussed in “Declarative Macros with macro_rules! for General Metaprogramming” earlier. Function-like macros take a TokenStream parameter, and their definition manipulates that TokenStream using Rust code as the other two types of procedural macros do. An example of a function-like macro is an sql! macro that might be called like so:": {
    "_translate": "函数式宏定义了看起来像函数调用的宏。类似于<code>macro_rules!</code>宏，它们比函数更灵活；例如，它们可以接受未知数量的参数。然而，<code>macro_rules!</code>宏只能使用我们在<a href=\"#declarative-macros-with-macro_rules-for-general-metaprogramming\">“使用<code>macro_rules!</code>的声明式宏进行通用元编程”</a>中讨论的匹配语法来定义。函数式宏接受一个<code>TokenStream</code>参数，并且它们的定义使用Rust代码来操作这个<code>TokenStream</code>，就像其他两种过程宏一样。一个函数式宏的例子是<code>sql!</code>宏，它可能被这样调用：",
    "_note": ""
  },
  "Declarative Macros for General Metaprogramming": {
    "_translate": "<a class=\"header\" href=\"#declarative-macros-for-general-metaprogramming\">用于通用元编程的声明式宏</a>",
    "_note": ""
  },
  "Custom derive Macros": {
    "_translate": "<a class=\"header\" href=\"#custom-derive-macros\">自定义 <code>derive</code> 宏</a>",
    "_note": ""
  },
  "We’ve used macros like println! throughout this book, but we haven’t fully explored what a macro is and how it works. The term macro refers to a family of features in Rust—declarative macros with macro_rules! and three kinds of procedural macros:": {
    "_translate": "我们在这本书中使用了像 <code>println!</code> 这样的宏，但还没有完全探讨宏是什么以及它是如何工作的。术语 <em>宏</em> 指的是 Rust 中的一组特性——声明式宏使用 <code>macro_rules!</code> 和三种过程宏：",
    "_note": ""
  },
  "A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: We can call println!(\"hello\") with one argument or println!(\"hello {}\", name) with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can’t, because it gets called at runtime and a trait needs to be implemented at compile time.": {
    "_translate": "函数签名必须声明函数的参数数量和类型。另一方面，宏可以接受可变数量的参数：我们可以用一个参数调用 <code>println!(\"hello\")</code> 或用两个参数调用 <code>println!(\"hello {}\", name)</code>。此外，宏在编译器解释代码含义之前就会展开，因此宏可以例如在给定类型上实现一个特质。函数则不能，因为函数是在运行时被调用的，而特质需要在编译时实现。",
    "_note": ""
  },
  "The most widely used form of macros in Rust is the declarative macro. These are also sometimes referred to as “macros by example,” “macro_rules! macros,” or just plain “macros.” At their core, declarative macros allow you to write something similar to a Rust match expression. As discussed in Chapter 6, match expressions are control structures that take an expression, compare the resultant value of the expression to patterns, and then run the code associated with the matching pattern. Macros also compare a value to patterns that are associated with particular code: In this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.": {
    "_translate": "在 Rust 中最广泛使用的宏形式是<em>声明式宏</em>。这些宏有时也被称为“示例宏”、“<code>macro_rules!</code> 宏”或简单的“宏”。在核心上，声明式宏允许你编写类似于 Rust <code>match</code> 表达式的内容。正如在第 6 章中讨论的，<code>match</code> 表达式是控制结构，它们接受一个表达式，将该表达式的结果值与模式进行比较，然后运行与匹配模式相关联的代码。宏也对值与特定代码相关联的模式进行比较：在这种情况下，值是传递给宏的字面 Rust 源代码；模式与该源代码的结构进行比较；当匹配时，与每个模式相关联的代码将替换传递给宏的代码。这一切都在编译期间发生。",
    "_note": ""
  },
  "The function that defines a procedural macro takes a TokenStream as an input and produces a TokenStream as an output. The TokenStream type is defined by the proc_macro crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: The source code that the macro is operating on makes up the input TokenStream, and the code the macro produces is the output TokenStream. The function also has an attribute attached to it that specifies which kind of procedural macro we’re creating. We can have multiple kinds of procedural macros in the same crate.": {
    "_translate": "定义过程宏的函数以 <code>TokenStream</code> 作为输入，并生成一个 <code>TokenStream</code> 作为输出。 <code>TokenStream</code> 类型由 Rust 自带的 <code>proc_macro</code> crate 定义，表示一个令牌序列。这是宏的核心：宏操作的源代码构成了输入 <code>TokenStream</code>，而宏生成的代码则是输出 <code>TokenStream</code>。该函数还附加了一个属性，指定了我们正在创建的过程宏的类型。我们可以在同一个 crate 中有多种类型的过程宏。",
    "_note": ""
  },
  "The next step is to define the procedural macro. At the time of this writing, procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: For a crate named foo, a custom derive procedural macro crate is called foo_derive. Let’s start a new crate called hello_macro_derive inside our hello_macro project:": {
    "_translate": "下一步是定义过程宏。在撰写本文时，\n过程宏需要位于它们自己的 crate 中。最终，这一限制\n可能会被取消。crate 和宏 crate 的结构约定如下：对于名为 <code>foo</code> 的 crate，自定义 <code>derive</code> 过程宏 crate\n称为 <code>foo_derive</code>。让我们在 <code>hello_macro</code> 项目中\n开始一个名为 <code>hello_macro_derive</code> 的新 crate：",
    "_note": ""
  },
  "Let’s create a crate named hello_macro that defines a trait named HelloMacro with one associated function named hello_macro. Rather than making our users implement the HelloMacro trait for each of their types, we’ll provide a procedural macro so that users can annotate their type with #[derive(HelloMacro)] to get a default implementation of the hello_macro function. The default implementation will print Hello, Macro! My name is TypeName! where TypeName is the name of the type on which this trait has been defined. In other words, we’ll write a crate that enables another programmer to write code like Listing 20-37 using our crate.": {
    "_translate": "让我们创建一个名为 <code>hello_macro</code> 的 crate，该 crate 定义了一个名为 <code>HelloMacro</code> 的 trait，其中有一个关联函数名为 <code>hello_macro</code>。我们不是让用户为他们的每个类型实现 <code>HelloMacro</code> trait，而是提供一个过程宏，以便用户可以通过 <code>#[derive(HelloMacro)]</code> 注解他们的类型来获得 <code>hello_macro</code> 函数的默认实现。默认实现将打印 <code>Hello, Macro! My name is TypeName!</code>，其中 <code>TypeName</code> 是定义此 trait 的类型的名称。换句话说，我们将编写一个 crate，使其他程序员能够使用我们的 crate 编写如清单 20-37 所示的代码。",
    "_note": ""
  },
  "Notice that we’ve split the code into the hello_macro_derive function, which is responsible for parsing the TokenStream, and the impl_hello_macro function, which is responsible for transforming the syntax tree: This makes writing a procedural macro more convenient. The code in the outer function (hello_macro_derive in this case) will be the same for almost every procedural macro crate you see or create. The code you specify in the body of the inner function (impl_hello_macro in this case) will be different depending on your procedural macro’s purpose.": {
    "_translate": "注意，我们将代码分成了 <code>hello_macro_derive</code> 函数，该函数负责解析 <code>TokenStream</code>，以及 <code>impl_hello_macro</code> 函数，该函数负责转换语法树：这使得编写过程宏更加方便。外部函数中的代码（在这种情况下为 <code>hello_macro_derive</code>）对于你看到或创建的几乎每个过程宏 crate 都是相同的。你在内部函数体中指定的代码（在这种情况下为 <code>impl_hello_macro</code>）将根据你的过程宏的目的而不同。",
    "_note": ""
  },
  "The syn crate parses Rust code from a string into a data structure that we can perform operations on. The quote crate turns syn data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: Writing a full parser for Rust code is no simple task.": {
    "_translate": "<code>syn</code> crate 从字符串中解析 Rust 代码到我们可以操作的数据结构。<code>quote</code> crate 将 <code>syn</code> 数据结构转换回 Rust 代码。这些 crate 使解析我们可能需要处理的任何类型的 Rust 代码变得更加简单：编写一个完整的 Rust 代码解析器绝非易事。",
    "_note": ""
  },
  "The quote! macro lets us define the Rust code that we want to return. The compiler expects something different from the direct result of the quote! macro’s execution, so we need to convert it to a TokenStream. We do this by calling the into method, which consumes this intermediate representation and returns a value of the required TokenStream type.": {
    "_translate": "<code>quote!</code> 宏让我们定义我们想要返回的 Rust 代码。编译器期望从 <code>quote!</code> 宏的直接执行结果中得到不同的东西，所以我们需要将其转换为 <code>TokenStream</code>。我们通过调用 <code>into</code> 方法来实现这一点，该方法消耗这个中间表示并返回所需 <code>TokenStream</code> 类型的值。",
    "_note": ""
  },
  "We get an Ident struct instance containing the name (identifier) of the annotated type using ast.ident. The struct in Listing 20-41 shows that when we run the impl_hello_macro function on the code in Listing 20-37, the ident we get will have the ident field with a value of \"Pancakes\". Thus, the name variable in Listing 20-42 will contain an Ident struct instance that, when printed, will be the string \"Pancakes\", the name of the struct in Listing 20-37.": {
    "_translate": "我们使用 <code>ast.ident</code> 获取一个包含注解类型名称（标识符）的 <code>Ident</code> 结构体实例。列表 20-41 中的结构体显示，当我们对列表 20-37 中的代码运行 <code>impl_hello_macro</code> 函数时，我们得到的 <code>ident</code> 将具有值为 <code>\"Pancakes\"</code> 的 <code>ident</code> 字段。因此，列表 20-42 中的 <code>name</code> 变量将包含一个 <code>Ident</code> 结构体实例，当打印时，它将是字符串 <code>\"Pancakes\"</code>，即列表 20-37 中结构体的名称。",
    "_note": ""
  },
  "The quote! macro also provides some very cool templating mechanics: We can enter #name, and quote! will replace it with the value in the variable name. You can even do some repetition similar to the way regular macros work. Check out the quote crate’s docs for a thorough introduction.": {
    "_translate": "<code>quote!</code> 宏还提供了一些非常酷的模板机制：我们可以输入 <code>#name</code>，<code>quote!</code> 会将其替换为变量 <code>name</code> 中的值。你甚至可以像普通宏那样进行一些重复操作。查看 <a href=\"https://docs.rs/quote\">the <code>quote</code> crate’s docs</a> 以获得详细的介绍。",
    "_note": ""
  },
  "The stringify! macro used here is built into Rust. It takes a Rust expression, such as 1 + 2, and at compile time turns the expression into a string literal, such as \"1 + 2\". This is different from format! or println!, which are macros that evaluate the expression and then turn the result into a String. There is a possibility that the #name input might be an expression to print literally, so we use stringify!. Using stringify! also saves an allocation by converting #name to a string literal at compile time.": {
    "_translate": "这里使用的 <code>stringify!</code> 宏是 Rust 内置的。它接受一个 Rust 表达式，例如 <code>1 + 2</code>，并在编译时将该表达式转换为字符串字面量，例如 <code>\"1 + 2\"</code>。这与 <code>format!</code> 或 <code>println!</code> 不同，后者是评估表达式然后将结果转换为 <code>String</code> 的宏。有可能 <code>#name</code> 输入是一个需要字面打印的表达式，因此我们使用 <code>stringify!</code>。使用 <code>stringify!</code> 还可以通过在编译时将 <code>#name</code> 转换为字符串字面量来节省分配。",
    "_note": ""
  },
  "Put the code in Listing 20-37 into src/main.rs, and run cargo run: It should print Hello, Macro! My name is Pancakes!. The implementation of the HelloMacro trait from the procedural macro was included without the pancakes crate needing to implement it; the #[derive(HelloMacro)] added the trait implementation.": {
    "_translate": "将清单 20-37 中的代码放入 <em>src/main.rs</em>，并运行 <code>cargo run</code>：它应该打印 <code>Hello, Macro! My name is Pancakes!</code>。来自过程宏的 <code>HelloMacro</code> 特性的实现被包含进来，而无需 <code>pancakes</code> crate 实现它；<code>#[derive(HelloMacro)]</code> 添加了特性实现。",
    "_note": ""
  },
  "Other than that, attribute-like macros work the same way as custom derive macros: You create a crate with the proc-macro crate type and implement a function that generates the code you want!": {
    "_translate": "除此之外，属性宏的工作方式与自定义<code>derive</code>宏相同：您需要创建一个<code>proc-macro</code>类型的crate，并实现一个生成所需代码的函数！",
    "_note": ""
  },
  "This definition is similar to the custom derive macro’s signature: We receive the tokens that are inside the parentheses and return the code we wanted to generate.": {
    "_translate": "这个定义与自定义 <code>derive</code> 宏的签名类似：我们接收括号内的标记并返回我们想要生成的代码。",
    "_note": ""
  },
  "Function-like macros define macros that look like function calls. Similarly to macro_rules! macros, they’re more flexible than functions; for example, they can take an unknown number of arguments. However, macro_rules! macros can only be defined using the match-like syntax we discussed in the “Declarative Macros for General Metaprogramming” section earlier. Function-like macros take a TokenStream parameter, and their definition manipulates that TokenStream using Rust code as the other two types of procedural macros do. An example of a function-like macro is an sql! macro that might be called like so:": {
    "_translate": "函数式宏定义了看起来像函数调用的宏。类似于<code>macro_rules!</code>宏，它们比函数更灵活；例如，它们可以接受未知数量的参数。然而，<code>macro_rules!</code>宏只能使用我们在<a href=\"#declarative-macros-with-macro_rules-for-general-metaprogramming\">“声明式宏用于通用元编程”</a>部分中讨论的匹配语法来定义。函数式宏接受一个<code>TokenStream</code>参数，并且它们的定义使用Rust代码来操作这个<code>TokenStream</code>，就像其他两种过程宏一样。一个函数式宏的例子是<code>sql!</code>宏，它可能被这样调用：",
    "_note": ""
  }
}