<!DOCTYPE html><html lang="zh-CN" class="light sidebar-visible" dir="ltr"><head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>编程一个猜数字游戏 - 《Rust编程语言》</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    <meta name="title" content="Rust 中文"><meta property="og:title" content="Rust 中文"><meta name="description" content="Rust 中文文档"><meta property="og:description" content="Rust 中文文档"><meta name="url" content="https://rust.xheldon.com"><meta property="og:url" content="https://rust.xheldon.com"><script src="https://www.googletagmanager.com/gtag/js?id=G-V7NE1X37EX"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-V7NE1X37EX')</script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486286026923411"></script><style>/* hover 显示原文 */
p[data-x-en],
li[data-x-en] {
  position: relative;
}
p[data-x-en]:hover::after,
li[data-x-en]:hover::after {
  visibility: visible;
  opacity: 1;
}
p[data-x-en]::after,
li[data-x-en]::after {
  content: attr(data-x-en);
  display: block;
  font-size: 12px;
  transition: all 0.2s 0.3s;
  visibility: hidden;
  opacity: 0;
  background: #cccccc;
  z-index: 99;
  border-radius: 4px;
  padding: 5px 10px;
  position: absolute;
  top: 100%;
  left: 0;
}
/* 译者注释内容 */
div[type='comment'] {
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  background: #eee;
}
div[type='comment']::before {
  content: '译者注: ';
  font-weight: 900;
}
header a.logo {
  position: relative;
}
header a.logo::after {
  content: '中文';
  position: absolute;
  left: calc(100% + 5px);
  font-size: 12px;
  width: 50px;
  top: -5px;
}
#banner-info {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  background: rgba(255, 255, 255, 0.9);
  font-size: 12px;
  padding: 0;
  z-index: 999;
}
#add-info {
  font-size: 14px;
}
blockquote {
  border-left: 5px solid #ccc;
  padding-left: 10px;
  margin-left: 0;
}
.content {
  overflow-y: none;
}
</style></head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky"><div id="banner-info">本文档为 AI + 人工翻译，hover 可以显示原文。当前页翻译有问题？<a style="cursor: pointer;" href="https://github.com/Xheldon/rust-book-cn/blob/main/dict/ch02-00-guessing-game-tutorial.json" target="_blank">我来翻译！</a></div>
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    <a href="https://github.com/Xheldon/rust-book-cn" target="_blank"><i class="fa fa-language"></i></a><a href="https://www.xheldon.com" target="_blank"><i class="fa fa-id-card"></i></a></div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="programming-a-guessing-game"><a class="header" href="#programming-a-guessing-game">编程一个猜数字游戏</a></h1>
<p data-x-en="Let’s jump into Rust by working through a hands-on project together! This chapter introduces you to a few common Rust concepts by showing you how to use them in a real program. You’ll learn about let, match, methods, associated functions, external crates, and more! In the following chapters, we’ll explore these ideas in more detail. In this chapter, you’ll just practice the fundamentals.">让我们通过一起完成一个动手项目来进入 Rust！本章通过向您展示如何在实际程序中使用一些常见的 Rust 概念来介绍它们。您将学习关于 <code>let</code>、<code>match</code>、方法、关联函数、外部 crate 等！在接下来的章节中，我们将更详细地探讨这些概念。在本章中，您将只练习基础内容。</p>
<p data-x-en="We’ll implement a classic beginner programming problem: a guessing game. Here’s how it works: the program will generate a random integer between 1 and 100. It will then prompt the player to enter a guess. After a guess is entered, the program will indicate whether the guess is too low or too high. If the guess is correct, the game will print a congratulatory message and exit.">我们将实现一个经典的初学者编程问题：猜数字游戏。这里是游戏的规则：程序将生成一个1到100之间的随机整数。然后，程序将提示玩家输入一个猜测。输入猜测后，程序将指示猜测的数字是太低还是太高。如果猜测正确，游戏将打印一条祝贺消息并退出。</p>
<h2 id="setting-up-a-new-project"><a class="header" href="#setting-up-a-new-project">设置新项目</a></h2>
<p data-x-en="To set up a new project, go to the projects directory that you created in Chapter 1 and make a new project using Cargo, like so:">要设置一个新项目，请转到您在第 1 章创建的 <em>projects</em> 目录，并使用 Cargo 创建一个新项目，如下所示：</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p data-x-en="The first command, cargo new, takes the name of the project (guessing_game) as the first argument. The second command changes to the new project’s directory.">第一个命令，<code>cargo new</code>，接受项目名称（<code>guessing_game</code>）作为第一个参数。第二个命令切换到新项目的目录。</p>
<p data-x-en="Look at the generated Cargo.toml file:">查看生成的<em>Cargo.toml</em>文件：</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p data-x-en="Filename: Cargo.toml"><span class="filename">文件名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
<p data-x-en="As you saw in Chapter 1, cargo new generates a “Hello, world!” program for you. Check out the src/main.rs file:">正如你在第 1 章中看到的，<code>cargo new</code> 为你生成了一个“Hello, world!”程序。查看 <em>src/main.rs</em> 文件：</p>
<p data-x-en="Filename: src/main.rs"><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p data-x-en="Now let’s compile this “Hello, world!” program and run it in the same step using the cargo run command:">现在让我们使用 <code>cargo run</code> 命令在同一步骤中编译并运行这个“Hello, world!”程序：</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.20s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p data-x-en="The run command comes in handy when you need to rapidly iterate on a project, as we’ll do in this game, quickly testing each iteration before moving on to the next one."><code>run</code> 命令在你需要快速迭代项目时非常有用，就像我们在制作这个游戏时一样，每次迭代后快速测试，然后再进行下一次迭代。</p>
<p data-x-en="Reopen the src/main.rs file. You’ll be writing all the code in this file.">重新打开 <em>src/main.rs</em> 文件。你将在该文件中编写所有代码。</p>
<h2 id="processing-a-guess"><a class="header" href="#processing-a-guess">处理一个猜测</a></h2>
<p data-x-en="The first part of the guessing game program will ask for user input, process that input, and check that the input is in the expected form. To start, we’ll allow the player to input a guess. Enter the code in Listing 2-1 into src/main.rs.">猜数字游戏程序的第一部分将请求用户输入，处理该输入，并检查输入是否为预期的形式。首先，我们将允许玩家输入一个猜测。将清单 2-1 中的代码输入到 <em>src/main.rs</em>。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}</code></pre>
<figcaption>Listing 2-1: Code that gets a guess from the user and prints it</figcaption>
</figure>
<p data-x-en="This code contains a lot of information, so let’s go over it line by line. To obtain user input and then print the result as output, we need to bring the io input/output library into scope. The io library comes from the standard library, known as std:">这段代码包含了很多信息，所以我们逐行来分析。为了获取用户输入并将其作为输出打印，我们需要将 <code>io</code> 输入/输出库引入作用域。<code>io</code> 库来自标准库，称为 <code>std</code>：</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p data-x-en="By default, Rust has a set of items defined in the standard library that it brings into the scope of every program. This set is called the prelude, and you can see everything in it in the standard library documentation.">默认情况下，Rust 在每个程序的作用域中引入了一组标准库中定义的项。这组项被称为 <em>前言</em>，您可以在 <a href="../std/prelude/index.html">标准库文档</a> 中查看其中的所有内容。</p>
<p data-x-en="If a type you want to use isn’t in the prelude, you have to bring that type into scope explicitly with a use statement. Using the std::io library provides you with a number of useful features, including the ability to accept user input.">如果您想使用的类型不在前言中，您必须使用 <code>use</code> 语句将该类型显式地带入作用域。使用 <code>std::io</code> 库为您提供了一些有用的功能，包括接受用户输入的能力。</p>
<p data-x-en="As you saw in Chapter 1, the main function is the entry point into the program:">正如你在第 1 章中看到的，<code>main</code> 函数是程序的入口点：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p data-x-en="The fn syntax declares a new function; the parentheses, (), indicate there are no parameters; and the curly bracket, {, starts the body of the function."><code>fn</code> 语法声明一个新函数；括号 <code>()</code> 表示没有参数；而大括号 <code>{</code> 开始函数的主体。</p>
<p data-x-en="As you also learned in Chapter 1, println! is a macro that prints a string to the screen:">正如你在第 1 章中所学的，<code>println!</code> 是一个将字符串打印到屏幕上的宏：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!("Guess the number!");

    println!("Please input your guess.");
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p data-x-en="This code is printing a prompt stating what the game is and requesting input from the user.">这段代码正在打印一个提示，说明游戏是什么，并请求用户输入。</p>
<h3 id="storing-values-with-variables"><a class="header" href="#storing-values-with-variables">使用变量存储值</a></h3>
<p data-x-en="Next, we’ll create a variable to store the user input, like this:">接下来，我们将创建一个<em>变量</em>来存储用户输入，如下所示：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p data-x-en="Now the program is getting interesting! There’s a lot going on in this little line. We use the let statement to create the variable. Here’s another example:">现在程序变得有趣了！这短短的一行代码里发生了许多事情。我们使用 <code>let</code> 语句来创建变量。这里有一个另一个例子：</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p data-x-en="This line creates a new variable named apples and binds it to the value 5. In Rust, variables are immutable by default, meaning once we give the variable a value, the value won’t change. We’ll be discussing this concept in detail in the “Variables and Mutability” section in Chapter 3. To make a variable mutable, we add mut before the variable name:">这行代码创建了一个名为<code>apples</code>的新变量，并将其绑定到值5。在
Rust中，默认情况下变量是不可变的，这意味着一旦我们给变量赋值，该值就不会改变。我们将在
<a href="ch03-01-variables-and-mutability.html#variables-and-mutability">“变量和可变性”</a><!-- ignore -->
章节3中详细讨论这个概念。要使变量可变，我们在变量名前添加<code>mut</code>：</p>
<pre><code class="language-rust ignore">let apples = 5; // immutable
let mut bananas = 5; // mutable</code></pre>
<section class="note" aria-role="note">
<p data-x-en="Note: The // syntax starts a comment that continues until the end of the line. Rust ignores everything in comments. We’ll discuss comments in more detail in Chapter 3.">注意：`<code>//</code>` 语法开始一个注释，该注释一直持续到行末。Rust 会忽略注释中的所有内容。我们将在 <a href="ch03-04-comments.html">第 3 章</a><!-- ignore --> 中更详细地讨论注释。</p>
</section>
<p data-x-en="Returning to the guessing game program, you now know that let mut guess will introduce a mutable variable named guess. The equal sign (=) tells Rust we want to bind something to the variable now. On the right of the equal sign is the value that guess is bound to, which is the result of calling String::new, a function that returns a new instance of a String. String is a string type provided by the standard library that is a growable, UTF-8 encoded bit of text.">回到猜数字游戏程序，你现在知道 <code>let mut guess</code> 会引入一个名为 <code>guess</code> 的可变变量。等号 (<code>=</code>) 告诉 Rust 我们现在想要将某个值绑定到这个变量。等号右边是 <code>guess</code> 绑定的值，即调用 <code>String::new</code> 函数的结果，该函数返回一个新的 <code>String</code> 实例。<a href="../std/string/struct.String.html"><code>String</code></a><!-- ignore --> 是标准库提供的字符串类型，它是一个可增长的、UTF-8 编码的文本片段。</p>
<p data-x-en="The :: syntax in the ::new line indicates that new is an associated function of the String type. An associated function is a function that’s implemented on a type, in this case String. This new function creates a new, empty string. You’ll find a new function on many types because it’s a common name for a function that makes a new value of some kind."><code>::</code> 语法在 <code>::new</code> 行中表示 <code>new</code> 是 <code>String</code> 类型的关联函数。一个 <em>关联函数</em> 是在类型上实现的函数，在这种情况下是 <code>String</code>。这个 <code>new</code> 函数创建一个新的、空的字符串。您会在许多类型上找到 <code>new</code> 函数，因为它是创建某种新值的函数的常用名称。</p>
<p data-x-en="In full, the let mut guess = String::new(); line has created a mutable variable that is currently bound to a new, empty instance of a String. Whew!"><code>let mut guess = String::new();</code> 这一行代码创建了一个可变变量，当前绑定到一个新的、空的 <code>String</code> 实例。</p>
<h3 id="receiving-user-input"><a class="header" href="#receiving-user-input">接收用户输入</a></h3>
<p data-x-en="Recall that we included the input/output functionality from the standard library with use std::io; on the first line of the program. Now we’ll call the stdin function from the io module, which will allow us to handle user input:">回想我们在程序的第一行用 <code>use std::io;</code> 包含了标准库中的输入/输出功能。现在我们将调用 <code>io</code> 模块中的 <code>stdin</code> 函数，这将使我们能够处理用户输入：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p data-x-en="If we hadn’t imported the io library with use std::io; at the beginning of the program, we could still use the function by writing this function call as std::io::stdin. The stdin function returns an instance of std::io::Stdin, which is a type that represents a handle to the standard input for your terminal.">如果我们没有在程序开始时通过 <code>use std::io;</code> 导入 <code>io</code> 库，我们仍然可以通过将此函数调用写为 <code>std::io::stdin</code> 来使用该函数。 <code>stdin</code> 函数返回一个 <a href="../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore --> 的实例，这是一个表示终端标准输入句柄的类型。</p>
<p data-x-en="Next, the line .read_line(&amp;mut guess) calls the read_line method on the standard input handle to get input from the user. We’re also passing &amp;mut guess as the argument to read_line to tell it what string to store the user input in. The full job of read_line is to take whatever the user types into standard input and append that into a string (without overwriting its contents), so we therefore pass that string as an argument. The string argument needs to be mutable so the method can change the string’s content.">接下来，这行代码 <code>.read_line(&amp;mut guess)</code> 调用了标准输入句柄上的 <a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!--
ignore --> 方法以获取用户的输入。
我们还传递了 <code>&amp;mut guess</code> 作为 <code>read_line</code> 的参数，以告诉它将用户输入存储在哪个字符串中。<code>read_line</code> 的完整任务是将用户在标准输入中输入的内容追加到一个字符串中（不会覆盖其内容），因此我们传递该字符串作为参数。字符串参数需要是可变的，以便方法可以更改字符串的内容。</p>
<p data-x-en="The &amp; indicates that this argument is a reference, which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times. References are a complex feature, and one of Rust’s major advantages is how safe and easy it is to use references. You don’t need to know a lot of those details to finish this program. For now, all you need to know is that, like variables, references are immutable by default. Hence, you need to write &amp;mut guess rather than &amp;guess to make it mutable. (Chapter 4 will explain references more thoroughly.)"><code>&amp;</code> 表示这个参数是一个 <em>引用</em>，这为你提供了一种方式，让你的代码的多个部分可以访问同一块数据，而无需将该数据多次复制到内存中。引用是一个复杂的特性，而 Rust 的一个主要优势在于使用引用既安全又简单。你不需要了解这些细节中的很多内容就可以完成这个程序。目前，你只需要知道，像变量一样，引用默认是不可变的。因此，你需要写 <code>&amp;mut guess</code> 而不是 <code>&amp;guess</code> 来使其可变。（第 4 章将更详细地解释引用。）</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="handling-potential-failure-with-result"><a class="header" href="#handling-potential-failure-with-result">使用 <code>Result</code> 处理潜在的失败</a></h3>
<p data-x-en="We’re still working on this line of code. We’re now discussing a third line of text, but note that it’s still part of a single logical line of code. The next part is this method:">我们仍在处理这行代码。我们现在讨论的是第三行文本，但请注意，它仍然是单个逻辑行代码的一部分。下一部分是这个方法：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect("Failed to read line");
<span class="boring">
</span><span class="boring">    println!("You guessed: {}", guess);
</span><span class="boring">}</span></code></pre>
<p data-x-en="We could have written this code as:">我们可以这样编写这段代码：</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect("Failed to read line");</code></pre>
<p data-x-en="However, one long line is difficult to read, so it’s best to divide it. It’s often wise to introduce a newline and other whitespace to help break up long lines when you call a method with the .method_name() syntax. Now let’s discuss what this line does.">然而，一行过长的代码难以阅读，因此最好将其分隔。在使用 <code>.method_name()</code> 语法调用方法时，通常明智的做法是引入换行符和其他空白，以帮助分隔长行。现在让我们讨论这行代码的作用。</p>
<p data-x-en="As mentioned earlier, read_line puts whatever the user enters into the string we pass to it, but it also returns a Result value. Result is an enumeration, often called an enum, which is a type that can be in one of multiple possible states. We call each possible state a variant.">如前所述，<code>read_line</code> 会将用户输入的内容放入我们传递给它的字符串中，但它也会返回一个 <code>Result</code> 值。 <a href="../std/result/enum.Result.html"><code>Result</code></a><!--
ignore --> 是一个 <a href="ch06-00-enums.html"><em>枚举</em></a><!-- ignore -->，通常称为 <em>enum</em>，
这是一种可以处于多种可能状态之一的类型。我们称每种可能的状态为一个 <em>变体</em>。</p>
<p data-x-en="Chapter 6 will cover enums in more detail. The purpose of these Result types is to encode error-handling information."><a href="ch06-00-enums.html">第6章</a><!-- ignore --> 将更详细地介绍枚举。这些 <code>Result</code> 类型的目的是编码错误处理信息。</p>
<p data-x-en="Result’s variants are Ok and Err. The Ok variant indicates the operation was successful, and inside Ok is the successfully generated value. The Err variant means the operation failed, and Err contains information about how or why the operation failed."><code>Result</code> 的变体是 <code>Ok</code> 和 <code>Err</code>。<code>Ok</code> 变体表示操作成功，<code>Ok</code> 内部包含成功生成的值。<code>Err</code> 变体表示操作失败，<code>Err</code> 包含有关操作失败的方式或原因的信息。</p>
<p data-x-en="Values of the Result type, like values of any type, have methods defined on them. An instance of Result has an expect method that you can call. If this instance of Result is an Err value, expect will cause the program to crash and display the message that you passed as an argument to expect. If the read_line method returns an Err, it would likely be the result of an error coming from the underlying operating system. If this instance of Result is an Ok value, expect will take the return value that Ok is holding and return just that value to you so you can use it. In this case, that value is the number of bytes in the user’s input."><code>Result</code> 类型的值，像任何类型的值一样，都有定义在其上的方法。一个 <code>Result</code> 的实例有一个 <a href="../std/result/enum.Result.html#method.expect"><code>expect</code> 方法</a><!-- ignore -->
你可以调用。如果这个 <code>Result</code> 的实例是一个 <code>Err</code> 值，<code>expect</code>
将导致程序崩溃并显示你传递给 <code>expect</code> 的参数消息。如果 <code>read_line</code> 方法返回一个 <code>Err</code>，它可能是来自底层操作系统的错误结果。
如果这个 <code>Result</code> 的实例是一个 <code>Ok</code> 值，<code>expect</code> 将获取 <code>Ok</code> 持有的返回值并仅返回该值给你，以便你可以使用它。
在这种情况下，该值是用户输入的字节数。</p>
<p data-x-en="If you don’t call expect, the program will compile, but you’ll get a warning:">如果你不调用<code>expect</code>，程序将编译，但你会收到一个警告：</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p data-x-en="Rust warns that you haven’t used the Result value returned from read_line, indicating that the program hasn’t handled a possible error.">Rust 警告你沒有使用從 <code>read_line</code> 返回的 <code>Result</code> 值，表明程序沒有處理可能的錯誤。</p>
<p data-x-en="The right way to suppress the warning is to actually write error-handling code, but in our case we just want to crash this program when a problem occurs, so we can use expect. You’ll learn about recovering from errors in Chapter 9.">正确的方法是编写错误处理代码来抑制警告，但在我们的情况下，当出现问题时，我们只是想让程序崩溃，所以我们可以使用<code>expect</code>。您将在<a href="ch09-02-recoverable-errors-with-result.html">第9章</a><!-- ignore -->中学习如何从错误中恢复。</p>
<h3 id="printing-values-with-println-placeholders"><a class="header" href="#printing-values-with-println-placeholders">使用 <code>println!</code> 占位符打印值</a></h3>
<p data-x-en="Aside from the closing curly bracket, there’s only one more line to discuss in the code so far:">除了结束的大括号外，到目前为止代码中只有一行需要讨论：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span>    println!("You guessed: {}", guess);
<span class="boring">}</span></code></pre>
<p data-x-en="This line prints the string that now contains the user’s input. The {} set of curly brackets is a placeholder: think of {} as little crab pincers that hold a value in place. When printing the value of a variable, the variable name can go inside the curly brackets. When printing the result of evaluating an expression, place empty curly brackets in the format string, then follow the format string with a comma-separated list of expressions to print in each empty curly bracket placeholder in the same order. Printing a variable and the result of an expression in one call to println! would look like this:">这行代码打印现在包含用户输入的字符串。`<code>{}</code>` 这组花括号是一个占位符：可以将 `<code>{}</code>` 想象为小螃蟹的钳子，用来夹住一个值。当打印变量的值时，变量名可以放在花括号内。当打印表达式求值的结果时，在格式字符串中放置空花括号，然后在格式字符串后面跟随一个以逗号分隔的表达式列表，按顺序打印每个空花括号占位符中的内容。在一个 `println!` 调用中同时打印变量和表达式的结果如下所示：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
<span class="boring">}</span></code></pre></pre>
<p data-x-en="This code would print x = 5 and y + 2 = 12.">这段代码会打印 <code>x = 5 和 y + 2 = 12</code>。</p>
<h3 id="testing-the-first-part"><a class="header" href="#testing-the-first-part">测试第一部分</a></h3>
<p data-x-en="Let’s test the first part of the guessing game. Run it using cargo run:">让我们测试猜数字游戏的第一部分。使用 <code>cargo run</code> 运行它：</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p data-x-en="At this point, the first part of the game is done: we’re getting input from the keyboard and then printing it.">到目前为止，游戏的第一部分已经完成：我们从键盘获取输入，然后打印出来。</p>
<h2 id="generating-a-secret-number"><a class="header" href="#generating-a-secret-number">生成一个秘密数字</a></h2>
<p data-x-en="Next, we need to generate a secret number that the user will try to guess. The secret number should be different every time so the game is fun to play more than once. We’ll use a random number between 1 and 100 so the game isn’t too difficult. Rust doesn’t yet include random number functionality in its standard library. However, the Rust team does provide a rand crate with said functionality.">接下来，我们需要生成一个用户将尝试猜测的密数。这个密数每次都应该不同，这样游戏才好玩，可以多次游玩。我们将使用1到100之间的随机数，使游戏不会太难。Rust 的标准库中目前还不包含随机数功能。但是，Rust 团队提供了一个 <a href="https://crates.io/crates/rand"><code>rand</code> crate</a>，具有所需的功能。</p>
<h3 id="using-a-crate-to-get-more-functionality"><a class="header" href="#using-a-crate-to-get-more-functionality">使用库来获得更多功能</a></h3>
<p data-x-en="Remember that a crate is a collection of Rust source code files. The project we’ve been building is a binary crate, which is an executable. The rand crate is a library crate, which contains code that is intended to be used in other programs and can’t be executed on its own.">记住，一个 crate 是一组 Rust 源代码文件的集合。我们一直在构建的项目是一个 <em>二进制 crate</em>，它是一个可执行文件。<code>rand</code> crate 是一个 <em>库 crate</em>，它包含的代码旨在被其他程序使用，不能单独执行。</p>
<p data-x-en="Cargo’s coordination of external crates is where Cargo really shines. Before we can write code that uses rand, we need to modify the Cargo.toml file to include the rand crate as a dependency. Open that file now and add the following line to the bottom, beneath the [dependencies] section header that Cargo created for you. Be sure to specify rand exactly as we have here, with this version number, or the code examples in this tutorial may not work:">Cargo 的外部 crate 协调是 Cargo 真正发光的地方。在我们能够编写使用 <code>rand</code> 的代码之前，我们需要修改 <em>Cargo.toml</em> 文件，将 <code>rand</code> crate 作为依赖项包含进去。现在打开该文件，并在 Cargo 为你创建的 <code>[dependencies]</code> 部分标题下方添加以下行。确保指定 <code>rand</code> 时与这里完全相同，包括这个版本号，否则本教程中的代码示例可能无法工作：</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p data-x-en="Filename: Cargo.toml"><span class="filename">文件名: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p data-x-en="In the Cargo.toml file, everything that follows a header is part of that section that continues until another section starts. In [dependencies] you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we specify the rand crate with the semantic version specifier 0.8.5. Cargo understands Semantic Versioning (sometimes called SemVer), which is a standard for writing version numbers. The specifier 0.8.5 is actually shorthand for ^0.8.5, which means any version that is at least 0.8.5 but below 0.9.0.">在 <em>Cargo.toml</em> 文件中，每个标题后面的所有内容都是该部分的一部分，直到另一个部分开始。在 <code>[dependencies]</code> 中，您告诉 Cargo 您的项目依赖于哪些外部 crate 以及您需要这些 crate 的哪些版本。在这种情况下，我们指定了版本为 <code>0.8.5</code> 的 <code>rand</code> crate。Cargo 理解 <a href="http://semver.org">语义化版本控制</a><!-- ignore -->（有时称为 <em>SemVer</em>），这是一种编写版本号的标准。版本说明符 <code>0.8.5</code> 实际上是 <code>^0.8.5</code> 的简写，这意味着任何版本至少为 0.8.5 但低于 0.9.0。</p>
<p data-x-en="Cargo considers these versions to have public APIs compatible with version 0.8.5, and this specification ensures you’ll get the latest patch release that will still compile with the code in this chapter. Any version 0.9.0 or greater is not guaranteed to have the same API as what the following examples use.">Cargo 认为这些版本与版本 0.8.5 具有兼容的公共 API，并且此规范确保您将获得最新的补丁版本，该版本仍可与本章中的代码编译。任何 0.9.0 或更高版本都不保证具有与以下示例使用的相同 API。</p>
<p data-x-en="Now, without changing any of the code, let’s build the project, as shown in Listing 2-2.">现在，不更改任何代码，让我们构建项目，如清单 2-2 所示。</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<figure class="listing">
<pre><code class="language-console">$ cargo build
    Updating crates.io index
     Locking 16 packages to latest compatible versions
      Adding wasi v0.11.0+wasi-snapshot-preview1 (latest: v0.13.3+wasi-0.2.2)
      Adding zerocopy v0.7.35 (latest: v0.8.9)
      Adding zerocopy-derive v0.7.35 (latest: v0.8.9)
  Downloaded syn v2.0.87
  Downloaded 1 crate (278.1 KB) in 0.16s
   Compiling proc-macro2 v1.0.89
   Compiling unicode-ident v1.0.13
   Compiling libc v0.2.161
   Compiling cfg-if v1.0.0
   Compiling byteorder v1.5.0
   Compiling getrandom v0.2.15
   Compiling rand_core v0.6.4
   Compiling quote v1.0.37
   Compiling syn v2.0.87
   Compiling zerocopy-derive v0.7.35
   Compiling zerocopy v0.7.35
   Compiling ppv-lite86 v0.2.20
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 3.69s
</code></pre>
<figcaption>Listing 2-2: The output from running <code>cargo build</code> after adding the rand crate as a dependency</figcaption>
</figure>
<p data-x-en="You may see different version numbers (but they will all be compatible with the code, thanks to SemVer!) and different lines (depending on the operating system), and the lines may be in a different order.">您可能会看到不同的版本号（但由于 SemVer，它们都将与代码兼容！）和不同的行（取决于操作系统），并且行的顺序可能不同。</p>
<p data-x-en="When we include an external dependency, Cargo fetches the latest versions of everything that dependency needs from the registry, which is a copy of data from Crates.io. Crates.io is where people in the Rust ecosystem post their open source Rust projects for others to use.">当我们包含一个外部依赖时，Cargo 会从<em>仓库</em>中获取该依赖所需的所有最新版本，<em>仓库</em>是来自<a href="https://crates.io/">Crates.io</a>的数据副本。Crates.io 是 Rust 生态系统中人们发布他们的开源 Rust 项目供他人使用的地方。</p>
<p data-x-en="After updating the registry, Cargo checks the [dependencies] section and downloads any crates listed that aren’t already downloaded. In this case, although we only listed rand as a dependency, Cargo also grabbed other crates that rand depends on to work. After downloading the crates, Rust compiles them and then compiles the project with the dependencies available.">在更新注册表后，Cargo 检查 <code>[dependencies]</code> 部分并下载任何尚未下载的列出的 crates。在这种情况下，虽然我们只将 <code>rand</code> 列为依赖项，Cargo 还获取了 <code>rand</code> 依赖的其他 crates 以正常工作。下载完 crates 后，Rust 会编译它们，然后使用可用的依赖项编译项目。</p>
<p data-x-en="If you immediately run cargo build again without making any changes, you won’t get any output aside from the Finished line. Cargo knows it has already downloaded and compiled the dependencies, and you haven’t changed anything about them in your Cargo.toml file. Cargo also knows that you haven’t changed anything about your code, so it doesn’t recompile that either. With nothing to do, it simply exits.">如果您立即再次运行 <code>cargo build</code> 而不做任何更改，您将不会收到任何输出，除了 <code>Finished</code> 这一行。Cargo 知道它已经下载并编译了依赖项，并且您在 <em>Cargo.toml</em> 文件中没有对它们进行任何更改。Cargo 还知道您没有更改任何代码，因此它也不会重新编译。由于没有需要做的事情，它会直接退出。</p>
<p data-x-en="If you open the src/main.rs file, make a trivial change, and then save it and build again, you’ll only see two lines of output:">如果您打开 <em>src/main.rs</em> 文件，进行一个微小的更改，然后保存并重新构建，您只会看到两行输出：</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
</code></pre>
<p data-x-en="These lines show that Cargo only updates the build with your tiny change to the src/main.rs file. Your dependencies haven’t changed, so Cargo knows it can reuse what it has already downloaded and compiled for those.">这些行显示 Cargo 仅使用您对 <em>src/main.rs</em> 文件的微小更改来更新构建。您的依赖项没有改变，因此 Cargo 知道它可以重用已经下载和编译的内容。</p>
<h4 id="ensuring-reproducible-builds-with-the-cargolock-file"><a class="header" href="#ensuring-reproducible-builds-with-the-cargolock-file">Ensuring Reproducible Builds with the <em>Cargo.lock</em> File</a></h4>
<p data-x-en="Cargo has a mechanism that ensures you can rebuild the same artifact every time you or anyone else builds your code: Cargo will use only the versions of the dependencies you specified until you indicate otherwise. For example, say that next week version 0.8.6 of the rand crate comes out, and that version contains an important bug fix, but it also contains a regression that will break your code. To handle this, Rust creates the Cargo.lock file the first time you run cargo build, so we now have this in the guessing_game directory.">Cargo 有一个机制，确保你或任何人在构建你的代码时都能每次都重建相同的工件：Cargo 将仅使用你指定的依赖版本，直到你另行指示。例如，假设下周发布了 <code>rand</code> crate 的 0.8.6 版本，该版本包含了一个重要的 bug 修复，但也包含了一个会导致你的代码出问题的回归。为了处理这种情况，Rust 在你第一次运行 <code>cargo build</code> 时创建了 <em>Cargo.lock</em> 文件，因此我们现在在 <em>guessing_game</em> 目录中有了这个文件。</p>
<p data-x-en="When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the Cargo.lock file. When you build your project in the future, Cargo will see that the Cargo.lock file exists and will use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at 0.8.5 until you explicitly upgrade, thanks to the Cargo.lock file. Because the Cargo.lock file is important for reproducible builds, it’s often checked into source control with the rest of the code in your project.">当你第一次构建项目时，Cargo 会确定所有符合标准的依赖项版本，然后将它们写入 <em>Cargo.lock</em> 文件。当你将来构建项目时，Cargo 会看到 <em>Cargo.lock</em> 文件存在，并将使用那里指定的版本，而不是再次进行所有确定版本的工作。这让你可以自动拥有可重现的构建。换句话说，你的项目将保持在 0.8.5，直到你显式升级，这要归功于 <em>Cargo.lock</em> 文件。因为 <em>Cargo.lock</em> 文件对于可重现的构建很重要，所以它通常会与项目中的其他代码一起提交到源代码控制中。</p>
<h4 id="updating-a-crate-to-get-a-new-version"><a class="header" href="#updating-a-crate-to-get-a-new-version">Updating a Crate to Get a New Version</a></h4>
<p data-x-en="When you do want to update a crate, Cargo provides the command update, which will ignore the Cargo.lock file and figure out all the latest versions that fit your specifications in Cargo.toml. Cargo will then write those versions to the Cargo.lock file. In this case, Cargo will only look for versions greater than 0.8.5 and less than 0.9.0. If the rand crate has released the two new versions 0.8.6 and 0.9.0, you would see the following if you ran cargo update:">当你<em>确实</em>想要更新一个 crate 时，Cargo 提供了 <code>update</code> 命令，
该命令将忽略 <em>Cargo.lock</em> 文件并找出 <em>Cargo.toml</em> 中符合你指定的所有最新版本。Cargo 然后会将这些
版本写入 <em>Cargo.lock</em> 文件。在这种情况下，Cargo 只会查找
大于 0.8.5 且小于 0.9.0 的版本。如果 <code>rand</code> crate 发布了
两个新版本 0.8.6 和 0.9.0，如果你运行 <code>cargo update</code>，你会看到以下内容：</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p data-x-en="Cargo ignores the 0.9.0 release. At this point, you would also notice a change in your Cargo.lock file noting that the version of the rand crate you are now using is 0.8.6. To use rand version 0.9.0 or any version in the 0.9.x series, you’d have to update the Cargo.toml file to look like this instead:">Cargo 忽略 0.9.0 版本。此时，您还会注意到 <em>Cargo.lock</em> 文件中的变化，指出您现在使用的 <code>rand</code> crate 版本是 0.8.6。要使用 <code>rand</code> 版本 0.9.0 或 0.9.<em>x</em> 系列中的任何版本，您需要更新 <em>Cargo.toml</em> 文件，使其看起来像这样：</p>
<pre><code class="language-toml">[dependencies]
rand = "0.9.0"
</code></pre>
<p data-x-en="The next time you run cargo build, Cargo will update the registry of crates available and reevaluate your rand requirements according to the new version you have specified.">下次您运行<code>cargo build</code>时，Cargo 将更新可用的 crates 注册表，并根据您指定的新版本重新评估您的<code>rand</code>需求。</p>
<p data-x-en="There’s a lot more to say about Cargo and its ecosystem, which we’ll discuss in Chapter 14, but for now, that’s all you need to know. Cargo makes it very easy to reuse libraries, so Rustaceans are able to write smaller projects that are assembled from a number of packages.">关于<a href="https://doc.rust-lang.org/cargo/">Cargo</a><!-- ignore -->和<a href="https://doc.rust-lang.org/cargo/reference/publishing.html">其生态系统</a><!-- ignore -->还有很多要说的，我们将在第14章中讨论，但目前，这些就是你需要知道的全部。Cargo使得重用库变得非常容易，因此Rustaceans能够编写由多个包组装而成的较小项目。</p>
<h3 id="generating-a-random-number"><a class="header" href="#generating-a-random-number">生成随机数</a></h3>
<p data-x-en="Let’s start using rand to generate a number to guess. The next step is to update src/main.rs, as shown in Listing 2-3.">让我们开始使用 <code>rand</code> 来生成一个要猜的数字。下一步是更新 <em>src/main.rs</em>，如列表 2-3 所示。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("The secret number is: {secret_number}");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}</code></pre>
<figcaption>Listing 2-3: Adding code to generate a random number</figcaption>
</figure>
<p data-x-en="First we add the line use rand::Rng;. The Rng trait defines methods that random number generators implement, and this trait must be in scope for us to use those methods. Chapter 10 will cover traits in detail.">首先我们添加一行 <code>use rand::Rng;</code>。这个 <code>Rng</code> 特性定义了随机数生成器实现的方法，而且这个特性必须在作用域内，我们才能使用这些方法。第 10 章将详细讨论特性。</p>
<p data-x-en="Next, we’re adding two lines in the middle. In the first line, we call the rand::thread_rng function that gives us the particular random number generator we’re going to use: one that is local to the current thread of execution and is seeded by the operating system. Then we call the gen_range method on the random number generator. This method is defined by the Rng trait that we brought into scope with the use rand::Rng; statement. The gen_range method takes a range expression as an argument and generates a random number in the range. The kind of range expression we’re using here takes the form start..=end and is inclusive on the lower and upper bounds, so we need to specify 1..=100 to request a number between 1 and 100.">接下来，我们在中间添加两行。在第一行中，我们调用<code>rand::thread_rng</code>函数，该函数为我们提供将要使用的特定随机数生成器：一个当前执行线程本地的，并由操作系统播种的生成器。然后我们在随机数生成器上调用<code>gen_range</code>方法。此方法由我们通过<code>use rand::Rng;</code>语句引入作用域的<code>Rng</code>特征定义。<code>gen_range</code>方法接受一个范围表达式作为参数，并生成该范围内的一个随机数。我们在这里使用的范围表达式的形式为<code>start..=end</code>，并且在下限和上限上都是包含的，因此我们需要指定<code>1..=100</code>以请求1到100之间的数字。</p>
<section class="note" aria-role="note">
<p data-x-en="Note: You won’t just know which traits to use and which methods and functions to call from a crate, so each crate has documentation with instructions for using it. Another neat feature of Cargo is that running the cargo doc --open command will build documentation provided by all your dependencies locally and open it in your browser. If you’re interested in other functionality in the rand crate, for example, run cargo doc --open and click rand in the sidebar on the left.">注意：您不会仅仅知道要使用哪个特质以及从哪个 crate 调用哪些方法和函数，因此每个 crate 都有包含使用说明的文档。Cargo 的另一个便捷功能是，运行 <code>cargo doc --open</code> 命令将构建所有依赖项提供的文档，并在您的浏览器中打开。例如，如果您对 <code>rand</code> crate 的其他功能感兴趣，可以运行 <code>cargo doc --open</code> 并在左侧边栏中点击 <code>rand</code>。</p>
</section>
<p data-x-en="The second new line prints the secret number. This is useful while we’re developing the program to be able to test it, but we’ll delete it from the final version. It’s not much of a game if the program prints the answer as soon as it starts!">第二行新代码打印出秘密数字。这在我们开发程序时很有用，可以测试它，但在最终版本中我们会删除这一行。如果程序一启动就打印出答案，那游戏就没什么意思了！</p>
<p data-x-en="Try running the program a few times:">尝试运行程序几次：</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p data-x-en="You should get different random numbers, and they should all be numbers between 1 and 100. Great job!">你应该得到不同的随机数，它们都应该是1到100之间的数字。干得好！</p>
<h2 id="comparing-the-guess-to-the-secret-number"><a class="header" href="#comparing-the-guess-to-the-secret-number">将猜测与秘密数字进行比较</a></h2>
<p data-x-en="Now that we have user input and a random number, we can compare them. That step is shown in Listing 2-4. Note that this code won’t compile just yet, as we will explain.">现在我们有了用户输入和一个随机数，可以将它们进行比较。这一步骤在清单 2-4 中展示。请注意，这段代码还不能编译，我们将对此进行解释。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span>
    println!("You guessed: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
}</code></pre>
<figcaption>Listing 2-4: Handling the possible return values of comparing two numbers</figcaption>
</figure>
<p data-x-en="First we add another use statement, bringing a type called std::cmp::Ordering into scope from the standard library. The Ordering type is another enum and has the variants Less, Greater, and Equal. These are the three outcomes that are possible when you compare two values.">首先我们添加另一个<code>use</code>语句，从标准库中引入一个名为<code>std::cmp::Ordering</code>的类型。<code>Ordering</code>类型是另一个枚举，具有<code>Less</code>、<code>Greater</code>和<code>Equal</code>变体。这些是在比较两个值时可能产生的三种结果。</p>
<p data-x-en="Then we add five new lines at the bottom that use the Ordering type. The cmp method compares two values and can be called on anything that can be compared. It takes a reference to whatever you want to compare with: here it’s comparing guess to secret_number. Then it returns a variant of the Ordering enum we brought into scope with the use statement. We use a match expression to decide what to do next based on which variant of Ordering was returned from the call to cmp with the values in guess and secret_number.">然后我们在底部添加五行新代码，使用 <code>Ordering</code> 类型。<code>cmp</code> 方法可以比较两个值，可以对任何可以比较的事物调用。它接受一个你想要比较的对象的引用：在这里，它比较 <code>guess</code> 和 <code>secret_number</code>。然后，它返回一个我们在 <code>use</code> 语句中引入的 <code>Ordering</code> 枚举的变体。我们使用一个 <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> 表达式来根据从 <code>cmp</code> 调用返回的 <code>Ordering</code> 变体决定接下来要做什么，这里的值是 <code>guess</code> 和 <code>secret_number</code>。</p>
<p data-x-en="A match expression is made up of arms. An arm consists of a pattern to match against, and the code that should be run if the value given to match fits that arm’s pattern. Rust takes the value given to match and looks through each arm’s pattern in turn. Patterns and the match construct are powerful Rust features: they let you express a variety of situations your code might encounter and they make sure you handle them all. These features will be covered in detail in Chapter 6 and Chapter 19, respectively.">一个 <code>match</code> 表达式由 <em>臂</em> 组成。一个臂包含一个 <em>模式</em> 用于匹配，以及如果给定给 <code>match</code> 的值符合该臂的模式时应运行的代码。Rust 会取 <code>match</code> 给定的值，并依次检查每个臂的模式。模式和 <code>match</code> 构造是强大的 Rust 特性：它们让你能够表达代码可能遇到的各种情况，并确保你处理了所有这些情况。这些特性将分别在第 6 章和第 19 章中详细讨论。</p>
<p data-x-en="Let’s walk through an example with the match expression we use here. Say that the user has guessed 50 and the randomly generated secret number this time is 38.">让我们通过一个使用这里的 <code>match</code> 表达式的例子来说明。假设用户猜的是 50，而这次随机生成的秘密数字是 38。</p>
<p data-x-en="When the code compares 50 to 38, the cmp method will return Ordering::Greater because 50 is greater than 38. The match expression gets the Ordering::Greater value and starts checking each arm’s pattern. It looks at the first arm’s pattern, Ordering::Less, and sees that the value Ordering::Greater does not match Ordering::Less, so it ignores the code in that arm and moves to the next arm. The next arm’s pattern is Ordering::Greater, which does match Ordering::Greater! The associated code in that arm will execute and print Too big! to the screen. The match expression ends after the first successful match, so it won’t look at the last arm in this scenario.">当代码比较 50 和 38 时，<code>cmp</code> 方法将返回 <code>Ordering::Greater</code>，因为 50 大于 38。<code>match</code> 表达式获取 <code>Ordering::Greater</code> 值并开始检查每个分支的模式。它查看第一个分支的模式 <code>Ordering::Less</code>，并发现值 <code>Ordering::Greater</code> 不匹配 <code>Ordering::Less</code>，因此它忽略该分支中的代码并移动到下一个分支。下一个分支的模式是 <code>Ordering::Greater</code>，这 <em>确实</em> 匹配 <code>Ordering::Greater</code>！该分支中的关联代码将执行，并在屏幕上打印 <code>Too big!</code>。<code>match</code> 表达式在第一次成功匹配后结束，因此在这种情况下它不会查看最后一个分支。</p>
<p data-x-en="However, the code in Listing 2-4 won’t compile yet. Let’s try it:">然而，清单 2-4 中的代码还不能编译。让我们试一试：</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
   --&gt; src/main.rs:22:21
    |
22  |     match guess.cmp(&amp;secret_number) {
    |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
    |                 |
    |                 arguments to this method are incorrect
    |
    = note: expected reference `&amp;String`
               found reference `&amp;{integer}`
note: method defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/core/src/cmp.rs:838:8
    |
838 |     fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
    |        ^^^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
</code></pre>
<p data-x-en="The core of the error states that there are mismatched types. Rust has a strong, static type system. However, it also has type inference. When we wrote let mut guess = String::new(), Rust was able to infer that guess should be a String and didn’t make us write the type. The secret_number, on the other hand, is a number type. A few of Rust’s number types can have a value between 1 and 100: i32, a 32-bit number; u32, an unsigned 32-bit number; i64, a 64-bit number; as well as others. Unless otherwise specified, Rust defaults to an i32, which is the type of secret_number unless you add type information elsewhere that would cause Rust to infer a different numerical type. The reason for the error is that Rust cannot compare a string and a number type.">错误的核心在于存在 <em>类型不匹配</em>。Rust 拥有强大的静态类型系统。然而，它也支持类型推断。当我们编写 <code>let mut guess = String::new()</code> 时，Rust 能够推断出 <code>guess</code> 应该是一个 <code>String</code>，因此不需要我们写出类型。而 <code>secret_number</code> 则是一个数字类型。Rust 的几种数字类型可以有 1 到 100 之间的值：<code>i32</code>，一个 32 位数字；<code>u32</code>，一个无符号 32 位数字；<code>i64</code>，一个 64 位数字；以及其他类型。除非另有指定，Rust 默认使用 <code>i32</code>，这是 <code>secret_number</code> 的类型，除非你在其他地方添加了类型信息，导致 Rust 推断出不同的数字类型。错误的原因是 Rust 无法比较字符串和数字类型。</p>
<p data-x-en="Ultimately, we want to convert the String the program reads as input into a number type so we can compare it numerically to the secret number. We do so by adding this line to the main function body:">最终，我们希望将程序读取的 <code>String</code> 转换为数字类型，以便我们可以将其与秘密数字进行数值比较。我们通过在 <code>main</code> 函数体中添加以下行来实现这一点：</p>
<p data-x-en="Filename: src/main.rs"><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span>    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
<span class="boring">}</span></code></pre>
<p data-x-en="The line is:">行是：</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect("Please type a number!");</code></pre>
<p data-x-en="We create a variable named guess. But wait, doesn’t the program already have a variable named guess? It does, but helpfully Rust allows us to shadow the previous value of guess with a new one. Shadowing lets us reuse the guess variable name rather than forcing us to create two unique variables, such as guess_str and guess, for example. We’ll cover this in more detail in Chapter 3, but for now, know that this feature is often used when you want to convert a value from one type to another type.">我们创建一个名为 <code>guess</code> 的变量。但是等等，程序不是已经有一个名为 <code>guess</code> 的变量了吗？确实有，但 Rust 帮助性地允许我们用新值覆盖 <code>guess</code> 的先前值。这种 <em>遮蔽</em> 让我们可以重用 <code>guess</code> 变量名，而不是强制我们创建两个独特的变量，例如 <code>guess_str</code> 和 <code>guess</code>。我们将在 <a href="ch03-01-variables-and-mutability.html#shadowing">第 3 章</a><!-- ignore --> 中更详细地讨论这一点，但目前，要知道此功能通常在您希望将一个类型的值转换为另一个类型的值时使用。</p>
<p data-x-en="We bind this new variable to the expression guess.trim().parse(). The guess in the expression refers to the original guess variable that contained the input as a string. The trim method on a String instance will eliminate any whitespace at the beginning and end, which we must do to be able to compare the string to the u32, which can only contain numerical data. The user must press enter to satisfy read_line and input their guess, which adds a newline character to the string. For example, if the user types 5 and presses enter, guess looks like this: 5\n. The \n represents “newline.” (On Windows, pressing enter results in a carriage return and a newline, \r\n.) The trim method eliminates \n or \r\n, resulting in just 5.">我们将这个新变量绑定到表达式 <code>guess.trim().parse()</code>。表达式中的 <code>guess</code>
指的是包含输入字符串的原始 <code>guess</code> 变量。在 <code>String</code> 实例上调用的 <code>trim</code> 方法将删除开头和结尾的任何空白，我们必须这样做才能将字符串与只能包含数字数据的 <code>u32</code> 进行比较。用户必须按 <kbd>enter</kbd> 以满足 <code>read_line</code> 并输入他们的猜测，这会在字符串中添加一个换行符。例如，如果用户输入 <kbd>5</kbd> 并按 <kbd>enter</kbd>，<code>guess</code> 看起来像这样： <code>5\n</code>。<code>\n</code> 表示“换行”。（在 Windows 上，按 <kbd>enter</kbd> 会产生回车和换行，<code>\r\n</code>。）<code>trim</code> 方法会删除 <code>\n</code> 或 <code>\r\n</code>，结果只剩下 <code>5</code>。</p>
<p data-x-en="The parse method on strings converts a string to another type. Here, we use it to convert from a string to a number. We need to tell Rust the exact number type we want by using let guess: u32. The colon (:) after guess tells Rust we’ll annotate the variable’s type. Rust has a few built-in number types; the u32 seen here is an unsigned, 32-bit integer. It’s a good default choice for a small positive number. You’ll learn about other number types in Chapter 3."><a href="../std/primitive.str.html#method.parse"><code>parse</code> 方法在字符串上</a><!-- ignore --> 将字符串转换为另一种类型。在这里，我们使用它将字符串转换为数字。我们需要通过使用 <code>let guess: u32</code> 告诉 Rust 我们想要的确切数字类型。在 <code>guess</code> 后面的冒号 (<code>:</code>) 告诉 Rust 我们将注解变量的类型。Rust 有一些内置的数字类型；这里看到的 <code>u32</code> 是一个无符号的 32 位整数。对于一个小的正数，它是一个很好的默认选择。您将在 <a href="ch03-02-data-types.html#integer-types">第 3 章</a><!-- ignore --> 中了解其他数字类型。</p>
<p data-x-en="Additionally, the u32 annotation in this example program and the comparison with secret_number means Rust will infer that secret_number should be a u32 as well. So now the comparison will be between two values of the same type!">此外，此示例程序中的 <code>u32</code> 注解和与 <code>secret_number</code> 的比较意味着 Rust 将推断 <code>secret_number</code> 也应该是 <code>u32</code>。因此，现在比较将在两个相同类型的值之间进行！</p>
<p data-x-en="The parse method will only work on characters that can logically be converted into numbers and so can easily cause errors. If, for example, the string contained A👍%, there would be no way to convert that to a number. Because it might fail, the parse method returns a Result type, much as the read_line method does (discussed earlier in “Handling Potential Failure with Result”). We’ll treat this Result the same way by using the expect method again. If parse returns an Err Result variant because it couldn’t create a number from the string, the expect call will crash the game and print the message we give it. If parse can successfully convert the string to a number, it will return the Ok variant of Result, and expect will return the number that we want from the Ok value.">The <code>parse</code> 方法只能用于可以逻辑上转换为数字的字符，因此很容易导致错误。例如，如果字符串包含 <code>A👍%</code>，则无法将其转换为数字。因为可能会失败，所以 <code>parse</code> 方法返回一个 <code>Result</code> 类型，就像 <code>read_line</code> 方法一样（在 <a href="#handling-potential-failure-with-result">“使用 <code>Result</code> 处理潜在失败”</a><!-- ignore--> 中讨论过）。我们将以相同的方式使用 <code>expect</code> 方法处理这个 <code>Result</code>。如果 <code>parse</code> 由于无法从字符串创建数字而返回 <code>Err</code> <code>Result</code> 变体，<code>expect</code> 调用将使游戏崩溃并打印我们提供的消息。如果 <code>parse</code> 可以成功将字符串转换为数字，它将返回 <code>Result</code> 的 <code>Ok</code> 变体，<code>expect</code> 将从 <code>Ok</code> 值中返回我们想要的数字。</p>
<p data-x-en="Let’s run the program now:">现在让我们运行这个程序:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
touch src/main.rs
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p data-x-en="Nice! Even though spaces were added before the guess, the program still figured out that the user guessed 76. Run the program a few times to verify the different behavior with different kinds of input: guess the number correctly, guess a number that is too high, and guess a number that is too low.">不错！即使在猜测前添加了空格，程序仍然判断出用户猜测的是76。运行程序几次以验证不同输入下的不同行为：正确猜测数字、猜测的数字过高和猜测的数字过低。</p>
<p data-x-en="We have most of the game working now, but the user can make only one guess. Let’s change that by adding a loop!">我们现在游戏的大部分功能已经实现了，但用户只能猜一次。<br>让我们通过添加一个循环来改变这一点！</p>
<h2 id="allowing-multiple-guesses-with-looping"><a class="header" href="#allowing-multiple-guesses-with-looping">允许多次猜测的循环</a></h2>
<p data-x-en="The loop keyword creates an infinite loop. We’ll add a loop to give users more chances at guessing the number:"><code>loop</code> 关键字创建一个无限循环。我们将添加一个循环，以给用户更多猜测数字的机会：</p>
<p data-x-en="Filename: src/main.rs"><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --snip--

    println!("The secret number is: {secret_number}");

    loop {
        println!("Please input your guess.");

        // --snip--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; println!("You win!"),
        }
    }
}</code></pre>
<p data-x-en="As you can see, we’ve moved everything from the guess input prompt onward into a loop. Be sure to indent the lines inside the loop another four spaces each and run the program again. The program will now ask for another guess forever, which actually introduces a new problem. It doesn’t seem like the user can quit!">正如您所见，我们已将从猜测输入提示开始的所有内容移到了一个循环中。确保将循环内的每一行再向右缩进四个空格，并再次运行程序。现在程序将永远要求用户再次猜测，这实际上引入了一个新问题。看起来用户无法退出！</p>
<p data-x-en="The user could always interrupt the program by using the keyboard shortcut ctrl-c. But there’s another way to escape this insatiable monster, as mentioned in the parse discussion in “Comparing the Guess to the Secret Number”: if the user enters a non-number answer, the program will crash. We can take advantage of that to allow the user to quit, as shown here:">用户可以随时通过使用键盘快捷键<kbd>ctrl</kbd>-<kbd>c</kbd>来中断程序。但还有另一种方法可以逃离这个贪得无厌的怪物，正如在<a href="#comparing-the-guess-to-the-secret-number">“将猜测与秘密数字进行比较”</a><!-- ignore -->中提到的<code>parse</code>讨论：如果用户输入非数字答案，程序将崩溃。我们可以利用这一点允许用户退出，如下所示：</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
touch src/main.rs
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p data-x-en="Typing quit will quit the game, but as you’ll notice, so will entering any other non-number input. This is suboptimal, to say the least; we want the game to also stop when the correct number is guessed.">输入 <code>quit</code> 会退出游戏，但你也会注意到，输入任何其他非数字也会退出游戏。这至少可以说是次优的；我们希望在猜到正确数字时游戏也能停止。</p>
<h3 id="quitting-after-a-correct-guess"><a class="header" href="#quitting-after-a-correct-guess">正确猜测后退出</a></h3>
<p data-x-en="Let’s program the game to quit when the user wins by adding a break statement:">让我们通过添加一个<code>break</code>语句来编程，使用户获胜时游戏退出：</p>
<p data-x-en="Filename: src/main.rs"><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span>        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}</code></pre>
<p data-x-en="Adding the break line after You win! makes the program exit the loop when the user guesses the secret number correctly. Exiting the loop also means exiting the program, because the loop is the last part of main.">在 <code>You win!</code> 之后添加 <code>break</code> 行会使程序在用户正确猜中秘密数字时退出循环。退出循环也意味着退出程序，因为循环是 <code>main</code> 的最后一部分。</p>
<h3 id="handling-invalid-input"><a class="header" href="#handling-invalid-input">处理无效输入</a></h3>
<p data-x-en="To further refine the game’s behavior, rather than crashing the program when the user inputs a non-number, let’s make the game ignore a non-number so the user can continue guessing. We can do that by altering the line where guess is converted from a String to a u32, as shown in Listing 2-5.">为了进一步完善游戏的行为，而不是在用户输入非数字时使程序崩溃，让我们让游戏忽略非数字，这样用户可以继续猜。我们可以通过修改将 <code>guess</code> 从 <code>String</code> 转换为 <code>u32</code> 的那一行来实现，如清单 2-5 所示。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {guess}");

        // --snip--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 2-5: Ignoring a non-number guess and asking for another guess instead of crashing the program</figcaption>
</figure>
<p data-x-en="We switch from an expect call to a match expression to move from crashing on an error to handling the error. Remember that parse returns a Result type and Result is an enum that has the variants Ok and Err. We’re using a match expression here, as we did with the Ordering result of the cmp method.">我们将从一个 <code>expect</code> 调用切换到一个 <code>match</code> 表达式，以从在错误时崩溃转变为处理错误。请记住，<code>parse</code> 返回一个 <code>Result</code> 类型，而 <code>Result</code> 是一个具有 <code>Ok</code> 和 <code>Err</code> 变体的枚举。我们在这里使用了一个 <code>match</code> 表达式，就像我们在 <code>cmp</code> 方法的 <code>Ordering</code> 结果中所做的那样。</p>
<p data-x-en="If parse is able to successfully turn the string into a number, it will return an Ok value that contains the resultant number. That Ok value will match the first arm’s pattern, and the match expression will just return the num value that parse produced and put inside the Ok value. That number will end up right where we want it in the new guess variable we’re creating.">如果 <code>parse</code> 能够成功地将字符串转换为数字，它将返回一个包含结果数字的 <code>Ok</code> 值。该 <code>Ok</code> 值将匹配第一个分支的模式，<code>match</code> 表达式将直接返回 <code>parse</code> 生成并放入 <code>Ok</code> 值中的 <code>num</code> 值。该数字最终会出现在我们正在创建的新 <code>guess</code> 变量中。</p>
<p data-x-en="If parse is not able to turn the string into a number, it will return an Err value that contains more information about the error. The Err value does not match the Ok(num) pattern in the first match arm, but it does match the Err(_) pattern in the second arm. The underscore, _, is a catchall value; in this example, we’re saying we want to match all Err values, no matter what information they have inside them. So the program will execute the second arm’s code, continue, which tells the program to go to the next iteration of the loop and ask for another guess. So, effectively, the program ignores all errors that parse might encounter!">如果 <code>parse</code> <em>无法</em> 将字符串转换为数字，它将返回一个包含更多错误信息的 <code>Err</code> 值。 <code>Err</code> 值不匹配第一个 <code>match</code> 分支中的 <code>Ok(num)</code> 模式，但确实匹配第二个分支中的 <code>Err(_)</code> 模式。下划线 <code>_</code> 是一个通配值；在这个例子中，我们表示我们想要匹配所有 <code>Err</code> 值，无论它们内部包含什么信息。因此，程序将执行第二个分支的代码 <code>continue</code>，这告诉程序进入 <code>loop</code> 的下一次迭代并请求另一个猜测。因此，程序实际上忽略了 <code>parse</code> 可能遇到的所有错误！</p>
<p data-x-en="Now everything in the program should work as expected. Let’s try it:">现在程序中的所有内容都应该按预期工作。让我们尝试一下：</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p data-x-en="Awesome! With one tiny final tweak, we will finish the guessing game. Recall that the program is still printing the secret number. That worked well for testing, but it ruins the game. Let’s delete the println! that outputs the secret number. Listing 2-6 shows the final code.">太棒了！通过最后一个小改动，我们将完成猜数字游戏。回想一下，程序仍然在打印秘密数字。这在测试时很好用，但会破坏游戏。让我们删除输出秘密数字的<code>println!</code>。清单2-6显示了最终的代码。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {guess}");

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}</code></pre>
<figcaption>Listing 2-6: Complete guessing game code</figcaption>
</figure>
<p data-x-en="At this point, you’ve successfully built the guessing game. Congratulations!">到目前为止，您已经成功构建了猜数字游戏。恭喜！</p>
<h2 id="summary"><a class="header" href="#summary">摘要</a></h2>
<p data-x-en="This project was a hands-on way to introduce you to many new Rust concepts: let, match, functions, the use of external crates, and more. In the next few chapters, you’ll learn about these concepts in more detail. Chapter 3 covers concepts that most programming languages have, such as variables, data types, and functions, and shows how to use them in Rust. Chapter 4 explores ownership, a feature that makes Rust different from other languages. Chapter 5 discusses structs and method syntax, and Chapter 6 explains how enums work.">这个项目是一个实践性的方式，向你介绍了许多新的Rust概念：<code>let</code>，<code>match</code>，函数，外部crate的使用等。在接下来的几章中，你将更详细地学习这些概念。第3章涵盖了大多数编程语言都有的概念，如变量、数据类型和函数，并展示了如何在Rust中使用它们。第4章探讨了所有权，这是使Rust与其他语言不同的特性。第5章讨论了结构体和方法语法，第6章解释了枚举的工作原理。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch01-03-hello-cargo.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch01-03-hello-cargo.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-00-common-programming-concepts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    

</body></html>