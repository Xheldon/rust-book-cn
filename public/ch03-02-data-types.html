<!DOCTYPE html><html lang="zh-CN" class="light sidebar-visible" dir="ltr"><head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>数据类型 - 《Rust 编程语言》</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    <meta name="title" content="Rust 中文"><meta property="og:title" content="Rust 中文"><meta name="description" content="Rust 中文文档"><meta property="og:description" content="Rust 中文文档"><meta name="url" content="https://rust.xheldon.com"><meta property="og:url" content="https://rust.xheldon.com"><script src="https://www.googletagmanager.com/gtag/js?id=G-V7NE1X37EX"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-V7NE1X37EX')</script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486286026923411"></script><style>/* hover 显示原文 */
p[data-x-en],
li[data-x-en] {
  position: relative;
}
p[data-x-en]:hover::after,
li[data-x-en]:hover::after {
  visibility: visible;
  opacity: 1;
}
p[data-x-en]::after,
li[data-x-en]::after {
  content: attr(data-x-en);
  display: block;
  font-size: 12px;
  transition: all 0.2s 0.3s;
  visibility: hidden;
  opacity: 0;
  background: var(--searchbar-bg);
  z-index: 99;
  border-radius: 4px;
  padding: 5px 10px;
  position: absolute;
  top: 100%;
  left: 0;
}
/* 译者注释内容 */
div[type='comment'] {
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  background: #eee;
}
div[type='comment']::before {
  content: '译者注: ';
  font-weight: 900;
}
header a.logo {
  position: relative;
}
header a.logo::after {
  content: '中文';
  position: absolute;
  left: calc(100% + 5px);
  font-size: 12px;
  width: 50px;
  top: -5px;
}
#banner-info {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  font-size: 12px;
  padding: 0;
  z-index: 999;
}
#add-info {
  font-size: 14px;
}
blockquote {
  border-left: 5px solid #ccc;
  padding-left: 10px;
  margin-left: 0;
}
.content {
  overflow-y: unset !important;
}
</style></head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky"><div id="banner-info">本文档为 AI + 人工翻译，hover 可以显示原文。当前页翻译有问题？<a style="cursor: pointer;" href="https://github.com/Xheldon/rust-book-cn/blob/main/dict/ch03-02-data-types.json" target="_blank">我来翻译！</a></div>
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    <a href="https://github.com/Xheldon/rust-book-cn" target="_blank"><i class="fa fa-language"></i></a><a href="https://www.xheldon.com" target="_blank"><i class="fa fa-id-card"></i></a></div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="data-types"><a class="header" href="#data-types">数据类型</a></h2>
<p data-x-en="Every value in Rust is of a certain data type, which tells Rust what kind of data is being specified so it knows how to work with that data. We’ll look at two data type subsets: scalar and compound.">Rust 中的每个值都有一个特定的<em>数据类型</em>，这告诉 Rust 正在指定什么样的数据，以便它知道如何处理这些数据。我们将研究两种数据类型子集：标量和复合。</p>
<p data-x-en="Keep in mind that Rust is a statically typed language, which means that it must know the types of all variables at compile time. The compiler can usually infer what type we want to use based on the value and how we use it. In cases when many types are possible, such as when we converted a String to a numeric type using parse in the “Comparing the Guess to the Secret Number” section in Chapter 2, we must add a type annotation, like this:">请记住，Rust 是一种 <em>静态类型</em> 语言，这意味着它必须在编译时知道所有变量的类型。编译器通常可以根据值及其使用方式推断我们想要使用的类型。在可能有多种类型的情况下，例如在第 2 章的 <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“将猜测与秘密数字进行比较”</a><!-- ignore --> 部分中，我们将 <code>String</code> 转换为数字类型时使用了 <code>parse</code>，我们必须添加类型注解，如下所示：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = "42".parse().expect("Not a number!");
<span class="boring">}</span></code></pre></pre>
<p data-x-en="If we don’t add the : u32 type annotation shown in the preceding code, Rust will display the following error, which means the compiler needs more information from us to know which type we want to use:">如果我们不添加前面代码中显示的<code>: u32</code>类型注解，Rust 将显示以下错误，这意味着编译器需要我们提供更多信息以确定我们想要使用哪种类型：</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = "42".parse().expect("Not a number!");
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin "no_type_annotations") due to 1 previous error
</code></pre>
<p data-x-en="You’ll see different type annotations for other data types.">您将看到其他数据类型的不同类型注解。</p>
<h3 id="scalar-types"><a class="header" href="#scalar-types">标量类型</a></h3>
<p data-x-en="A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Let’s jump into how they work in Rust.">一个 <em>标量</em> 类型表示一个单一的值。Rust 有四种主要的标量类型：整数、浮点数、布尔值和字符。你可能从其他编程语言中认识这些类型。让我们来看看它们在 Rust 中是如何工作的。</p>
<h4 id="integer-types"><a class="header" href="#integer-types">整数类型</a></h4>
<p data-x-en="An integer is a number without a fractional component. We used one integer type in Chapter 2, the u32 type. This type declaration indicates that the value it’s associated with should be an unsigned integer (signed integer types start with i instead of u) that takes up 32 bits of space. Table 3-1 shows the built-in integer types in Rust. We can use any of these variants to declare the type of an integer value.">一个<em>整数</em>是没有小数部分的数字。我们在第2章中使用了一种整数类型，即<code>u32</code>类型。这种类型声明表示其关联的值应该是一个无符号整数（有符号整数类型以<code>i</code>而不是<code>u</code>开头），占用32位空间。表3-1显示了Rust中的内置整数类型。我们可以使用这些变体中的任何一种来声明整数值的类型。</p>
<p data-x-en="Table 3-1: Integer Types in Rust"><span class="caption">表 3-1：Rust 中的整数类型</span></p>
<div class="table-wrapper"><table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p data-x-en="Each variant can be either signed or unsigned and has an explicit size. Signed and unsigned refer to whether it’s possible for the number to be negative—in other words, whether the number needs to have a sign with it (signed) or whether it will only ever be positive and can therefore be represented without a sign (unsigned). It’s like writing numbers on paper: when the sign matters, a number is shown with a plus sign or a minus sign; however, when it’s safe to assume the number is positive, it’s shown with no sign. Signed numbers are stored using two’s complement representation.">每个变体可以是带符号的或不带符号的，并且具有明确的大小。
<em>带符号的</em>和<em>不带符号的</em>指的是数字是否可以为
负数——换句话说，数字是否需要带有符号（带符号的）或者它将始终为正数，因此可以
不带符号表示（不带符号的）。这就像在纸上写数字：当符号重要时，数字会显示带有加号或减号；然而，
当可以假设数字为正数时，它会显示没有符号。
带符号的数字使用<a href="https://en.wikipedia.org/wiki/Two%27s_complement">二进制补码</a><!-- ignore
-->表示。</p>
<p data-x-en="Each signed variant can store numbers from −(2n − 1) to 2n − 1 − 1 inclusive, where n is the number of bits that variant uses. So an i8 can store numbers from −(27) to 27 − 1, which equals −128 to 127. Unsigned variants can store numbers from 0 to 2n − 1, so a u8 can store numbers from 0 to 28 − 1, which equals 0 to 255.">每个有符号变体可以存储从 −(2<sup>n − 1</sup>) 到 2<sup>n − 1</sup> − 1（包括）的数字，其中 <em>n</em> 是该变体使用的位数。所以 <code>i8</code> 可以存储从 −(2<sup>7</sup>) 到 2<sup>7</sup> − 1 的数字，即 −128 到 127。无符号变体可以存储从 0 到 2<sup>n</sup> − 1 的数字，因此 <code>u8</code> 可以存储从 0 到 2<sup>8</sup> − 1 的数字，即 0 到 255。</p>
<p data-x-en="Additionally, the isize and usize types depend on the architecture of the computer your program is running on, which is denoted in the table as “arch”: 64 bits if you’re on a 64-bit architecture and 32 bits if you’re on a 32-bit architecture.">此外，<code>isize</code> 和 <code>usize</code> 类型取决于你的程序运行的计算机的架构，表中表示为“arch”：
如果你在 64 位架构上，则为 64 位；如果你在 32 位架构上，则为 32 位。</p>
<p data-x-en="You can write integer literals in any of the forms shown in Table 3-2. Note that number literals that can be multiple numeric types allow a type suffix, such as 57u8, to designate the type. Number literals can also use _ as a visual separator to make the number easier to read, such as 1_000, which will have the same value as if you had specified 1000.">您可以使用表 3-2 中显示的任何形式编写整数字面量。请注意，可以是多种数字类型的数字字面量允许使用类型后缀，例如 <code>57u8</code>，来指定类型。数字字面量还可以使用 <code>_</code> 作为视觉分隔符，使数字更易于阅读，例如 <code>1_000</code>，其值与您指定 <code>1000</code> 时相同。</p>
<p data-x-en="Table 3-2: Integer Literals in Rust"><span class="caption">表 3-2：Rust 中的整数字面量</span></p>
<div class="table-wrapper"><table><thead><tr><th>Number literals</th><th>Example</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>98_222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binary</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (<code>u8</code> only)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p data-x-en="So how do you know which type of integer to use? If you’re unsure, Rust’s defaults are generally good places to start: integer types default to i32. The primary situation in which you’d use isize or usize is when indexing some sort of collection.">那么你如何知道使用哪种类型的整数呢？如果你不确定，Rust 的默认值通常是很好的起点：整数类型默认为 <code>i32</code>。使用 <code>isize</code> 或 <code>usize</code> 的主要情况是在对某种集合进行索引时。</p>
<section class="note" aria-role="note">
<h5 id="integer-overflow"><a class="header" href="#integer-overflow">Integer Overflow</a></h5>
<p data-x-en="Let’s say you have a variable of type u8 that can hold values between 0 and 255. If you try to change the variable to a value outside that range, such as 256, integer overflow will occur, which can result in one of two behaviors. When you’re compiling in debug mode, Rust includes checks for integer overflow that cause your program to panic at runtime if this behavior occurs. Rust uses the term panicking when a program exits with an error; we’ll discuss panics in more depth in the “Unrecoverable Errors with panic!” section in Chapter 9.">假设你有一个类型为<code>u8</code>的变量，它可以存储0到255之间的值。如果你尝试将变量更改为该范围之外的值，例如256，将会发生<em>整数溢出</em>，这可能导致两种行为之一。当你在调试模式下编译时，Rust 会包含整数溢出检查，如果发生这种行为，这些检查会导致你的程序在运行时<em>崩溃</em>。Rust 在程序以错误退出时使用<em>崩溃</em>一词；我们将在第9章的<a href="ch09-01-unrecoverable-errors-with-panic.html">“不可恢复的错误与<code>panic!</code>”</a><!-- ignore -->部分中更深入地讨论崩溃。</p>
<p data-x-en="When you’re compiling in release mode with the --release flag, Rust does not include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs two’s complement wrapping. In short, values greater than the maximum value the type can hold “wrap around” to the minimum of the values the type can hold. In the case of a u8, the value 256 becomes 0, the value 257 becomes 1, and so on. The program won’t panic, but the variable will have a value that probably isn’t what you were expecting it to have. Relying on integer overflow’s wrapping behavior is considered an error.">当你使用 <code>--release</code> 标志在发布模式下编译时，Rust <em>不会</em> 包含导致 panic 的整数溢出检查。相反，如果发生溢出，Rust 会执行 <em>二进制补码环绕</em>。简而言之，大于类型可容纳的最大值的值会“环绕”到类型可容纳的最小值。对于 <code>u8</code> 类型，值 256 会变为 0，值 257 会变为 1，依此类推。程序不会 panic，但变量将具有一个可能不是你期望的值。依赖整数溢出的环绕行为被视为错误。</p>
<p data-x-en="To explicitly handle the possibility of overflow, you can use these families of methods provided by the standard library for primitive numeric types:">为了显式处理溢出的可能性，您可以使用标准库为原始数值类型提供的这些方法族：</p>
<ul>
<li data-x-en="Wrap in all modes with the wrapping_* methods, such as wrapping_add.">在所有模式下使用 <code>wrapping_*</code> 方法进行包装，例如 <code>wrapping_add</code>。</li>
<li data-x-en="Return the None value if there is overflow with the checked_* methods.">如果使用 <code>checked_*</code> 方法时发生溢出，则返回 <code>None</code> 值。</li>
<li data-x-en="Return the value and a Boolean indicating whether there was overflow with the overflowing_* methods.">返回值和一个布尔值，指示是否发生了溢出，使用 <code>overflowing_*</code> 方法。</li>
<li data-x-en="Saturate at the value’s minimum or maximum values with the saturating_* methods.">使用 <code>saturating_*</code> 方法在值的最小值或最大值处饱和。</li>
</ul>
</section>
<h4 id="floating-point-types"><a class="header" href="#floating-point-types">浮点类型</a></h4>
<p data-x-en="Rust also has two primitive types for floating-point numbers, which are numbers with decimal points. Rust’s floating-point types are f32 and f64, which are 32 bits and 64 bits in size, respectively. The default type is f64 because on modern CPUs, it’s roughly the same speed as f32 but is capable of more precision. All floating-point types are signed.">Rust 也有两种用于<em>浮点数</em>的原始类型，即带有小数点的数字。Rust 的浮点类型是 <code>f32</code> 和 <code>f64</code>，它们的大小分别为 32 位和 64 位。默认类型是 <code>f64</code>，因为在现代 CPU 上，它的速度与 <code>f32</code> 大致相同，但能够提供更高的精度。所有浮点类型都是有符号的。</p>
<p data-x-en="Here’s an example that shows floating-point numbers in action:">这里有一个示例，展示了浮点数的实际应用：</p>
<p data-x-en="Filename: src/main.rs"><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre></pre>
<p data-x-en="Floating-point numbers are represented according to the IEEE-754 standard.">浮点数根据 IEEE-754 标准表示。</p>
<h4 id="numeric-operations"><a class="header" href="#numeric-operations">数值运算</a></h4>
<p data-x-en="Rust supports the basic mathematical operations you’d expect for all the number types: addition, subtraction, multiplication, division, and remainder. Integer division truncates toward zero to the nearest integer. The following code shows how you’d use each numeric operation in a let statement:">Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取余。整数除法会向零舍入到最近的整数。以下代码展示了如何在 <code>let</code> 语句中使用每个数值运算：</p>
<p data-x-en="Filename: src/main.rs"><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1

    // remainder
    let remainder = 43 % 5;
}</code></pre></pre>
<p data-x-en="Each expression in these statements uses a mathematical operator and evaluates to a single value, which is then bound to a variable. Appendix B contains a list of all operators that Rust provides.">这些语句中的每个表达式都使用了一个数学运算符，并评估为一个单一的值，然后绑定到一个变量。 <a href="appendix-02-operators.html">附录 B</a><!-- ignore --> 包含了 Rust 提供的所有运算符的列表。</p>
<h4 id="the-boolean-type"><a class="header" href="#the-boolean-type">布尔类型</a></h4>
<p data-x-en="As in most other programming languages, a Boolean type in Rust has two possible values: true and false. Booleans are one byte in size. The Boolean type in Rust is specified using bool. For example:">如大多数其他编程语言一样，Rust 中的布尔类型有两种可能的值：<code>true</code> 和 <code>false</code>。布尔值占用一个字节。Rust 中的布尔类型使用 <code>bool</code> 指定。例如：</p>
<p data-x-en="Filename: src/main.rs"><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}</code></pre></pre>
<p data-x-en="The main way to use Boolean values is through conditionals, such as an if expression. We’ll cover how if expressions work in Rust in the “Control Flow” section.">使用布尔值的主要方式是通过条件语句，例如 <code>if</code> 表达式。我们将在 <a href="ch03-05-control-flow.html#control-flow">“控制流”</a><!-- ignore --> 部分介绍 Rust 中 <code>if</code> 表达式的工作原理。</p>
<h4 id="the-character-type"><a class="header" href="#the-character-type">字符类型</a></h4>
<p data-x-en="Rust’s char type is the language’s most primitive alphabetic type. Here are some examples of declaring char values:">Rust 的 <code>char</code> 类型是语言中最基本的字母类型。以下是一些声明 <code>char</code> 值的示例：</p>
<p data-x-en="Filename: src/main.rs"><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}</code></pre></pre>
<p data-x-en="Note that we specify char literals with single quotes, as opposed to string literals, which use double quotes. Rust’s char type is four bytes in size and represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII. Accented letters; Chinese, Japanese, and Korean characters; emoji; and zero-width spaces are all valid char values in Rust. Unicode Scalar Values range from U+0000 to U+D7FF and U+E000 to U+10FFFF inclusive. However, a “character” isn’t really a concept in Unicode, so your human intuition for what a “character” is may not match up with what a char is in Rust. We’ll discuss this topic in detail in “Storing UTF-8 Encoded Text with Strings” in Chapter 8.">请注意，我们使用单引号指定 <code>char</code> 字面量，而字符串字面量则使用双引号。Rust 的 <code>char</code> 类型大小为四个字节，表示一个 Unicode 标量值，这意味着它可以表示比 ASCII 更多的内容。带重音的字母；中文、日文和韩文字符；表情符号；以及零宽度空格都是 Rust 中有效的 <code>char</code> 值。Unicode 标量值的范围从 <code>U+0000</code> 到 <code>U+D7FF</code> 和 <code>U+E000</code> 到 <code>U+10FFFF</code>（包括这两个范围）。然而，“字符”在 Unicode 中并不是一个真正的概念，因此你对“字符”的直觉可能与 Rust 中的 <code>char</code> 不完全匹配。我们将在第 8 章的 <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">“使用字符串存储 UTF-8 编码的文本”</a><!-- ignore --> 中详细讨论这个主题。</p>
<h3 id="compound-types"><a class="header" href="#compound-types">复合类型</a></h3>
<p data-x-en="Compound types can group multiple values into one type. Rust has two primitive compound types: tuples and arrays."><em>复合类型</em>可以将多个值组合成一种类型。Rust 有两种原始复合类型：元组和数组。</p>
<h4 id="the-tuple-type"><a class="header" href="#the-tuple-type">元组类型</a></h4>
<p data-x-en="A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.">一个 <em>元组</em> 是将多个具有不同类型的值组合成一种复合类型的一般方法。元组具有固定长度：一旦声明，它们不能增长或缩小。</p>
<p data-x-en="We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don’t have to be the same. We’ve added optional type annotations in this example:">我们通过在括号内写入以逗号分隔的值列表来创建元组。元组中的每个位置都有一个类型，元组中不同值的类型不必相同。我们在本例中添加了可选的类型注解：</p>
<p data-x-en="Filename: src/main.rs"><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre></pre>
<p data-x-en="The variable tup binds to the entire tuple because a tuple is considered a single compound element. To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this:">变量 <code>tup</code> 绑定到整个元组，因为元组被视为一个复合元素。要从元组中获取单个值，我们可以使用模式匹配来解构元组值，如下所示：</p>
<p data-x-en="Filename: src/main.rs"><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}</code></pre></pre>
<p data-x-en="This program first creates a tuple and binds it to the variable tup. It then uses a pattern with let to take tup and turn it into three separate variables, x, y, and z. This is called destructuring because it breaks the single tuple into three parts. Finally, the program prints the value of y, which is 6.4.">这个程序首先创建一个元组并将其绑定到变量<code>tup</code>。然后
使用带有<code>let</code>的模式来取<code>tup</code>并将其转换为三个独立的
变量，<code>x</code>、<code>y</code>和<code>z</code>。这被称为<em>解构</em>，因为它将
单个元组分解为三个部分。最后，程序打印<code>y</code>的值，即<code>6.4</code>。</p>
<p data-x-en="We can also access a tuple element directly by using a period (.) followed by the index of the value we want to access. For example:">我们也可以通过使用点 (<code>.</code>) 后跟我们想要访问的值的索引来直接访问元组元素。例如：</p>
<p data-x-en="Filename: src/main.rs"><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}</code></pre></pre>
<p data-x-en="This program creates the tuple x and then accesses each element of the tuple using their respective indices. As with most programming languages, the first index in a tuple is 0.">这个程序创建了元组 <code>x</code>，然后使用各自的索引来访问元组中的每个元素。与大多数编程语言一样，元组中的第一个索引是 0。</p>
<p data-x-en="The tuple without any values has a special name, unit. This value and its corresponding type are both written () and represent an empty value or an empty return type. Expressions implicitly return the unit value if they don’t return any other value.">不含任何值的元组有一个特殊的名字，<em>单元</em>。这个值及其对应的类型都写作 <code>()</code>，表示一个空值或一个空的返回类型。如果表达式没有返回其他值，它们会隐式地返回单元值。</p>
<h4 id="the-array-type"><a class="header" href="#the-array-type">数组类型</a></h4>
<p data-x-en="Another way to have a collection of multiple values is with an array. Unlike a tuple, every element of an array must have the same type. Unlike arrays in some other languages, arrays in Rust have a fixed length.">另一种拥有多个值集合的方法是使用<em>数组</em>。与元组不同，数组中的每个元素必须具有相同的类型。与其他一些语言中的数组不同，Rust 中的数组具有固定的长度。</p>
<p data-x-en="We write the values in an array as a comma-separated list inside square brackets:">我们以逗号分隔的列表形式在方括号内写入数组的值:</p>
<p data-x-en="Filename: src/main.rs"><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre></pre>
<p data-x-en="Arrays are useful when you want your data allocated on the stack, the same as the other types we have seen so far, rather than the heap (we will discuss the stack and the heap more in Chapter 4) or when you want to ensure you always have a fixed number of elements. An array isn’t as flexible as the vector type, though. A vector is a similar collection type provided by the standard library that is allowed to grow or shrink in size. If you’re unsure whether to use an array or a vector, chances are you should use a vector. Chapter 8 discusses vectors in more detail.">数组在你希望数据像我们迄今为止看到的其他类型一样分配在栈上，而不是堆上（我们将在<a href="ch04-01-what-is-ownership.html#the-stack-and-the-heap">第 4 章</a><!-- ignore -->）讨论栈和堆）时非常有用，或者当你希望确保始终拥有固定数量的元素时。然而，数组不如向量类型灵活。一个<em>向量</em>是由标准库提供的类似集合类型，<em>可以</em>增长或缩小。如果你不确定是使用数组还是向量，很可能你应该使用向量。<a href="ch08-01-vectors.html">第 8 章</a><!-- ignore -->将更详细地讨论向量。</p>
<p data-x-en="However, arrays are more useful when you know the number of elements will not need to change. For example, if you were using the names of the month in a program, you would probably use an array rather than a vector because you know it will always contain 12 elements:">然而，当您知道元素数量不会改变时，数组更为有用。例如，如果您在程序中使用月份名称，您可能会使用数组而不是向量，因为您知道它将始终包含12个元素：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
<span class="boring">}</span></code></pre></pre>
<p data-x-en="You write an array’s type using square brackets with the type of each element, a semicolon, and then the number of elements in the array, like so:">您使用方括号编写数组的类型，其中包含每个元素的类型、一个分号，然后是数组中的元素数量，如下所示：<code>类型[数量]</code></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p data-x-en="Here, i32 is the type of each element. After the semicolon, the number 5 indicates the array contains five elements.">这里，<code>i32</code> 是每个元素的类型。分号后的数字 <code>5</code> 表示数组包含五个元素。</p>
<p data-x-en="You can also initialize an array to contain the same value for each element by specifying the initial value, followed by a semicolon, and then the length of the array in square brackets, as shown here:">你也可以通过指定初始值，后跟一个分号，然后在方括号中指定数组的长度来初始化数组，使每个元素包含相同的值，如下所示：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p data-x-en="The array named a will contain 5 elements that will all be set to the value 3 initially. This is the same as writing let a = [3, 3, 3, 3, 3]; but in a more concise way.">数组 <code>a</code> 将包含 <code>5</code> 个元素，这些元素的初始值都将被设置为 <code>3</code>。这与编写 <code>let a = [3, 3, 3, 3, 3];</code> 相同，但更为简洁。</p>
<h5 id="accessing-array-elements"><a class="header" href="#accessing-array-elements">Accessing Array Elements</a></h5>
<p data-x-en="An array is a single chunk of memory of a known, fixed size that can be allocated on the stack. You can access elements of an array using indexing, like this:">一个数组是一块已知固定大小的内存，可以分配在栈上。你可以使用索引访问数组的元素，如下所示：<code>let a = [1, 2, 3, 4, 5];</code> <code>let first_element = a[0];</code></p>
<p data-x-en="Filename: src/main.rs"><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}</code></pre></pre>
<p data-x-en="In this example, the variable named first will get the value 1 because that is the value at index [0] in the array. The variable named second will get the value 2 from index [1] in the array.">在这个例子中，名为 <code>first</code> 的变量将获得值 <code>1</code>，因为这是数组中索引 <code>[0]</code> 处的值。名为 <code>second</code> 的变量将从数组的索引 <code>[1]</code> 处获得值 <code>2</code>。</p>
<h5 id="invalid-array-element-access"><a class="header" href="#invalid-array-element-access">Invalid Array Element Access</a></h5>
<p data-x-en="Let’s see what happens if you try to access an element of an array that is past the end of the array. Say you run this code, similar to the guessing game in Chapter 2, to get an array index from the user:">让我们看看如果你尝试访问数组末尾之后的元素会发生什么。假设你运行了这段代码，类似于第2章中的猜数字游戏，从用户那里获取数组索引：</p>
<p data-x-en="Filename: src/main.rs"><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {index} is: {element}");
}</code></pre>
<p data-x-en="This code compiles successfully. If you run this code using cargo run and enter 0, 1, 2, 3, or 4, the program will print out the corresponding value at that index in the array. If you instead enter a number past the end of the array, such as 10, you’ll see output like this:">这段代码编译成功。如果您使用 <code>cargo run</code> 运行此代码并输入 <code>0</code>、<code>1</code>、<code>2</code>、<code>3</code> 或 <code>4</code>，程序将打印出数组中该索引处的对应值。如果您输入一个超过数组末尾的数字，例如 <code>10</code>，您将看到如下输出：</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p data-x-en="The program resulted in a runtime error at the point of using an invalid value in the indexing operation. The program exited with an error message and didn’t execute the final println! statement. When you attempt to access an element using indexing, Rust will check that the index you’ve specified is less than the array length. If the index is greater than or equal to the length, Rust will panic. This check has to happen at runtime, especially in this case, because the compiler can’t possibly know what value a user will enter when they run the code later.">程序在使用无效值进行索引操作时导致了<em>运行时</em>错误。程序退出时显示了错误消息，并且没有执行最后的<code>println!</code>语句。当你尝试使用索引访问元素时，Rust 会检查你指定的索引是否小于数组长度。如果索引大于或等于长度，Rust 将会崩溃。这种检查必须在运行时进行，特别是在这种情况下，因为编译器不可能知道用户在稍后运行代码时会输入什么值。</p>
<p data-x-en="This is an example of Rust’s memory safety principles in action. In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed. Rust protects you against this kind of error by immediately exiting instead of allowing the memory access and continuing. Chapter 9 discusses more of Rust’s error handling and how you can write readable, safe code that neither panics nor allows invalid memory access.">这是 Rust 内存安全原则的一个实例。在许多低级语言中，不会进行这种检查，当你提供一个错误的索引时，可能会访问到无效的内存。Rust 通过立即退出而不是允许内存访问并继续执行来保护你免受此类错误的影响。第 9 章将讨论更多关于 Rust 的错误处理以及如何编写既可读又安全的代码，这些代码既不会引发恐慌也不会允许访问无效内存。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-01-variables-and-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-03-how-functions-work.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-01-variables-and-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-03-how-functions-work.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    

</body></html>