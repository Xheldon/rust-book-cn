<!DOCTYPE html><html lang="zh-CN" class="light sidebar-visible" dir="ltr"><head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>路径用于引用模块树中的项 - 《Rust编程语言》</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    <meta name="title" content="Rust 中文"><meta property="og:title" content="Rust 中文"><meta name="description" content="Rust 中文文档"><meta property="og:description" content="Rust 中文文档"><meta name="url" content="https://rust.xheldon.com"><meta property="og:url" content="https://rust.xheldon.com"><script src="https://www.googletagmanager.com/gtag/js?id=G-V7NE1X37EX"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-V7NE1X37EX')</script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486286026923411"></script><style>/* hover 显示原文 */
p[data-x-en],
li[data-x-en] {
  position: relative;
}
p[data-x-en]:hover::after,
li[data-x-en]:hover::after {
  visibility: visible;
  opacity: 1;
}
p[data-x-en]::after,
li[data-x-en]::after {
  content: attr(data-x-en);
  display: block;
  font-size: 12px;
  transition: all 0.2s 0.3s;
  visibility: hidden;
  opacity: 0;
  background: var(--searchbar-bg);
  z-index: 99;
  border-radius: 4px;
  padding: 5px 10px;
  position: absolute;
  top: 100%;
  left: 0;
}
/* 译者注释内容 */
div[type='comment'] {
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  background: #eee;
}
div[type='comment']::before {
  content: '译者注: ';
  font-weight: 900;
}
header a.logo {
  position: relative;
}
header a.logo::after {
  content: '中文';
  position: absolute;
  left: calc(100% + 5px);
  font-size: 12px;
  width: 50px;
  top: -5px;
}
#banner-info {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  font-size: 12px;
  padding: 0;
  z-index: 999;
}
#add-info {
  font-size: 14px;
}
blockquote {
  border-left: 5px solid #ccc;
  padding-left: 10px;
  margin-left: 0;
}
.content {
  overflow-y: unset !important;
}
</style></head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky"><div id="banner-info">本文档为 AI + 人工翻译，hover 可以显示原文。当前页翻译有问题？<a style="cursor: pointer;" href="https://github.com/Xheldon/rust-book-cn/blob/main/dict/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.json" target="_blank">我来翻译！</a></div>
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    <a href="https://github.com/Xheldon/rust-book-cn" target="_blank"><i class="fa fa-language"></i></a><a href="https://www.xheldon.com" target="_blank"><i class="fa fa-id-card"></i></a></div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="paths-for-referring-to-an-item-in-the-module-tree"><a class="header" href="#paths-for-referring-to-an-item-in-the-module-tree">模块树中引用项的路径</a></h2>
<p data-x-en="To show Rust where to find an item in a module tree, we use a path in the same way we use a path when navigating a filesystem. To call a function, we need to know its path.">为了告诉 Rust 在模块树中查找某个项的位置，我们使用路径，就像在导航文件系统时使用路径一样。要调用一个函数，我们需要知道它的路径。</p>
<p data-x-en="A path can take two forms:">路径可以有两种形式：</p>
<ul>
<li data-x-en="An absolute path is the full path starting from a crate root; for code from an external crate, the absolute path begins with the crate name, and for code from the current crate, it starts with the literal crate.">一个<em>绝对路径</em>是从crate根开始的完整路径；对于来自外部crate的代码，绝对路径以crate名称开始，而对于当前crate的代码，它以字面<code>crate</code>开始。</li>
<li data-x-en="A relative path starts from the current module and uses self, super, or an identifier in the current module.">一个<em>相对路径</em>从当前模块开始，并使用<code>self</code>、<code>super</code>或当前模块中的标识符。</li>
</ul>
<p data-x-en="Both absolute and relative paths are followed by one or more identifiers separated by double colons (::).">绝对路径和相对路径后面都跟着一个或多个由双冒号 (<code>::</code>) 分隔的标识符。</p>
<p data-x-en="Returning to Listing 7-1, say we want to call the add_to_waitlist function. This is the same as asking: What’s the path of the add_to_waitlist function? Listing 7-3 contains Listing 7-1 with some of the modules and functions removed.">回到清单 7-1，假设我们想要调用 <code>add_to_waitlist</code> 函数。
这相当于问：<code>add_to_waitlist</code> 函数的路径是什么？
清单 7-3 包含了清单 7-1 的内容，但移除了一些模块和函数。</p>
<p data-x-en="We’ll show two ways to call the add_to_waitlist function from a new function, eat_at_restaurant, defined in the crate root. These paths are correct, but there’s another problem remaining that will prevent this example from compiling as is. We’ll explain why in a bit.">我们将展示两种从新函数<code>eat_at_restaurant</code>调用<code>add_to_waitlist</code>函数的方法，这些函数在crate根目录中定义。这些路径是正确的，但还有一个问题会导致此示例无法编译。我们稍后会解释原因。</p>
<p data-x-en="The eat_at_restaurant function is part of our library crate’s public API, so we mark it with the pub keyword. In the “Exposing Paths with the pub Keyword” section, we’ll go into more detail about pub."><code>eat_at_restaurant</code> 函数是我们库crate的公共API的一部分，所以我们用 <code>pub</code> 关键字标记它。在 <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">“使用 <code>pub</code> 关键字暴露路径”</a><!-- ignore --> 部分，我们将详细介绍 <code>pub</code>。</p>
<figure class="listing" id="listing-7-3">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<figcaption><a href="#listing-7-3">Listing 7-3</a>: Calling the <code>add_to_waitlist</code> function using absolute and relative paths</figcaption>
</figure>
<p data-x-en="The first time we call the add_to_waitlist function in eat_at_restaurant, we use an absolute path. The add_to_waitlist function is defined in the same crate as eat_at_restaurant, which means we can use the crate keyword to start an absolute path. We then include each of the successive modules until we make our way to add_to_waitlist. You can imagine a filesystem with the same structure: We’d specify the path /front_of_house/hosting/add_to_waitlist to run the add_to_waitlist program; using the crate name to start from the crate root is like using / to start from the filesystem root in your shell.">我们第一次在 <code>eat_at_restaurant</code> 中调用 <code>add_to_waitlist</code> 函数时，
我们使用了一个绝对路径。<code>add_to_waitlist</code> 函数定义在与 <code>eat_at_restaurant</code> 相同的
crate 中，这意味着我们可以使用 <code>crate</code> 关键字来
开始一个绝对路径。然后我们包含每个后续的模块，直到我们到达 <code>add_to_waitlist</code>。你可以想象一个具有相同
结构的文件系统：我们会指定路径 <code>/front_of_house/hosting/add_to_waitlist</code> 来
运行 <code>add_to_waitlist</code> 程序；使用 <code>crate</code> 名称从
crate 根开始就像在你的 shell 中使用 <code>/</code> 从文件系统根开始一样。</p>
<p data-x-en="The second time we call add_to_waitlist in eat_at_restaurant, we use a relative path. The path starts with front_of_house, the name of the module defined at the same level of the module tree as eat_at_restaurant. Here the filesystem equivalent would be using the path front_of_house/hosting/add_to_waitlist. Starting with a module name means that the path is relative.">我们在 <code>eat_at_restaurant</code> 中第二次调用 <code>add_to_waitlist</code> 时，使用了相对路径。路径从 <code>front_of_house</code> 开始，这是与 <code>eat_at_restaurant</code> 在模块树同一级别的模块的名称。在这里，文件系统中的等效路径将是 <code>front_of_house/hosting/add_to_waitlist</code>。以模块名称开头意味着路径是相对的。</p>
<p data-x-en="Choosing whether to use a relative or absolute path is a decision you’ll make based on your project, and it depends on whether you’re more likely to move item definition code separately from or together with the code that uses the item. For example, if we moved the front_of_house module and the eat_at_restaurant function into a module named customer_experience, we’d need to update the absolute path to add_to_waitlist, but the relative path would still be valid. However, if we moved the eat_at_restaurant function separately into a module named dining, the absolute path to the add_to_waitlist call would stay the same, but the relative path would need to be updated. Our preference in general is to specify absolute paths because it’s more likely we’ll want to move code definitions and item calls independently of each other.">选择使用相对路径还是绝对路径是基于你的项目做出的决定，这取决于你更可能将项定义代码与使用该项的代码分开移动还是一起移动。例如，如果我们把 <code>front_of_house</code> 模块和 <code>eat_at_restaurant</code> 函数移到一个名为 <code>customer_experience</code> 的模块中，我们需要更新调用 <code>add_to_waitlist</code> 的绝对路径，但相对路径仍然有效。然而，如果我们单独将 <code>eat_at_restaurant</code> 函数移到一个名为 <code>dining</code> 的模块中，调用 <code>add_to_waitlist</code> 的绝对路径将保持不变，但相对路径需要更新。我们通常更倾向于指定绝对路径，因为更可能我们希望独立地移动代码定义和项调用。</p>
<p data-x-en="Let’s try to compile Listing 7-3 and find out why it won’t compile yet! The errors we get are shown in Listing 7-4.">让我们尝试编译清单 7-3 并找出为什么它还不能编译！我们得到的错误如清单 7-4 所示。</p>
<figure class="listing" id="listing-7-4">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
  |                            |
  |                            private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
   |                     |
   |                     private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<figcaption><a href="#listing-7-4">Listing 7-4</a>: Compiler errors from building the code in Listing 7-3</figcaption>
</figure>
<p data-x-en="The error messages say that module hosting is private. In other words, we have the correct paths for the hosting module and the add_to_waitlist function, but Rust won’t let us use them because it doesn’t have access to the private sections. In Rust, all items (functions, methods, structs, enums, modules, and constants) are private to parent modules by default. If you want to make an item like a function or struct private, you put it in a module.">错误消息说模块 <code>hosting</code> 是私有的。换句话说，我们有 <code>hosting</code> 模块和 <code>add_to_waitlist</code> 函数的正确路径，但 Rust 不让我们使用它们，因为它无法访问私有部分。在 Rust 中，默认情况下所有项（函数、方法、结构体、枚举、模块和常量）对父模块都是私有的。如果你想让一个项如函数或结构体私有，你可以将其放在一个模块中。</p>
<p data-x-en="Items in a parent module can’t use the private items inside child modules, but items in child modules can use the items in their ancestor modules. This is because child modules wrap and hide their implementation details, but the child modules can see the context in which they’re defined. To continue with our metaphor, think of the privacy rules as being like the back office of a restaurant: What goes on in there is private to restaurant customers, but office managers can see and do everything in the restaurant they operate.">父模块中的项不能使用子模块中的私有项，但子模块中的项可以使用其祖先模块中的项。这是因为子模块封装并隐藏了它们的实现细节，但子模块可以看到它们被定义的上下文。继续我们的比喻，可以把隐私规则想象成餐厅的后台办公室：后台发生的事情对餐厅顾客来说是私密的，但办公室经理可以看到并操作他们经营的餐厅中的一切。</p>
<p data-x-en="Rust chose to have the module system function this way so that hiding inner implementation details is the default. That way, you know which parts of the inner code you can change without breaking the outer code. However, Rust does give you the option to expose inner parts of child modules’ code to outer ancestor modules by using the pub keyword to make an item public.">Rust 选择让模块系统以这种方式工作，以便隐藏内部实现细节成为默认行为。这样，你就知道可以在不破坏外部代码的情况下更改内部代码的哪些部分。然而，Rust 确实提供了通过使用 <code>pub</code> 关键字将项公开的选项，以使子模块的内部代码对父模块可见。</p>
<h3 id="exposing-paths-with-the-pub-keyword"><a class="header" href="#exposing-paths-with-the-pub-keyword">使用 <code>pub</code> 关键字暴露路径</a></h3>
<p data-x-en="Let’s return to the error in Listing 7-4 that told us the hosting module is private. We want the eat_at_restaurant function in the parent module to have access to the add_to_waitlist function in the child module, so we mark the hosting module with the pub keyword, as shown in Listing 7-5.">让我们回到列表 7-4 中的错误，它告诉我们 <code>hosting</code> 模块是私有的。我们希望父模块中的 <code>eat_at_restaurant</code> 函数能够访问子模块中的 <code>add_to_waitlist</code> 函数，因此我们使用 <code>pub</code> 关键字标记 <code>hosting</code> 模块，如列表 7-5 所示。</p>
<figure class="listing" id="listing-7-5">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

// -- snip --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // Absolute path
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // Relative path
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-7-5">Listing 7-5</a>: Declaring the <code>hosting</code> module as <code>pub</code> to use it from <code>eat_at_restaurant</code></figcaption>
</figure>
<p data-x-en="Unfortunately, the code in Listing 7-5 still results in compiler errors, as shown in Listing 7-6.">不幸的是，清单 7-5 中的代码仍然会导致编译器错误，如 清单 7-6 所示。</p>
<figure class="listing" id="listing-7-6">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:10:37
   |
10 |     crate::front_of_house::hosting::add_to_waitlist();
   |                                     ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:13:30
   |
13 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<figcaption><a href="#listing-7-6">Listing 7-6</a>: Compiler errors from building the code in Listing 7-5</figcaption>
</figure>
<p data-x-en="What happened? Adding the pub keyword in front of mod hosting makes the module public. With this change, if we can access front_of_house, we can access hosting. But the contents of hosting are still private; making the module public doesn’t make its contents public. The pub keyword on a module only lets code in its ancestor modules refer to it, not access its inner code. Because modules are containers, there’s not much we can do by only making the module public; we need to go further and choose to make one or more of the items within the module public as well.">发生了什么？在 <code>mod hosting</code> 前面添加 <code>pub</code> 关键字使模块变为公共模块。通过这一更改，如果我们能够访问 <code>front_of_house</code>，我们就可以访问 <code>hosting</code>。但是 <code>hosting</code> 的 <em>内容</em> 仍然是私有的；将模块设为公共模块并不会使其内容也变为公共的。<code>pub</code> 关键字在模块上仅允许其祖先模块中的代码引用它，而不能访问其内部代码。由于模块是容器，仅将模块设为公共模块并不能做太多事情；我们需要进一步选择将模块内的一个或多个项设为公共的。</p>
<p data-x-en="The errors in Listing 7-6 say that the add_to_waitlist function is private. The privacy rules apply to structs, enums, functions, and methods as well as modules.">列表 7-6 中的错误表明 <code>add_to_waitlist</code> 函数是私有的。
隐私规则适用于结构体、枚举、函数和方法以及模块。</p>
<p data-x-en="Let’s also make the add_to_waitlist function public by adding the pub keyword before its definition, as in Listing 7-7.">让我们也通过在定义前添加 <code>pub</code> 关键字来使 <code>add_to_waitlist</code> 函数公开，如清单 7-7 所示。</p>
<figure class="listing" id="listing-7-7">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// -- snip --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // Absolute path
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // Relative path
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-7-7">Listing 7-7</a>: Adding the <code>pub</code> keyword to <code>mod hosting</code> and <code>fn add_to_waitlist</code> lets us call the function from <code>eat_at_restaurant</code>.</figcaption>
</figure>
<p data-x-en="Now the code will compile! To see why adding the pub keyword lets us use these paths in eat_at_restaurant with respect to the privacy rules, let’s look at the absolute and the relative paths.">现在代码可以编译了！要了解为什么添加 <code>pub</code> 关键字让我们能够在 <code>eat_at_restaurant</code> 中使用这些路径，同时遵守隐私规则，让我们来看看绝对路径和相对路径。</p>
<p data-x-en="In the absolute path, we start with crate, the root of our crate’s module tree. The front_of_house module is defined in the crate root. While front_of_house isn’t public, because the eat_at_restaurant function is defined in the same module as front_of_house (that is, eat_at_restaurant and front_of_house are siblings), we can refer to front_of_house from eat_at_restaurant. Next is the hosting module marked with pub. We can access the parent module of hosting, so we can access hosting. Finally, the add_to_waitlist function is marked with pub, and we can access its parent module, so this function call works!">在绝对路径中，我们从 <code>crate</code> 开始，这是我们的 crate 模块树的根。 <code>front_of_house</code> 模块在 crate 根中定义。虽然 <code>front_of_house</code> 不是公共的，但由于 <code>eat_at_restaurant</code> 函数与 <code>front_of_house</code> 定义在同一个模块中（即 <code>eat_at_restaurant</code> 和 <code>front_of_house</code> 是同级的），我们可以从 <code>eat_at_restaurant</code> 引用 <code>front_of_house</code>。接下来是标记为 <code>pub</code> 的 <code>hosting</code> 模块。我们可以访问 <code>hosting</code> 的父模块，因此我们可以访问 <code>hosting</code>。最后， <code>add_to_waitlist</code> 函数标记为 <code>pub</code>，并且我们可以访问其父模块，所以这个函数调用可以工作！</p>
<p data-x-en="In the relative path, the logic is the same as the absolute path except for the first step: Rather than starting from the crate root, the path starts from front_of_house. The front_of_house module is defined within the same module as eat_at_restaurant, so the relative path starting from the module in which eat_at_restaurant is defined works. Then, because hosting and add_to_waitlist are marked with pub, the rest of the path works, and this function call is valid!">在相对路径中，逻辑与绝对路径相同，只是第一步不同：不是从crate根开始，而是从<code>front_of_house</code>开始。<code>front_of_house</code>模块与<code>eat_at_restaurant</code>定义在同一个模块中，因此从<code>eat_at_restaurant</code>定义的模块开始的相对路径是有效的。然后，因为<code>hosting</code>和<code>add_to_waitlist</code>被标记为<code>pub</code>，所以路径的其余部分有效，这个函数调用是有效的！</p>
<p data-x-en="If you plan to share your library crate so that other projects can use your code, your public API is your contract with users of your crate that determines how they can interact with your code. There are many considerations around managing changes to your public API to make it easier for people to depend on your crate. These considerations are beyond the scope of this book; if you’re interested in this topic, see the Rust API Guidelines.">如果你计划共享你的库crate，以便其他项目可以使用你的代码，那么你的公共API就是你与crate用户之间的契约，决定了他们如何与你的代码交互。在管理公共API的变更时有许多需要考虑的问题，以使人们更容易依赖你的crate。这些考虑超出了本书的范围；如果你对这个话题感兴趣，可以参见<a href="https://rust-lang.github.io/api-guidelines/">Rust API Guidelines</a>。</p>
<section class="note" aria-role="note">
<h4 id="best-practices-for-packages-with-a-binary-and-a-library"><a class="header" href="#best-practices-for-packages-with-a-binary-and-a-library">包含二进制文件和库的包的最佳实践</a></h4>
<p data-x-en="We mentioned that a package can contain both a src/main.rs binary crate root as well as a src/lib.rs library crate root, and both crates will have the package name by default. Typically, packages with this pattern of containing both a library and a binary crate will have just enough code in the binary crate to start an executable that calls code defined in the library crate. This lets other projects benefit from the most functionality that the package provides because the library crate’s code can be shared.">我们提到，一个包可以同时包含一个 <em>src/main.rs</em> 二进制包根和一个 <em>src/lib.rs</em> 库包根，默认情况下这两个包都会使用包名。通常，具有这种同时包含库和二进制包模式的包，其二进制包中只包含足够的代码来启动一个调用库包中定义的代码的可执行文件。这使得其他项目可以从包提供的大部分功能中受益，因为库包的代码可以被共享。</p>
<p data-x-en="The module tree should be defined in src/lib.rs. Then, any public items can be used in the binary crate by starting paths with the name of the package. The binary crate becomes a user of the library crate just like a completely external crate would use the library crate: It can only use the public API. This helps you design a good API; not only are you the author, but you’re also a client!">模块树应该在 <em>src/lib.rs</em> 中定义。然后，任何公共项都可以通过以包的名称开头的路径在二进制 crate 中使用。
二进制 crate 成为库 crate 的用户，就像完全外部的 crate 使用库 crate 一样：它只能使用公共 API。
这有助于你设计一个好的 API；不仅是作者，你也是客户端！</p>
<p data-x-en="In Chapter 12, we’ll demonstrate this organizational practice with a command line program that will contain both a binary crate and a library crate.">在<a href="ch12-00-an-io-project.html">第 12 章</a><!-- ignore -->，我们将通过一个命令行程序演示这种组织实践，该程序将同时包含一个二进制包和一个库包。</p>
</section>
<h3 id="starting-relative-paths-with-super"><a class="header" href="#starting-relative-paths-with-super">以 <code>super</code> 开始的相对路径</a></h3>
<p data-x-en="We can construct relative paths that begin in the parent module, rather than the current module or the crate root, by using super at the start of the path. This is like starting a filesystem path with the .. syntax that means to go to the parent directory. Using super allows us to reference an item that we know is in the parent module, which can make rearranging the module tree easier when the module is closely related to the parent but the parent might be moved elsewhere in the module tree someday.">我们可以通过在路径的开头使用<code>super</code>来构建从父模块而不是当前模块或crate根开始的相对路径。这类似于使用<code>..</code>语法在文件系统路径中表示进入父目录。使用<code>super</code>可以让我们引用我们知道在父模块中的项，这在模块与父模块紧密相关但父模块将来可能被移动到模块树的其他位置时，可以使重新排列模块树更加容易。</p>
<p data-x-en="Consider the code in Listing 7-8 that models the situation in which a chef fixes an incorrect order and personally brings it out to the customer. The function fix_incorrect_order defined in the back_of_house module calls the function deliver_order defined in the parent module by specifying the path to deliver_order, starting with super.">考虑清单 7-8 中的代码，该代码模拟了一位厨师修正错误订单并亲自将其送到客户手中的情况。<code>back_of_house</code> 模块中定义的 <code>fix_incorrect_order</code> 函数通过指定从 <code>super</code> 开始的 <code>deliver_order</code> 路径，调用了父模块中定义的 <code>deliver_order</code> 函数。</p>
<figure class="listing" id="listing-7-8">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}</code></pre>
<figcaption><a href="#listing-7-8">Listing 7-8</a>: Calling a function using a relative path starting with <code>super</code></figcaption>
</figure>
<p data-x-en="The fix_incorrect_order function is in the back_of_house module, so we can use super to go to the parent module of back_of_house, which in this case is crate, the root. From there, we look for deliver_order and find it. Success! We think the back_of_house module and the deliver_order function are likely to stay in the same relationship to each other and get moved together should we decide to reorganize the crate’s module tree. Therefore, we used super so that we’ll have fewer places to update code in the future if this code gets moved to a different module."><code>fix_incorrect_order</code> 函数位于 <code>back_of_house</code> 模块中，因此我们可以使用 <code>super</code> 转到 <code>back_of_house</code> 的父模块，在这种情况下是 <code>crate</code>，即根模块。从那里，我们查找 <code>deliver_order</code> 并找到它。成功！我们认为 <code>back_of_house</code> 模块和 <code>deliver_order</code> 函数可能会保持彼此之间的关系，并且如果决定重组 crate 的模块树，它们会被一起移动。因此，我们使用了 <code>super</code>，这样如果这段代码将来被移动到不同的模块，我们需要更新的代码位置就会更少。</p>
<h3 id="making-structs-and-enums-public"><a class="header" href="#making-structs-and-enums-public">使结构体和枚举公开</a></h3>
<p data-x-en="We can also use pub to designate structs and enums as public, but there are a few extra details to the usage of pub with structs and enums. If we use pub before a struct definition, we make the struct public, but the struct’s fields will still be private. We can make each field public or not on a case-by-case basis. In Listing 7-9, we’ve defined a public back_of_house::Breakfast struct with a public toast field but a private seasonal_fruit field. This models the case in a restaurant where the customer can pick the type of bread that comes with a meal, but the chef decides which fruit accompanies the meal based on what’s in season and in stock. The available fruit changes quickly, so customers can’t choose the fruit or even see which fruit they’ll get.">我们也可以使用 <code>pub</code> 将结构体和枚举指定为公共的，但 <code>pub</code> 与结构体和枚举的使用有一些额外的细节。如果我们在一个结构体定义前使用 <code>pub</code>，我们会使该结构体公共，但结构体的字段仍将保持私有。我们可以逐个字段地决定是否将其公开。在清单 7-9 中，我们定义了一个公共的 <code>back_of_house::Breakfast</code> 结构体，其中 <code>toast</code> 字段是公共的，但 <code>seasonal_fruit</code> 字段是私有的。这模拟了在餐厅中顾客可以选择随餐提供的面包类型，但厨师根据季节和库存决定随餐提供的水果。可用的水果变化很快，因此顾客不能选择水果，甚至不能看到他们会得到哪种水果。</p>
<figure class="listing" id="listing-7-9">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast.
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like.
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal.
    // meal.seasonal_fruit = String::from("blueberries");
}</code></pre>
<figcaption><a href="#listing-7-9">Listing 7-9</a>: A struct with some public fields and some private fields</figcaption>
</figure>
<p data-x-en="Because the toast field in the back_of_house::Breakfast struct is public, in eat_at_restaurant we can write and read to the toast field using dot notation. Notice that we can’t use the seasonal_fruit field in eat_at_restaurant, because seasonal_fruit is private. Try uncommenting the line modifying the seasonal_fruit field value to see what error you get!">因为 <code>back_of_house::Breakfast</code> 结构体中的 <code>toast</code> 字段是公开的，在 <code>eat_at_restaurant</code> 中我们可以使用点符号来写入和读取 <code>toast</code> 字段。注意，我们不能在 <code>eat_at_restaurant</code> 中使用 <code>seasonal_fruit</code> 字段，因为 <code>seasonal_fruit</code> 是私有的。尝试取消注释修改 <code>seasonal_fruit</code> 字段值的行，看看你会得到什么错误！</p>
<p data-x-en="Also, note that because back_of_house::Breakfast has a private field, the struct needs to provide a public associated function that constructs an instance of Breakfast (we’ve named it summer here). If Breakfast didn’t have such a function, we couldn’t create an instance of Breakfast in eat_at_restaurant, because we couldn’t set the value of the private seasonal_fruit field in eat_at_restaurant.">另外，请注意，因为 <code>back_of_house::Breakfast</code> 有一个私有字段，所以该结构体需要提供一个公共关联函数来构造一个 <code>Breakfast</code> 实例（在这里我们将其命名为 <code>summer</code>）。如果 <code>Breakfast</code> 没有这样一个函数，我们就无法在 <code>eat_at_restaurant</code> 中创建一个 <code>Breakfast</code> 实例，因为我们在 <code>eat_at_restaurant</code> 中无法设置私有字段 <code>seasonal_fruit</code> 的值。</p>
<p data-x-en="In contrast, if we make an enum public, all of its variants are then public. We only need the pub before the enum keyword, as shown in Listing 7-10.">相比之下，如果我们使一个枚举公开，那么它的所有变体都将公开。我们只需要在 <code>enum</code> 关键字前加上 <code>pub</code>，如清单 7-10 所示。</p>
<figure class="listing" id="listing-7-10">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}</code></pre>
<figcaption><a href="#listing-7-10">Listing 7-10</a>: Designating an enum as public makes all its variants public.</figcaption>
</figure>
<p data-x-en="Because we made the Appetizer enum public, we can use the Soup and Salad variants in eat_at_restaurant.">因为我们将 <code>Appetizer</code> 枚举公开，所以可以在 <code>eat_at_restaurant</code> 中使用 <code>Soup</code> 和 <code>Salad</code> 变体。</p>
<p data-x-en="Enums aren’t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with pub in every case, so the default for enum variants is to be public. Structs are often useful without their fields being public, so struct fields follow the general rule of everything being private by default unless annotated with pub.">枚举类型除非其变体是公开的，否则并不是很实用；如果每次都要为所有枚举变体标注<code>pub</code>会很麻烦，所以枚举变体的默认状态是公开的。结构体即使其字段不是公开的也经常是有用的，因此结构体字段遵循一切默认为私有的规则，除非标注了<code>pub</code>。</p>
<p data-x-en="There’s one more situation involving pub that we haven’t covered, and that is our last module system feature: the use keyword. We’ll cover use by itself first, and then we’ll show how to combine pub and use.">还有另一种涉及<code>pub</code>的情况我们尚未讨论，那就是我们模块系统中的最后一个特性：<code>use</code>关键字。我们首先单独介绍<code>use</code>，然后展示如何结合使用<code>pub</code>和<code>use</code>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-02-defining-modules-to-control-scope-and-privacy.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-02-defining-modules-to-control-scope-and-privacy.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    

</body></html>