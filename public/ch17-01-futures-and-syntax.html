<!DOCTYPE html><html lang="zh-CN" class="light sidebar-visible" dir="ltr"><head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Futures and the Async Syntax - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    <script src="https://www.googletagmanager.com/gtag/js?id=G-V7NE1X37EX"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-V7NE1X37EX')</script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486286026923411"></script><style>/* hover 显示原文 */
p[data-x-en],
li[data-x-en] {
  position: relative;
}
p[data-x-en]:hover::after,
li[data-x-en]:hover::after {
  visibility: visible;
  opacity: 1;
}
p[data-x-en]::after,
li[data-x-en]::after {
  content: attr(data-x-en);
  display: block;
  font-size: 12px;
  transition: all 0.2s 0.3s;
  visibility: hidden;
  opacity: 0;
  background: #cccccc;
  z-index: 99;
  border-radius: 4px;
  padding: 5px 10px;
  position: absolute;
  top: 100%;
  left: 0;
}
/* 译者注释内容 */
div[type='comment'] {
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  background: #eee;
}
div[type='comment']::before {
  content: '译者注: ';
  font-weight: 900;
}
header a.logo {
  position: relative;
}
header a.logo::after {
  content: '中文';
  position: absolute;
  left: calc(100% + 5px);
  font-size: 12px;
  width: 50px;
  top: -5px;
}
#banner-info {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  background: rgba(255, 255, 255, 0.9);
  font-size: 12px;
  padding: 0;
  z-index: 999;
}
#add-info {
  font-size: 14px;
}
blockquote {
  border-left: 5px solid #ccc;
  padding-left: 10px;
  margin-left: 0;
}
</style></head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky"><div id="banner-info">本文档为 AI + 人工翻译，hover 可以显示原文。当前页翻译有问题？<a style="cursor: pointer;" href="https://github.com/Xheldon/rust-book-cn/blob/main/dict/ch17-01-futures-and-syntax.json" target="_blank">我来翻译！</a></div>
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    <a href="https://github.com/Xheldon/rust-book-cn" target="_blank"><i class="fa fa-language"></i></a><a href="https://www.xheldon.com" target="_blank"><i class="fa fa-id-card"></i></a></div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="futures-and-the-async-syntax"><a class="header" href="#futures-and-the-async-syntax">Future 和异步语法</a></h2>
<p data-x-en="The key elements of asynchronous programming in Rust are futures and Rust’s async and await keywords.">Rust 中异步编程的关键元素是 <em>future</em> 和 Rust 的 <code>async</code> 和 <code>await</code> 关键字。</p>
<p data-x-en="A future is a value which may not be ready now, but will become ready at some point in the future. (This same concept shows up in many languages, sometimes under other names such as “task” or “promise”.) Rust provides a Future trait as a building block so different async operations can be implemented with different data structures, but with a common interface. In Rust, we say that types which implement the Future trait are futures. Each type which implements Future holds its own information about the progress that has been made and what “ready” means.">A <em>未来</em> 是一个可能现在还没有准备好，但在将来的某个时间点会准备好的值。（这个相同的概念在许多语言中都有出现，有时被称为“任务”或“承诺”。）Rust 提供了一个 <code>Future</code> 特性作为构建块，以便不同的异步操作可以用不同的数据结构实现，但具有共同的接口。在 Rust 中，我们说实现了 <code>Future</code> 特性的类型是未来。每个实现 <code>Future</code> 的类型都持有自己的关于已经取得的进展和“准备好”意味着什么的信息。</p>
<p data-x-en="The async keyword can be applied to blocks and functions to specify that they can be interrupted and resumed. Within an async block or async function, you can use the await keyword to wait for a future to become ready, called awaiting a future. Each place you await a future within an async block or function is a place that async block or function may get paused and resumed. The process of checking with a future to see if its value is available yet is called polling."><code>async</code> 关键字可以应用于块和函数，以指定它们可以被中断和恢复。在 async 块或 async 函数内，您可以使用 <code>await</code> 关键字来等待一个未来值变得可用，这称为 <em>等待未来值</em>。在 async 块或函数中每个等待未来值的地方，都是该 async 块或函数可能被暂停和恢复的地方。与未来值检查其值是否已可用的过程称为 <em>轮询</em>。</p>
<p data-x-en="Some other languages also use async and await keywords for async programming. If you’re familiar with those languages, you may notice some significant differences in how Rust does things, including how it handles the syntax. That’s for good reason, as we’ll see!">一些其他语言也使用 <code>async</code> 和 <code>await</code> 关键字进行异步编程。如果你对这些语言很熟悉，你可能会注意到 Rust 在处理这些关键字时有一些显著的不同，包括语法的处理。这是有原因的，我们将会看到！</p>
<p data-x-en="Most of the time when writing async Rust, we use the async and await keywords. Rust compiles them into equivalent code using the Future trait, much as it compiles for loops into equivalent code using the Iterator trait. Because Rust provides the Future trait, though, you can also implement it for your own data types when you need to. Many of the functions we’ll see throughout this chapter return types with their own implementations of Future. We’ll return to the definition of the trait at the end of the chapter and dig into more of how it works, but this is enough detail to keep us moving forward.">大多数时候在编写异步 Rust 代码时，我们使用 <code>async</code> 和 <code>await</code>
关键字。Rust 将它们编译成使用 <code>Future</code> 特性的等效代码，就像它将 <code>for</code> 循环编译成使用 <code>Iterator</code> 特性的等效代码一样。
因为 Rust 提供了 <code>Future</code> 特性，所以你也可以为自己的数据类型实现它，当你需要时。我们将在本章中看到的许多函数返回具有自己 <code>Future</code> 实现的类型。
我们将在本章末尾回到特性的定义，并深入探讨其工作原理，但这些细节足以让我们继续前进。</p>
<p data-x-en="That may all feel a bit abstract. Let’s write our first async program: a little web scraper. We’ll pass in two URLs from the command line, fetch both of them concurrently, and return the result of whichever one finishes first. This example will have a fair bit of new syntax, but don’t worry. We’ll explain everything you need to know as we go.">这可能感觉有点抽象。让我们编写我们的第一个异步程序：一个小小的网页抓取器。我们将从命令行传入两个URL，同时获取它们，并返回最先完成的那个的结果。这个例子将包含相当多的新语法，但不要担心。我们将逐步解释你需要知道的一切。</p>
<h3 id="our-first-async-program"><a class="header" href="#our-first-async-program">我们的第一个异步程序</a></h3>
<p data-x-en="To keep this chapter focused on learning async, rather than juggling parts of the ecosystem, we have created the trpl crate (trpl is short for “The Rust Programming Language”). It re-exports all the types, traits, and functions you’ll need, primarily from the futures and tokio crates.">为了使本章专注于学习异步编程，而不是处理生态系统中的各个部分，我们创建了 <code>trpl</code> crate (<code>trpl</code> 是 “The Rust Programming Language” 的缩写)。它重新导出了你将需要的所有类型、特征和函数，主要来自 <a href="https://crates.io/crates/futures"><code>futures</code></a> 和 <a href="https://tokio.rs"><code>tokio</code></a> crate。</p>
<ul>
<li>
<p data-x-en="The futures crate is an official home for Rust experimentation for async code, and is actually where the Future type was originally designed."><code>futures</code> crate 是 Rust 异步代码实验的官方场所，实际上 <code>Future</code> 类型最初就是在这里设计的。</p>
</li>
<li>
<p data-x-en="Tokio is the most widely used async runtime in Rust today, especially (but not only!) for web applications. There are other great runtimes out there, and they may be more suitable for your purposes. We use Tokio under the hood for trpl because it’s well-tested and widely used.">Tokio 是当今 Rust 中使用最广泛的异步运行时，尤其是在（但不仅限于！）Web 应用程序中。还有其他优秀的运行时，它们可能更适合您的需求。我们在 <code>trpl</code> 中使用 Tokio 是因为它经过了充分测试并且广泛使用。</p>
</li>
</ul>
<p data-x-en="In some cases, trpl also renames or wraps the original APIs to let us stay focused on the details relevant to this chapter. If you want to understand what the crate does, we encourage you to check out its source code. You’ll be able to see what crate each re-export comes from, and we’ve left extensive comments explaining what the crate does.">在某些情况下，<code>trpl</code> 也会重命名或包装原始 API，以便我们专注于与本章相关的细节。如果您想了解该 crate 的功能，我们鼓励您查看 <a href="https://github.com/rust-lang/book/tree/main/packages/trpl">其源代码</a>。您将能够看到每个重新导出的 crate 来自哪里，我们还留下了大量注释解释该 crate 的功能。</p>
<p data-x-en="Create a new binary project named hello-async and add the trpl crate as a dependency:">创建一个名为 <code>hello-async</code> 的新二进制项目，并将 <code>trpl</code> crate 作为依赖项添加：</p>
<pre><code class="language-console">$ cargo new hello-async
$ cd hello-async
$ cargo add trpl
</code></pre>
<p data-x-en="Now we can use the various pieces provided by trpl to write our first async program. We’ll build a little command line tool which fetches two web pages, pulls the <title> element from each, and prints out the title of whichever finishes that whole process first.">现在我们可以使用<code>trpl</code>提供的各种组件来编写我们的第一个异步程序。我们将构建一个小的命令行工具，该工具获取两个网页，从每个网页中提取<code>&lt;title&gt;</code>元素，并打印出首先完成整个过程的网页的标题。</p>
<p data-x-en="Let’s start by writing a function that takes one page URL as a parameter, makes a request to it, and returns the text of the title element:">让我们从编写一个函数开始，该函数接受一个页面URL作为参数，向其发出请求，并返回标题元素的文本：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: we'll add this next!
</span><span class="boring">}
</span><span class="boring">
</span>use trpl::Html;

async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
    let response = trpl::get(url).await;
    let response_text = response.text().await;
    Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title_element| title_element.inner_html())
}</code></pre></pre>
<figcaption>Listing 17-1: Defining an async function to get the title element from an HTML page</figcaption>
</figure>
<p data-x-en="In Listing 17-1, we define a function named page_title, and we mark it with the async keyword. Then we use the trpl::get function to fetch whatever URL is passed in, and we await the response by using the await keyword. Then we get the text of the response by calling its text method, and once again await it with the await keyword. Both of these steps are asynchronous. For get, we need to wait for the server to send back the first part of its response, which will include HTTP headers, cookies, and so on. That part of the response can be delivered separately from the body of the request. Especially if the body is very large, it can take some time for it all to arrive. Thus, we have to wait for the entirety of the response to arrive, so the text method is also async.">在清单 17-1 中，我们定义了一个名为 <code>page_title</code> 的函数，并用 <code>async</code> 关键字标记它。然后我们使用 <code>trpl::get</code> 函数来获取传递的任何 URL，并通过使用 <code>await</code> 关键字来等待响应。然后我们通过调用其 <code>text</code> 方法来获取响应的文本，并再次使用 <code>await</code> 关键字等待它。这两个步骤都是异步的。对于 <code>get</code>，我们需要等待服务器发送其响应的第一部分，这将包括 HTTP 标头、cookie 等。这部分响应可以与请求的主体分开交付。特别是如果主体非常大，它可能需要一些时间才能全部到达。因此，我们必须等待响应的 <em>全部</em> 到达，所以 <code>text</code> 方法也是异步的。</p>
<p data-x-en="We have to explicitly await both of these futures, because futures in Rust are lazy: they don’t do anything until you ask them to with await. (In fact, Rust will show a compiler warning if you don’t use a future.) This should remind you of our discussion of iterators back in Chapter 13. Iterators do nothing unless you call their next method—whether directly, or using for loops or methods such as map which use next under the hood. With futures, the same basic idea applies: they do nothing unless you explicitly ask them to. This laziness allows Rust to avoid running async code until it’s actually needed.">我们必须显式地等待这两个 future，因为 Rust 中的 future 是<em>惰性</em>的：除非你用 <code>await</code> 要求它们执行，否则它们不会做任何事情。（事实上，如果你不使用一个 future，Rust 会显示一个编译器警告。）这应该让你想起我们在<a href="ch13-02-iterators.html">第 13 章</a>中关于迭代器的讨论。除非你调用它们的 <code>next</code> 方法——无论是直接调用，还是使用 <code>for</code> 循环或像 <code>map</code> 这样的方法在底层使用 <code>next</code>——否则迭代器不会做任何事情。对于 future，基本原理是相同的：除非你显式地要求它们执行，否则它们不会做任何事情。这种惰性使得 Rust 可以避免在实际需要之前运行异步代码。</p>
<section class="note" aria-role="note">
<p data-x-en="Note: This is different from the behavior we saw when using thread::spawn in the previous chapter, where the closure we passed to another thread started running immediately. It’s also different from how many other languages approach async! But it’s important for Rust. We’ll see why that is later.">注意：这与我们在上一章使用 <code>thread::spawn</code> 时看到的行为不同，当时我们传递给另一个线程的闭包会立即开始运行。这也与其他许多语言处理异步的方式不同！但对于 Rust 来说很重要。我们稍后会看到为什么这一点很重要。</p>
</section>
<p data-x-en="Once we have response_text, we can then parse it into an instance of the Html type using Html::parse. Instead of a raw string, we now have a data type we can use to work with the HTML as a richer data structure. In particular, we can use the select_first method to find the first instance of a given CSS selector. By passing the string &quot;title&quot;, we’ll get the first <title> element in the document, if there is one. Because there may not be any matching element, select_first returns an Option<ElementRef>. Finally, we use the Option::map method, which lets us work with the item in the Option if it’s present, and do nothing if it isn’t. (We could also use a match expression here, but map is more idiomatic.) In the body of the function we supply to map, we call inner_html on the title_element to get its content, which is a String. When all is said and done, we have an Option<String>.">一旦我们有了<code>response_text</code>，我们就可以使用<code>Html::parse</code>将其解析为<code>Html</code>类型的实例。现在我们有了一个可以用来处理HTML的更丰富的数据结构，而不仅仅是一个原始字符串。特别是，我们可以使用<code>select_first</code>方法来查找给定CSS选择器的第一个实例。通过传递字符串<code>"title"</code>，我们将获得文档中的第一个<code>&lt;title&gt;</code>元素，如果有的话。因为可能没有匹配的元素，<code>select_first</code>返回一个<code>Option&lt;ElementRef&gt;</code>。最后，我们使用<code>Option::map</code>方法，这让我们可以在<code>Option</code>中存在项目时对其进行操作，如果不存在则什么都不做。（我们也可以在这里使用<code>match</code>表达式，但<code>map</code>更符合惯用法。）在我们提供给<code>map</code>的函数体中，我们调用<code>title_element</code>的<code>inner_html</code>方法来获取其内容，这是一个<code>String</code>。最终，我们得到了一个<code>Option&lt;String&gt;</code>。</p>
<p data-x-en="Notice that Rust’s await keyword goes after the expression you’re awaiting, not before it. That is, it’s a postfix keyword. This may be different from what you might be used to if you have used async in other languages. Rust chose this because it makes chains of methods much nicer to work with. As a result, we can change the body of page_url_for to chain the trpl::get and text function calls together with await between them, as shown in Listing 17-2:">请注意，Rust 的 <code>await</code> 关键字放在你要等待的表达式之后，而不是之前。也就是说，它是一个 <em>后缀关键字</em>。这可能与你在其他语言中使用 async 时的习惯不同。Rust 选择这样做是因为它使得方法链的使用更加方便。因此，我们可以将 <code>page_url_for</code> 的主体改为将 <code>trpl::get</code> 和 <code>text</code> 函数调用用 <code>await</code> 连接起来，如示例 17-2 所示：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: we'll add this next!
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span>    let response_text = trpl::get(url).await.text().await;
<span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-2: Chaining with the <code>await</code> keyword</figcaption>
</figure>
<p data-x-en="With that, we have successfully written our first async function! Before we add some code in main to call it, let’s talk a little more about what we’ve written and what it means.">至此，我们成功编写了我们的第一个异步函数！在我们在 <code>main</code> 中添加一些代码来调用它之前，让我们再多谈谈我们编写的内容及其意义。</p>
<p data-x-en="When Rust sees a block marked with the async keyword, it compiles it into a unique, anonymous data type which implements the Future trait. When Rust sees a function marked with async, it compiles it into a non-async function whose body is an async block. An async function’s return type is the type of the anonymous data type the compiler creates for that async block.">当 Rust 看到一个用 <code>async</code> 关键字标记的块时，它会将其编译成一个实现 <code>Future</code> 特性的唯一、匿名数据类型。当 Rust 看到一个用 <code>async</code> 标记的函数时，它会将其编译成一个非异步函数，其函数体是一个异步块。异步函数的返回类型是编译器为该异步块创建的匿名数据类型的类型。</p>
<p data-x-en="Thus, writing async fn is equivalent to writing a function which returns a future of the return type. When the compiler sees a function definition such as the async fn page_title in Listing 17-1, it’s equivalent to a non-async function defined like this:">因此，编写 <code>async fn</code> 相当于编写一个返回 <em>未来</em> 类型的函数。当编译器看到如清单 17-1 中的 <code>async fn page_title</code> 这样的函数定义时，它相当于一个定义如下所示的非异步函数：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // required for mdbook test
</span>use std::future::Future;
use trpl::Html;

fn page_title(url: &amp;str) -&gt; impl Future&lt;Output = Option&lt;String&gt;&gt; + '_ {
    async move {
        let text = trpl::get(url).await.text().await;
        Html::parse(&amp;text)
            .select_first("title")
            .map(|title| title.inner_html())
    }
}
<span class="boring">}</span></code></pre></pre>
<p data-x-en="Let’s walk through each part of the transformed version:">让我们逐一解析转换后的每个部分：</p>
<ul>
<li>It uses the <code>impl Trait</code> syntax we discussed back in the <a href="ch10-02-traits.html#traits-as-parameters">“Traits as
Parameters”</a> section in Chapter 10.</li>
<li>The returned trait is a <code>Future</code>, with an associated type of <code>Output</code>. Notice
that the <code>Output</code> type is <code>Option&lt;String&gt;</code>, which is the same as the the
original return type from the <code>async fn</code> version of <code>page_title</code>.</li>
<li>All of the code called in the body of the original function is wrapped in an
<code>async move</code> block. Remember that blocks are expressions. This whole block is
the expression returned from the function.</li>
<li>This async block produces a value with the type <code>Option&lt;String&gt;</code>, as described
above. That value matches the <code>Output</code> type in the return type. This is just
like other blocks you have seen.</li>
<li>The new function body is an <code>async move</code> block because of how it uses the
<code>url</code> parameter. (We’ll talk about <code>async</code> vs. <code>async move</code> much more later
in the chapter.)</li>
<li>The new version of the function has a kind of lifetime we haven’t seen before
in the output type: <code>'_</code>. Because the function returns a <code>Future</code> which refers
to a reference—in this case, the reference from the <code>url</code> parameter—we need to
tell Rust that we mean for that reference to be included. We don’t have to
name the lifetime here, because Rust is smart enough to know there is only one
reference which could be involved, but we <em>do</em> have to be explicit that the
resulting <code>Future</code> is bound by that lifetime.</li>
</ul>
<p data-x-en="Now we can call page_title in main. To start, we’ll just get the title for a single page. In Listing 17-3, we follow the same pattern we used for getting command line arguments back in Chapter 12. Then we pass the first URL page_title, and await the result. Because the value produced by the future is an Option<String>, we use a match expression to print different messages to account for whether the page had a <title>.">现在我们可以在 <code>main</code> 中调用 <code>page_title</code>。首先，我们只获取单个页面的标题。在清单 17-3 中，我们遵循了第 12 章中用于获取命令行参数的相同模式。然后我们将第一个 URL 传递给 <code>page_title</code>，并等待结果。因为未来产生的值是一个 <code>Option&lt;String&gt;</code>，我们使用一个 <code>match</code> 表达式来打印不同的消息，以考虑页面是否有 <code>&lt;title&gt;</code>。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>async fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();
    let url = &amp;args[1];
    match page_title(url).await {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-3: Calling the <code>page_title</code> function from <code>main</code> with a user-supplied argument</figcaption>
</figure>
<p data-x-en="Unfortunately, this doesn’t compile. The only place we can use the await keyword is in async functions or blocks, and Rust won’t let us mark the special main function as async.">不幸的是，这无法编译。我们只能在异步函数或块中使用<code>await</code>关键字，而 Rust 不允许我们将特殊的<code>main</code>函数标记为<code>async</code>。</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-03
cargo build
copy just the compiler error
-->
<pre><code class="language-text">error[E0752]: `main` function is not allowed to be `async`
 --&gt; src/main.rs:6:1
  |
6 | async fn main() {
  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`
</code></pre>
<p data-x-en="The reason main can’t be marked async is that async code needs a runtime: a Rust crate which manages the details of executing asynchronous code. A program’s main function can initialize a runtime, but it’s not a runtime itself. (We’ll see more about why this is a bit later.) Every Rust program that executes async code has at least one place where it sets up a runtime and executes the futures."><code>main</code> 不能被标记为 <code>async</code> 的原因是异步代码需要一个 <em>运行时</em>：一个管理异步代码执行细节的 Rust 库。程序的 <code>main</code> 函数可以 <em>初始化</em> 一个运行时，但它本身并不是一个运行时。（我们稍后会详细讨论为什么这一点很重要。）每个执行异步代码的 Rust 程序至少有一个地方会设置运行时并执行未来的任务。</p>
<p data-x-en="Most languages which support async bundle a runtime with the language. Rust does not. Instead, there are many different async runtimes available, each of which makes different tradeoffs suitable to the use case they target. For example, a high-throughput web server with many CPU cores and a large amount of RAM has very different needs than a microcontroller with a single core, a small amount of RAM, and no ability to do heap allocations. The crates which provide those runtimes also often supply async versions of common functionality such as file or network I/O.">大多数支持异步的语言都会捆绑一个运行时。Rust 并没有这样做。相反，有许多不同的异步运行时可供选择，每个运行时都针对其目标用例做出了不同的权衡。例如，具有多个 CPU 核心和大量 RAM 的高吞吐量 Web 服务器与只有一个核心、少量 RAM 且无法进行堆分配的微控制器的需求非常不同。提供这些运行时的 crate 通常还会提供异步版本的常见功能，如文件或网络 I/O。</p>
<p data-x-en="Here, and throughout the rest of this chapter, we’ll use the run function from the trpl crate, which takes a future as an argument and runs it to completion. Behind the scenes, calling run sets up a runtime to use to run the future passed in. Once the future completes, run returns whatever value the future produced.">在这里，以及在本章的其余部分，我们将使用来自 <code>trpl</code> crate 的 <code>run</code> 函数，该函数接受一个 future 作为参数并运行到完成。在幕后，调用 <code>run</code> 会设置一个运行时来运行传入的 future。一旦 future 完成，<code>run</code> 将返回 future 产生的值。</p>
<p data-x-en="We could pass the future returned by page_title directly to run. Once it completed, we would be able to match on the resulting Option<String>, the way we tried to do in Listing 17-3. However, for most of the examples in the chapter (and most async code in the real world!), we’ll be doing more than just one async function call, so instead we’ll pass an async block and explicitly await the result of calling page_title, as in Listing 17-4.">我们可以直接将 <code>page_title</code> 返回的 future 传递给 <code>run</code>。一旦它完成，我们就可以像在清单 17-3 中尝试的那样匹配返回的 <code>Option&lt;String&gt;</code>。然而，对于本章中的大多数示例（以及现实世界中的大多数异步代码！），我们将不仅仅调用一个异步函数，因此我们将传递一个 <code>async</code> 块，并显式等待调用 <code>page_title</code> 的结果，如清单 17-4 所示。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<!-- should_panic,noplayground because mdbook test does not pass args -->
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let url = &amp;args[1];
        match page_title(url).await {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
    })
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 17-4: Awaiting an async block with <code>trpl::run</code></figcaption>
</figure>
<p data-x-en="When we run this, we get the behavior we might have expected initially:">当我们运行这个时，我们得到了最初可能预期的行为：</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-04
cargo build # skip all the build noise
cargo run https://www.rust-lang.org
# copy the output here
-->
<pre><code class="language-console">$ cargo run -- https://www.rust-lang.org
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/async_await 'https://www.rust-lang.org'`
The title for https://www.rust-lang.org was
            Rust Programming Language
</code></pre>
<p data-x-en="Phew: we finally have some working async code! This now compiles, and we can run it. Before we add code to race two sites against each other, let’s briefly turn our attention back to how futures work.">Phew: 我们终于有一些可以工作的异步代码了！这现在可以编译，我们可以运行它。在我们添加代码来竞速两个站点之前，让我们简要回顾一下未来的运作方式。</p>
<p data-x-en="Each await point—that is, every place where the code uses the await keyword—represents a place where control gets handed back to the runtime. To make that work, Rust needs to keep track of the state involved in the async block, so that the runtime can kick off some other work and then come back when it’s ready to try advancing this one again. This is an invisible state machine, as if you wrote an enum in this way to save the current state at each await point:">每个 <em>await 点</em>——也就是说，代码中每个使用 <code>await</code> 关键字的地方——都表示一个将控制权交还给运行时的地方。为了使这一点生效，Rust 需要跟踪异步块中涉及的状态，以便运行时可以启动其他工作，然后在准备好再次尝试推进这个任务时返回。这就像你以这种方式编写一个枚举来在每个 <code>await</code> 点保存当前状态的不可见状态机：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>enum PageTitleFuture&lt;'a&gt; {
    Initial { url: &amp;'a str },
    GetAwaitPoint { url: &amp;'a str },
    TextAwaitPoint { response: trpl::Response },
}
<span class="boring">}</span></code></pre></pre>
<p data-x-en="Writing the code to transition between each state by hand would be tedious and error-prone, especially when adding more functionality and more states to the code later. Instead, the Rust compiler creates and manages the state machine data structures for async code automatically. If you’re wondering: yep, the normal borrowing and ownership rules around data structures all apply. Happily, the compiler also handles checking those for us, and has good error messages. We’ll work through a few of those later in the chapter!">手动编写在每个状态之间转换的代码会很繁琐且容易出错，尤其是在稍后向代码中添加更多功能和更多状态时。相反，Rust 编译器会自动创建和管理异步代码的状态机数据结构。如果你在想：是的，围绕数据结构的正常借用和所有权规则都适用。幸运的是，编译器还会为我们检查这些规则，并且有很好的错误消息。我们将在本章后面详细讨论其中的一些内容！</p>
<p data-x-en="Ultimately, something has to execute that state machine. That something is a runtime. (This is why you may sometimes come across references to executors when looking into runtimes: an executor is the part of a runtime responsible for executing the async code.)">最终，必须有东西来执行这个状态机。这个东西就是运行时。(这就是为什么在研究运行时时，你有时会遇到<em>执行器</em>的引用：执行器是运行时中负责执行异步代码的部分。)</p>
<p data-x-en="Now we can understand why the compiler stopped us from making main itself an async function back in Listing 17-3. If main were an async function, something else would need to manage the state machine for whatever future main returned, but main is the starting point for the program! Instead, we call the trpl::run function in main, which sets up a runtime and runs the future returned by the async block until it returns Ready.">现在我们可以理解为什么编译器在第 17-3 节中阻止我们将 <code>main</code> 本身设为异步函数。如果 <code>main</code> 是一个异步函数，那么就需要有其他东西来管理 <code>main</code> 返回的未来状态机，但 <code>main</code> 是程序的起点！相反，我们在 <code>main</code> 中调用 <code>trpl::run</code> 函数，它设置了一个运行时并运行由 <code>async</code> 块返回的未来，直到它返回 <code>Ready</code>。</p>
<section class="note" aria-role="note">
<p data-x-en="Note: some runtimes provide macros to make it so you can write an async main function. Those macros rewrite async fn main() { ... } to be a normal fn main which does the same thing we did by hand in Listing 17-5: call a function which runs a future to completion the way trpl::run does.">注意：某些运行时提供宏，使你<em>可以</em>编写一个异步的 main 函数。这些宏会将 <code>async fn main() { ... }</code> 重写为一个普通的 <code>fn main</code>，它所做的与我们在清单 17-5 中手动所做的相同：调用一个运行未来直到完成的函数，就像 <code>trpl::run</code> 那样。</p>
</section>
<p data-x-en="Let’s put these pieces together and see how we can write concurrent code, by calling page_title with two different URLs passed in from the command line and racing them.">让我们把这些部分放在一起，看看我们如何通过调用<code>page_title</code>并从命令行传入两个不同的URL来编写并发代码，并进行竞速。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<!-- should_panic,noplayground because mdbook does not pass args -->
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::{Either, Html};

fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let title_fut_1 = page_title(&amp;args[1]);
        let title_fut_2 = page_title(&amp;args[2]);

        let (url, maybe_title) =
            match trpl::race(title_fut_1, title_fut_2).await {
                Either::Left(left) =&gt; left,
                Either::Right(right) =&gt; right,
            };

        println!("{url} returned first");
        match maybe_title {
            Some(title) =&gt; println!("Its page title is: '{title}'"),
            None =&gt; println!("Its title could not be parsed."),
        }
    })
}

async fn page_title(url: &amp;str) -&gt; (&amp;str, Option&lt;String&gt;) {
    let text = trpl::get(url).await.text().await;
    let title = Html::parse(&amp;text)
        .select_first("title")
        .map(|title| title.inner_html());
    (url, title)
}</code></pre>
<figcaption>Listing 17-5: </figcaption>
</figure>
<p data-x-en="In Listing 17-5, we begin by calling page_title for each of the user-supplied URLs. We save the futures produced by calling page_title as title_fut_1 and title_fut_2. Remember, these don’t do anything yet, because futures are lazy, and we haven’t yet awaited them. Then we pass the futures to trpl::race, which returns a value to indicate which of the futures passed to it finishes first.">在清单 17-5 中，我们首先为每个用户提供的 URL 调用 <code>page_title</code>。我们将调用 <code>page_title</code> 产生的未来值保存为 <code>title_fut_1</code> 和 <code>title_fut_2</code>。记住，这些还不会做任何事情，因为未来值是惰性的，我们还没有等待它们。然后我们将未来值传递给 <code>trpl::race</code>，它返回一个值来指示传递给它的未来值中哪一个先完成。</p>
<section class="note" aria-role="note">
<p data-x-en="Note: Under the hood, race is built on a more general function, select, which you will encounter more often in real-world Rust code. A select function can do a lot of things that trpl::race function can’t, but it also has some additional complexity that we can skip over for now.">注意：在底层，<code>race</code> 是基于一个更通用的函数 <code>select</code> 构建的，
在实际的 Rust 代码中，你将更频繁地遇到 <code>select</code>。
<code>select</code> 函数可以做很多 <code>trpl::race</code> 函数做不到的事情，但它也
有一些我们目前可以忽略的额外复杂性。</p>
</section>
<p data-x-en="Either future can legitimately “win,” so it doesn’t make sense to return a Result. Instead, race returns a type we haven’t seen before, trpl::Either. The Either type is somewhat similar to a Result, in that it has two cases. Unlike Result, though, there is no notion of success or failure baked into Either. Instead, it uses Left and Right to indicate “one or the other”.">任一 future 都可以合法地“获胜”，因此返回一个 <code>Result</code> 没有意义。相反，<code>race</code> 返回一个我们之前未见过的类型，<code>trpl::Either</code>。<code>Either</code> 类型在某种程度上类似于 <code>Result</code>，因为它也有两种情况。然而，<code>Either</code> 并没有像 <code>Result</code> 那样内置成功或失败的概念。相反，它使用 <code>Left</code> 和 <code>Right</code> 来表示“其中之一”。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Either&lt;A, B&gt; {
    Left(A),
    Right(B),
}
<span class="boring">}</span></code></pre></pre>
<p data-x-en="The race function returns Left if the first argument finishes first, with that future’s output, and Right with the second future argument’s output if that one finishes first. This matches the order the arguments appear when calling the function: the first argument is to the left of the second argument."><code>race</code> 函数如果第一个参数先完成，则返回 <code>Left</code>，并带有该未来的输出；如果 <em>那个</em> 一个先完成，则返回带有第二个未来参数输出的 <code>Right</code>。这与调用函数时参数出现的顺序相匹配：第一个参数位于第二个参数的左侧。</p>
<p data-x-en="We also update page_title to return the same URL passed in. That way, if the page which returns first does not have a <title> we can resolve, we can still print a meaningful message. With that information available, we wrap up by updating our println! output to indicate both which URL finished first and what the <title> was for the web page at that URL, if any.">我们还更新了<code>page_title</code>以返回相同的URL。这样，如果首先返回的页面没有我们可以解析的<code>&lt;title&gt;</code>，我们仍然可以打印一条有意义的消息。有了这些信息，我们最后更新<code>println!</code>输出，以指示哪个URL首先完成以及该URL的网页的<code>&lt;title&gt;</code>是什么，如果有的话。</p>
<p data-x-en="You have built a small working web scraper now! Pick a couple URLs and run the command line tool. You may discover that some sites are reliably faster than others, while in other cases which site “wins” varies from run to run. More importantly, you’ve learned the basics of working with futures, so we can now dig into even more of the things we can do with async.">你现在已经构建了一个小型的可工作的网络爬虫！选择几个URL并运行命令行工具。你可能会发现有些网站比其他网站更稳定地快，而在其他情况下，哪个网站“获胜”则会因运行而异。更重要的是，你已经学会了使用future的基础知识，因此我们现在可以深入探讨使用async可以做的更多事情。</p>
<!-- TODO: map source link version to version of Rust? -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-00-async-await.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-02-concurrency-with-async.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-00-async-await.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-02-concurrency-with-async.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    

</body></html>