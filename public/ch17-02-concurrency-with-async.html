<!DOCTYPE html><html lang="zh-CN" class="light sidebar-visible" dir="ltr"><head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>应用并发 - 异步 - 《Rust编程语言》</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    <meta name="title" content="Rust 中文"><meta property="og:title" content="Rust 中文"><meta name="description" content="Rust 中文文档"><meta property="og:description" content="Rust 中文文档"><meta name="url" content="https://rust.xheldon.com"><meta property="og:url" content="https://rust.xheldon.com"><script src="https://www.googletagmanager.com/gtag/js?id=G-V7NE1X37EX"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-V7NE1X37EX')</script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486286026923411"></script><style>/* hover 显示原文 */
p[data-x-en],
li[data-x-en] {
  position: relative;
}
p[data-x-en]:hover::after,
li[data-x-en]:hover::after {
  visibility: visible;
  opacity: 1;
}
p[data-x-en]::after,
li[data-x-en]::after {
  content: attr(data-x-en);
  display: block;
  font-size: 12px;
  transition: all 0.2s 0.3s;
  visibility: hidden;
  opacity: 0;
  background: var(--searchbar-bg);
  z-index: 99;
  border-radius: 4px;
  padding: 5px 10px;
  position: absolute;
  top: 100%;
  left: 0;
}
/* 译者注释内容 */
div[type='comment'] {
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  background: #eee;
}
div[type='comment']::before {
  content: '译者注: ';
  font-weight: 900;
}
header a.logo {
  position: relative;
}
header a.logo::after {
  content: '中文';
  position: absolute;
  left: calc(100% + 5px);
  font-size: 12px;
  width: 50px;
  top: -5px;
}
#banner-info {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  font-size: 12px;
  padding: 0;
  z-index: 999;
}
#add-info {
  font-size: 14px;
}
blockquote {
  border-left: 5px solid #ccc;
  padding-left: 10px;
  margin-left: 0;
}
.content {
  overflow-y: unset !important;
}
</style></head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky"><div id="banner-info">本文档为 AI + 人工翻译，hover 可以显示原文。当前页翻译有问题？<a style="cursor: pointer;" href="https://github.com/Xheldon/rust-book-cn/blob/main/dict/ch17-02-concurrency-with-async.json" target="_blank">我来翻译！</a></div>
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    <a href="https://github.com/Xheldon/rust-book-cn" target="_blank"><i class="fa fa-language"></i></a><a href="https://www.xheldon.com" target="_blank"><i class="fa fa-id-card"></i></a></div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="applying-concurrency-with-async"><a class="header" href="#applying-concurrency-with-async">使用异步应用并发</a></h2>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="concurrency-with-async"></a></p>
<p data-x-en="In this section, we’ll apply async to some of the same concurrency challenges we tackled with threads in chapter 16. Because we already talked about a lot of the key ideas there, in this section we’ll focus on what’s different between threads and futures.">在本节中，我们将把异步应用到我们在第16章用线程解决的一些相同的并发挑战上。因为我们已经在那讨论了很多关键概念，所以在本节中我们将重点关注线程和未来的不同之处。</p>
<p data-x-en="In many cases, the APIs for working with concurrency using async are very similar to those for using threads. In other cases, they end up being quite different. Even when the APIs look similar between threads and async, they often have different behavior—and they nearly always have different performance characteristics.">在许多情况下，使用 async 进行并发操作的 API 与使用线程的 API 非常相似。在其他情况下，它们最终会变得相当不同。即使线程和 async 之间的 API <em>看起来</em>相似，它们通常也有不同的行为——而且它们几乎总是有不同的性能特征。</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="counting"></a></p>
<h3 id="creating-a-new-task-with-spawn_task"><a class="header" href="#creating-a-new-task-with-spawn_task">使用<code>spawn_task</code>创建新任务</a></h3>
<p data-x-en="The first operation we tackled in Creating a New Thread with Spawn was counting up on two separate threads. Let’s do the same using async. The trpl crate supplies a spawn_task function that looks very similar to the thread::spawn API, and a sleep function that is an async version of the thread::sleep API. We can use these together to implement the counting example, as shown in Listing 17-6.">我们在<a href="ch16-01-threads.html#creating-a-new-thread-with-spawn">使用spawn创建新线程</a><!-- ignore -->中处理的第一个操作是在两个独立的线程上进行计数。
让我们使用async来做同样的事情。<code>trpl</code>库提供了一个<code>spawn_task</code>函数
它看起来非常类似于<code>thread::spawn</code> API，以及一个<code>sleep</code>函数
这是<code>thread::sleep</code> API的异步版本。我们可以将这些一起使用
来实现计数示例，如列表17-6所示。</p>
<figure class="listing" id="listing-17-6">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::time::Duration;

fn main() {
    trpl::run(async {
        trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }
    });
}</code></pre></pre>
<figcaption><a href="#listing-17-6">Listing 17-6</a>: Creating a new task to print one thing while the main task prints something else</figcaption>
</figure>
<p data-x-en="As our starting point, we set up our main function with trpl::run so that our top-level function can be async.">作为起点，我们使用 <code>trpl::run</code> 设置我们的 <code>main</code> 函数，以便我们的顶级函数可以是异步的。</p>
<section class="note" aria-role="note">
<p data-x-en="Note: From this point forward in the chapter, every example will include this exact same wrapping code with trpl::run in main, so we’ll often skip it just as we do with main. Don’t forget to include it in your code!">注意：从本章的这一点开始，每个示例都将包含这个完全相同的包装代码，在<code>main</code>中使用<code>trpl::run</code>，因此我们通常会跳过它，就像我们对<code>main</code>所做的那样。不要忘记在你的代码中包含它！</p>
</section>
<p data-x-en="Then we write two loops within that block, each containing a trpl::sleep call, which waits for half a second (500 milliseconds) before sending the next message. We put one loop in the body of a trpl::spawn_task and the other in a top-level for loop. We also add an await after the sleep calls.">然后我们在该块中编写两个循环，每个循环都包含一个 <code>trpl::sleep</code> 调用，等待半秒（500毫秒）后发送下一条消息。我们将一个循环放在 <code>trpl::spawn_task</code> 的主体中，另一个放在顶级 <code>for</code> 循环中。我们还在 <code>sleep</code> 调用后添加了一个 <code>await</code>。</p>
<p data-x-en="This code behaves similarly to the thread-based implementation—including the fact that you may see the messages appear in a different order in your own terminal when you run it:">这段代码的行为与基于线程的实现类似——包括当你运行它时，可能会在你自己的终端中看到消息以不同的顺序出现：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
</code></pre>
<p data-x-en="This version stops as soon as the for loop in the body of the main async block finishes, because the task spawned by spawn_task is shut down when the main function ends. If you want it to run all the way to the task’s completion, you will need to use a join handle to wait for the first task to complete. With threads, we used the join method to “block” until the thread was done running. In Listing 17-7, we can use await to do the same thing, because the task handle itself is a future. Its Output type is a Result, so we also unwrap it after awaiting it.">这个版本会在主异步块体中的 <code>for</code> 循环结束时停止，因为由 <code>spawn_task</code> 启动的任务在 <code>main</code> 函数结束时会被关闭。如果你想让它一直运行到任务完成，你需要使用一个 join 句柄来等待第一个任务完成。对于线程，我们使用 <code>join</code> 方法来“阻塞”直到线程运行完毕。在示例 17-7 中，我们可以使用 <code>await</code> 来做同样的事情，因为任务句柄本身就是一个未来。它的 <code>Output</code> 类型是一个 <code>Result</code>，所以在等待它之后我们还需要解开它。</p>
<figure class="listing" id="listing-17-7">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }

        handle.await.unwrap();
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-7">Listing 17-7</a>: Using <code>await</code> with a join handle to run a task to completion</figcaption>
</figure>
<p data-x-en="This updated version runs until both loops finish.">这个更新的版本运行直到<em>两个</em>循环都完成。</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p data-x-en="So far, it looks like async and threads give us the same basic outcomes, just with different syntax: using await instead of calling join on the join handle, and awaiting the sleep calls.">到目前为止，看起来异步和线程给我们提供了相同的基本结果，只是语法不同：使用<code>await</code>而不是在连接句柄上调用<code>join</code>，以及等待<code>sleep</code>调用。</p>
<p data-x-en="The bigger difference is that we didn’t need to spawn another operating system thread to do this. In fact, we don’t even need to spawn a task here. Because async blocks compile to anonymous futures, we can put each loop in an async block and have the runtime run them both to completion using the trpl::join function.">更大的不同在于我们不需要为此启动另一个操作系统线程。事实上，我们甚至不需要在这里启动一个任务。因为异步块编译为匿名未来，我们可以将每个循环放在一个异步块中，并使用<code>trpl::join</code>函数让运行时完成它们的执行。</p>
<p data-x-en="In the section Waiting for All Threads to Finishing Using join Handles, we showed how to use the join method on the JoinHandle type returned when you call std::thread::spawn. The trpl::join function is similar, but for futures. When you give it two futures, it produces a single new future whose output is a tuple containing the output of each future you passed in once they both complete. Thus, in Listing 17-8, we use trpl::join to wait for both fut1 and fut2 to finish. We do not await fut1 and fut2 but instead the new future produced by trpl::join. We ignore the output, because it’s just a tuple containing two unit values.">在章节 <a href="ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-handles">使用 <code>join</code> 句柄等待所有线程完成</a><!-- ignore --> 中，我们展示了如何在调用 <code>std::thread::spawn</code> 时返回的 <code>JoinHandle</code> 类型上使用 <code>join</code> 方法。<code>trpl::join</code> 函数类似，但用于未来值。当你给它两个未来值时，它会产生一个新的未来值，其输出是一个包含你传入的每个未来值输出的元组，一旦它们 <em>都</em> 完成。因此，在清单 17-8 中，我们使用 <code>trpl::join</code> 等待 <code>fut1</code> 和 <code>fut2</code> 都完成。我们 <em>不</em> 等待 <code>fut1</code> 和 <code>fut2</code>，而是等待由 <code>trpl::join</code> 产生的新未来值。我们忽略输出，因为这只是包含两个单元值的元组。</p>
<figure class="listing" id="listing-17-8">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let fut1 = async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let fut2 = async {
            for i in 1..5 {
                println!("hi number {i} from the second task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        trpl::join(fut1, fut2).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-8">Listing 17-8</a>: Using <code>trpl::join</code> to await two anonymous futures</figcaption>
</figure>
<p data-x-en="When we run this, we see both futures run to completion:">当我们运行这个时，我们看到两个未来都运行到了完成：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the first task!
hi number 1 from the second task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p data-x-en="Now, you’ll see the exact same order every time, which is very different from what we saw with threads. That is because the trpl::join function is fair, meaning it checks each future equally often, alternating between them, and never lets one race ahead if the other is ready. With threads, the operating system decides which thread to check and how long to let it run. With async Rust, the runtime decides which task to check. (In practice, the details get complicated because an async runtime might use operating system threads under the hood as part of how it manages concurrency, so guaranteeing fairness can be more work for a runtime—but it’s still possible!) Runtimes don’t have to guarantee fairness for any given operation, and they often offer different APIs to let you choose whether or not you want fairness.">现在，您每次都会看到完全相同的顺序，这与我们使用线程时看到的情况非常不同。这是因为 <code>trpl::join</code> 函数是 <em>公平的</em>，意味着它会同样频繁地检查每个未来，交替进行，而不会让一个在未来准备好时领先。对于线程，操作系统决定检查哪个线程以及让它运行多长时间。对于异步 Rust，运行时决定检查哪个任务。（实际上，细节会变得复杂，因为异步运行时可能在底层使用操作系统线程作为管理并发的一部分，因此保证公平性对运行时来说可能更复杂——但仍然是可能的！）运行时不必为任何给定操作保证公平性，它们通常提供不同的 API 让您选择是否需要公平性。</p>
<p data-x-en="Try some of these variations on awaiting the futures and see what they do:">尝试这些关于等待未来的变体，看看它们的作用：</p>
<ul>
<li data-x-en="Remove the async block from around either or both of the loops.">移除围绕任一或两个循环的 async 块。</li>
<li data-x-en="Await each async block immediately after defining it.">在定义每个异步块后立即等待。</li>
<li data-x-en="Wrap only the first loop in an async block, and await the resulting future after the body of second loop.">仅将第一个循环包装在异步块中，并在第二个循环的主体之后等待生成的未来。</li>
</ul>
<p data-x-en="For an extra challenge, see if you can figure out what the output will be in each case before running the code!">为了增加挑战性，看看你是否能在<em>运行代码之前</em>弄清楚每种情况下的输出！</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="message-passing"></a></p>
<h3 id="counting-up-on-two-tasks-using-message-passing"><a class="header" href="#counting-up-on-two-tasks-using-message-passing">使用消息传递在两个任务上计数</a></h3>
<p data-x-en="Sharing data between futures will also be familiar: we’ll use message passing again, but this time with async versions of the types and functions. We’ll take a slightly different path than we did in Using Message Passing to Transfer Data Between Threads to illustrate some of the key differences between thread-based and futures-based concurrency. In Listing 17-9, we’ll begin with just a single async block—not spawning a separate task as we spawned a separate thread.">在 futures 之间共享数据也会很熟悉：我们将再次使用消息传递，但这次使用异步版本的类型和函数。我们将采取与<a href="ch16-02-message-passing.html">使用消息传递在线程之间传输数据</a>中稍有不同的路径，以说明基于线程的并发和基于 futures 的并发之间的一些关键差异。在示例 17-9 中，我们将从一个单一的 async 块开始——<em>不</em>像我们之前创建单独的线程那样创建单独的任务。</p>
<figure class="listing" id="listing-17-9">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let val = String::from("hi");
        tx.send(val).unwrap();

        let received = rx.recv().await.unwrap();
        println!("received '{received}'");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-9">Listing 17-9</a>: Creating an async channel and assigning the two halves to <code>tx</code> and <code>rx</code></figcaption>
</figure>
<p data-x-en="Here, we use trpl::channel, an async version of the multiple-producer, single-consumer channel API we used with threads back in Chapter 16. The async version of the API is only a little different from the thread-based version: it uses a mutable rather than an immutable receiver rx, and its recv method produces a future we need to await rather than producing the value directly. Now we can send messages from the sender to the receiver. Notice that we don’t have to spawn a separate thread or even a task; we merely need to await the rx.recv call.">这里，我们使用<code>trpl::channel</code>，这是我们在第16章使用线程时使用的多生产者、单消费者通道API的异步版本。异步版本的API与基于线程的版本只有 slight 不同：它使用可变而非不可变的接收者<code>rx</code>，并且其<code>recv</code>方法生成一个我们需要等待的 future，而不是直接生成值。现在我们可以从发送者向接收者发送消息。请注意，我们不需要启动一个单独的线程甚至任务；我们只需要等待<code>rx.recv</code>调用。</p>
<p data-x-en="The synchronous Receiver::recv method in std::mpsc::channel blocks until it receives a message. The trpl::Receiver::recv method does not, because it is async. Instead of blocking, it hands control back to the runtime until either a message is received or the send side of the channel closes. By contrast, we don’t await the send call, because it doesn’t block. It doesn’t need to, because the channel we’re sending it into is unbounded."><code>std::mpsc::channel</code> 中的同步 <code>Receiver::recv</code> 方法会阻塞，直到收到消息。而 <code>trpl::Receiver::recv</code> 方法不会阻塞，因为它是一个异步方法。它不会阻塞，而是将控制权交还给运行时，直到收到消息或通道的发送端关闭。相比之下，我们不会等待 <code>send</code> 调用，因为它不会阻塞。它不需要阻塞，因为我们发送到的通道是无界的。</p>
<section class="note" aria-role="note">
<p data-x-en="Note: Because all of this async code runs in an async block in a trpl::run call, everything within it can avoid blocking. However, the code outside it will block on the run function returning. That’s the whole point of the trpl::run function: it lets you choose where to block on some set of async code, and thus where to transition between sync and async code. In most async runtimes, run is actually named block_on for exactly this reason.">注意：因为所有这些异步代码都在 <code>trpl::run</code> 调用中的异步块中运行，所以其中的所有内容都可以避免阻塞。然而，<em>外部</em>的代码将在 <code>run</code> 函数返回时阻塞。这就是 <code>trpl::run</code> 函数的全部意义：它让你可以<em>选择</em>在何处阻塞一组异步代码，从而在同步和异步代码之间进行转换。在大多数异步运行时中，<code>run</code> 实际上被命名为 <code>block_on</code>，原因正是如此。</p>
</section>
<p data-x-en="Notice two things about this example. First, the message will arrive right away. Second, although we use a future here, there’s no concurrency yet. Everything in the listing happens in sequence, just as it would if there were no futures involved.">注意这个例子的两个方面。首先，消息会立即到达。
其次，虽然我们在这里使用了 future，但还没有并发。列表中的所有内容都是按顺序发生的，就像没有涉及 future 一样。</p>
<p data-x-en="Let’s address the first part by sending a series of messages and sleeping in between them, as shown in Listing 17-10.">让我们先处理第一部分，通过发送一系列消息并在它们之间休眠，如清单 17-10 所示。</p>
<!-- We cannot test this one because it never stops! -->
<figure class="listing" id="listing-17-10">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("future"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            trpl::sleep(Duration::from_millis(500)).await;
        }

        while let Some(value) = rx.recv().await {
            println!("received '{value}'");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-17-10">Listing 17-10</a>: Sending and receiving multiple messages over the async channel and sleeping with an <code>await</code> between each message</figcaption>
</figure>
<p data-x-en="In addition to sending the messages, we need to receive them. In this case, because we know how many messages are coming in, we could do that manually by calling rx.recv().await four times. In the real world, though, we’ll generally be waiting on some unknown number of messages, so we need to keep waiting until we determine that there are no more messages.">除了发送消息外，我们还需要接收它们。在这种情况下，
因为我们知道有多少消息传入，我们可以通过手动调用<code>rx.recv().await</code>四次来实现。然而，在现实世界中，我们通常会等待一些<em>未知</em>数量的消息，所以我们需要一直等待，直到确定没有更多消息。</p>
<p data-x-en="In Listing 16-10, we used a for loop to process all the items received from a synchronous channel. Rust doesn’t yet have a way to write a for loop over an asynchronous series of items, however, so we need to use a loop we haven’t seen before: the while let conditional loop. This is the loop version of the if let construct we saw back in the section Concise Control Flow with if let and let else. The loop will continue executing as long as the pattern it specifies continues to match the value.">在清单 16-10 中，我们使用了一个 <code>for</code> 循环来处理从同步通道接收到的所有项。然而，Rust 尚未提供一种方法来编写一个 <code>for</code> 循环来处理 <em>异步</em> 的一系列项，因此我们需要使用一个我们之前未见过的循环：<code>while let</code> 条件循环。这是我们在 <a href="ch06-03-if-let.html">使用 <code>if let</code> 和 <code>let else</code> 简化控制流</a><!-- ignore --> 部分中看到的 <code>if let</code> 构造的循环版本。只要循环指定的模式继续匹配值，循环就会继续执行。</p>
<p data-x-en="The rx.recv call produces a future, which we await. The runtime will pause the future until it is ready. Once a message arrives, the future will resolve to Some(message) as many times as a message arrives. When the channel closes, regardless of whether any messages have arrived, the future will instead resolve to None to indicate that there are no more values and thus we should stop polling—that is, stop awaiting."><code>rx.recv</code> 调用生成一个未来，我们等待它。运行时会暂停这个未来，直到它准备就绪。一旦消息到达，未来将解析为 <code>Some(message)</code>，每次消息到达都会如此。当通道关闭时，无论是否 <em>任何</em> 消息已到达，未来将解析为 <code>None</code>，以表示没有更多值，因此我们应该停止轮询——也就是说，停止等待。</p>
<p data-x-en="The while let loop pulls all of this together. If the result of calling rx.recv().await is Some(message), we get access to the message and we can use it in the loop body, just as we could with if let. If the result is None, the loop ends. Every time the loop completes, it hits the await point again, so the runtime pauses it again until another message arrives."><code>while let</code> 循环将所有这些内容整合在一起。如果调用 <code>rx.recv().await</code> 的结果是 <code>Some(message)</code>，我们可以访问消息并在循环体中使用它，就像使用 <code>if let</code> 一样。如果结果是 <code>None</code>，循环结束。每次循环完成时，它都会再次遇到 await 点，因此运行时会再次暂停，直到另一条消息到达。</p>
<p data-x-en="The code now successfully sends and receives all of the messages. Unfortunately, there are still a couple of problems. For one thing, the messages do not arrive at half-second intervals. They arrive all at once, 2 seconds (2,000 milliseconds) after we start the program. For another, this program never exits! Instead, it waits forever for new messages. You will need to shut it down using ctrl-c.">代码现在成功地发送和接收了所有的消息。不幸的是，仍然存在一些问题。首先，消息并不是每半秒到达一次。它们是在我们启动程序2秒（2,000毫秒）后一次性到达的。其次，这个程序永远不会退出！相反，它会永远等待新的消息。您需要使用<span class="keystroke">ctrl-c</span>来关闭它。</p>
<p data-x-en="Let’s start by examining why the messages come in all at once after the full delay, rather than coming in with delays between each one. Within a given async block, the order in which await keywords appear in the code is also the order in which they’re executed when the program runs.">让我们先来分析为什么消息会在完整的延迟后一次性到达，而不是每个消息之间有延迟。在给定的异步块中，<code>await</code> 关键字在代码中出现的顺序也是它们在程序运行时执行的顺序。</p>
<p data-x-en="There’s only one async block in Listing 17-10, so everything in it runs linearly. There’s still no concurrency. All the tx.send calls happen, interspersed with all of the trpl::sleep calls and their associated await points. Only then does the while let loop get to go through any of the await points on the recv calls.">在清单 17-10 中只有一个异步块，因此其中的所有内容都是线性运行的。仍然没有并发。所有的 <code>tx.send</code> 调用都会发生，穿插着所有的 <code>trpl::sleep</code> 调用及其相关的 await 点。只有这样，<code>while let</code> 循环才能通过任何 <code>recv</code> 调用的 <code>await</code> 点。</p>
<p data-x-en="To get the behavior we want, where the sleep delay happens between each message, we need to put the tx and rx operations in their own async blocks, as shown in Listing 17-11. Then the runtime can execute each of them separately using trpl::join, just as in the counting example. Once again, we await the result of calling trpl::join, not the individual futures. If we awaited the individual futures in sequence, we would just end up back in a sequential flow—exactly what we’re trying not to do.">为了获得我们想要的行为，即在每条消息之间发生睡眠延迟，
我们需要将<code>tx</code>和<code>rx</code>操作放在它们自己的异步块中，如清单17-11所示。然后运行时可以使用<code>trpl::join</code>分别执行每个操作，就像在计数示例中一样。同样，我们等待调用<code>trpl::join</code>的结果，而不是单独的未来。如果我们按顺序等待单独的未来，我们最终会回到顺序流程——这正是我们试图避免的。</p>
<!-- We cannot test this one because it never stops! -->
<figure class="listing" id="listing-17-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span>        let tx_fut = async {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-17-11">Listing 17-11</a>: Separating <code>send</code> and <code>recv</code> into their own <code>async</code> blocks and awaiting the futures for those blocks</figcaption>
</figure>
<p data-x-en="With the updated code in Listing 17-11, the messages get printed at 500-millisecond intervals, rather than all in a rush after 2 seconds.">随着列表 17-11 中更新的代码，消息以 500 毫秒的间隔打印，而不是在 2 秒后一口气全部打印。</p>
<p data-x-en="The program still never exits, though, because of the way the while let loop interacts with trpl::join:">程序仍然永远不会退出，因为 <code>while let</code> 循环与 <code>trpl::join</code> 的交互方式：</p>
<ul>
<li data-x-en="The future returned from trpl::join completes only once both futures passed to it have completed.">从 <code>trpl::join</code> 返回的 future 只有在传递给它的 <em>两个</em> future 都完成时才会完成。</li>
<li data-x-en="The tx future completes once it finishes sleeping after sending the last message in vals."><code>tx</code> 未来在发送 <code>vals</code> 中的最后一条消息后完成睡眠。</li>
<li data-x-en="The rx future won’t complete until the while let loop ends."><code>rx</code> 未来不会完成，直到 <code>while let</code> 循环结束。</li>
<li data-x-en="The while let loop won’t end until awaiting rx.recv produces None."><code>while let</code> 循环不会结束，直到等待 <code>rx.recv</code> 产生 <code>None</code>。</li>
<li data-x-en="Awaiting rx.recv will return None only once the other end of the channel is closed.">等待 <code>rx.recv</code> 仅在通道的另一端关闭时返回 <code>None</code>。</li>
<li data-x-en="The channel will close only if we call rx.close or when the sender side, tx, is dropped.">通道只有在我们调用<code>rx.close</code>或发送方<code>tx</code>被丢弃时才会关闭。</li>
<li data-x-en="We don’t call rx.close anywhere, and tx won’t be dropped until the outermost async block passed to trpl::run ends.">我们 nowhere 调用 <code>rx.close</code>，并且 <code>tx</code> 不会在传递给 <code>trpl::run</code> 的最外层异步块结束之前被丢弃。</li>
<li data-x-en="The block can’t end because it is blocked on trpl::join completing, which takes us back to the top of this list.">块无法结束，因为它被阻塞在 <code>trpl::join</code> 完成上，这又把我们带回到了这个列表的顶部。</li>
</ul>
<p data-x-en="We could manually close rx by calling rx.close somewhere, but that doesn’t make much sense. Stopping after handling some arbitrary number of messages would make the program shut down, but we could miss messages. We need some other way to make sure that tx gets dropped before the end of the function.">我们可以通过在某个地方调用<code>rx.close</code>来手动关闭<code>rx</code>，但这没有太大意义。在处理了一些任意数量的消息后停止会使程序关闭，但我们可能会错过消息。我们需要某种其他方法来确保<code>tx</code>在函数结束<em>之前</em>被丢弃。</p>
<p data-x-en="Right now, the async block where we send the messages only borrows tx because sending a message doesn’t require ownership, but if we could move tx into that async block, it would be dropped once that block ends. In the Chapter 13 section Capturing References or Moving Ownership, you learned how to use the move keyword with closures, and, as discussed in the Chapter 16 section Using move Closures with Threads, we often need to move data into closures when working with threads. The same basic dynamics apply to async blocks, so the move keyword works with async blocks just as it does with closures.">目前，我们发送消息的异步块只借用 <code>tx</code>，因为发送消息不需要所有权，但如果我们可以将 <code>tx</code> 移动到该异步块中，那么该块结束时 <code>tx</code> 就会被丢弃。在第 13 章的 <a href="ch13-01-closures.html#capturing-references-or-moving-ownership">捕获引用或移动所有权</a><!-- ignore --> 部分，你学习了如何在闭包中使用 <code>move</code> 关键字，正如在第 16 章的 <a href="ch16-01-threads.html#using-move-closures-with-threads">使用 <code>move</code> 闭包与线程</a><!-- ignore --> 部分所讨论的，我们在使用线程时通常需要将数据移动到闭包中。同样的基本动态也适用于异步块，因此 <code>move</code> 关键字在异步块中与在闭包中一样有效。</p>
<p data-x-en="In Listing 17-12, we change the block used to send messages from async to async move. When we run this version of the code, it shuts down gracefully after the last message is sent and received.">在清单 17-12 中，我们将用于发送消息的块从 <code>async</code> 更改为 <code>async move</code>。当我们运行 <em>此</em> 版本的代码时，它会在发送和接收最后一条消息后优雅地关闭。</p>
<figure class="listing" id="listing-17-12">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-12">Listing 17-12</a>: A  revision of the code from Listing 17-11 that correctly shuts down when complete</figcaption>
</figure>
<p data-x-en="This async channel is also a multiple-producer channel, so we can call clone on tx if we want to send messages from multiple futures, as shown in Listing 17-13.">这个异步通道也是一个多生产者通道，因此如果我们要从多个 future 发送消息，可以对 <code>tx</code> 调用 <code>clone</code>，如清单 17-13 所示。</p>
<figure class="listing" id="listing-17-13">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("more"),
                String::from("messages"),
                String::from("for"),
                String::from("you"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(1500)).await;
            }
        };

        trpl::join3(tx1_fut, tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption><a href="#listing-17-13">Listing 17-13</a>: Using multiple producers with async blocks</figcaption>
</figure>
<p data-x-en="First, we clone tx, creating tx1 outside the first async block. We move tx1 into that block just as we did before with tx. Then, later, we move the original tx into a new async block, where we send more messages on a slightly slower delay. We happen to put this new async block after the async block for receiving messages, but it could go before it just as well. The key is the order in which the futures are awaited, not in which they’re created.">首先，我们克隆 <code>tx</code>，在第一个异步块外部创建 <code>tx1</code>。我们将 <code>tx1</code> 移入该块，就像之前处理 <code>tx</code> 一样。然后，稍后，我们将原始的 <code>tx</code> 移入一个 <em>新的</em> 异步块，在那里我们以稍微慢一点的延迟发送更多消息。我们碰巧将这个新的异步块放在接收消息的异步块之后，但它也可以放在前面。关键在于这些未来的等待顺序，而不是它们的创建顺序。</p>
<p data-x-en="Both of the async blocks for sending messages need to be async move blocks so that both tx and tx1 get dropped when those blocks finish. Otherwise, we’ll end up back in the same infinite loop we started out in. Finally, we switch from trpl::join to trpl::join3 to handle the additional future.">两个用于发送消息的异步块都需要是 <code>async move</code> 块，以便在这些块结束时 <code>tx</code> 和 <code>tx1</code> 都能被丢弃。否则，我们最终会回到最初的那个无限循环中。最后，我们从 <code>trpl::join</code> 切换到 <code>trpl::join3</code> 以处理额外的未来。</p>
<p data-x-en="Now we see all the messages from both sending futures, and because the sending futures use slightly different delays after sending, the messages are also received at those different intervals.">现在我们可以看到来自两个发送未来的所有消息，因为发送未来在发送后使用了略有不同的延迟，所以消息也在这些不同的时间间隔内被接收。</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'the'
received 'messages'
received 'future'
received 'for'
received 'you'
</code></pre>
<p data-x-en="This is a good start, but it limits us to just a handful of futures: two with join, or three with join3. Let’s see how we might work with more futures.">这是一个好的开始，但它将我们限制在只有少数几个未来：两个使用<code>join</code>，或三个使用<code>join3</code>。让我们看看如何处理更多的未来。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-01-futures-and-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-03-more-futures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-01-futures-and-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-03-more-futures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    

</body></html>