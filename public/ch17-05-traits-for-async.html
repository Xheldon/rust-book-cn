<!DOCTYPE html><html lang="zh-CN" class="light sidebar-visible" dir="ltr"><head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Digging Into the Traits for Async - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    <script src="https://www.googletagmanager.com/gtag/js?id=G-V7NE1X37EX"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-V7NE1X37EX')</script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486286026923411"></script><style>/* hover 显示原文 */
p[data-x-en],
li[data-x-en] {
  position: relative;
}
p[data-x-en]:hover::after,
li[data-x-en]:hover::after {
  visibility: visible;
  opacity: 1;
}
p[data-x-en]::after,
li[data-x-en]::after {
  content: attr(data-x-en);
  display: block;
  font-size: 12px;
  transition: all 0.2s 0.3s;
  visibility: hidden;
  opacity: 0;
  background: #cccccc;
  z-index: 99;
  border-radius: 4px;
  padding: 5px 10px;
  position: absolute;
  top: 100%;
  left: 0;
}
/* 译者注释内容 */
div[type='comment'] {
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  background: #eee;
}
div[type='comment']::before {
  content: '译者注: ';
  font-weight: 900;
}
header a.logo {
  position: relative;
}
header a.logo::after {
  content: '中文';
  position: absolute;
  left: calc(100% + 5px);
  font-size: 12px;
  width: 50px;
  top: -5px;
}
#banner-info {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  background: rgba(255, 255, 255, 0.9);
  font-size: 12px;
  padding: 0;
  z-index: 999;
}
#add-info {
  font-size: 14px;
}
blockquote {
  border-left: 5px solid #ccc;
  padding-left: 10px;
  margin-left: 0;
}
</style></head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky"><div id="banner-info">本文档为 AI + 人工翻译，hover 可以显示原文。当前页翻译有问题？<a style="cursor: pointer;" href="https://github.com/Xheldon/rust-book-cn/blob/main/dict/ch17-05-traits-for-async.json" target="_blank">我来翻译！</a></div>
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    <a href="https://github.com/Xheldon/rust-book-cn" target="_blank"><i class="fa fa-language"></i></a><a href="https://www.xheldon.com" target="_blank"><i class="fa fa-id-card"></i></a></div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="digging-into-the-traits-for-async"><a class="header" href="#digging-into-the-traits-for-async">深入异步特性</a></h2>
<p data-x-en="Throughout the chapter, we’ve used the Future, Pin, Unpin, Stream, and StreamExt traits in various ways. So far, though, we’ve avoided digging too far into the details of how they work or how they fit together. Much of the time when writing Rust day to day, this is fine. Sometimes, though, you’ll hit situations where understanding a few more of these details matters. In this section, we’ll dig down enough further to help with those situations—while still leaving the really deep dive for other documentation!">在本章中，我们以各种方式使用了<code>Future</code>、<code>Pin</code>、<code>Unpin</code>、<code>Stream</code>和<code>StreamExt</code>特质。然而，到目前为止，我们还没有深入探讨它们的工作原理或它们是如何协同工作的。在日常编写Rust代码时，大多数情况下这样做是没问题的。但有时，您会遇到需要理解更多这些细节的情况。在本节中，我们将深入探讨<em>足够</em>多的细节以帮助处理这些情况——同时仍然将<em>真正</em>深入的内容留给其他文档！</p>
<h3 id="future"><a class="header" href="#future">未来</a></h3>
<p data-x-en="Back in Futures and the Async Syntax, we noted that Future is a trait. Let’s start by taking a closer look at how it works. Here is how Rust defines a Future:">在<a href="ch17-01-futures-and-syntax.html">Futures 和异步语法</a>中，我们提到<code>Future</code>
是一个特质。让我们先仔细看看它是如何工作的。以下是 Rust 如何定义<code>Future</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p data-x-en="That trait definition includes a bunch of new types and also some syntax we haven’t seen before, so let’s walk through the definition piece by piece.">那个特征定义包括了一堆新的类型还有一些我们之前没见过的语法，所以让我们一步步地解析这个定义。</p>
<p data-x-en="First, Future’s associated type Output says what the future resolves to. This is analogous to the Item associated type for the Iterator trait. Second, Future also has the poll method, which takes a special Pin reference for its self parameter and a mutable reference to a Context type, and returns a Poll<Self::Output>. We’ll talk a little more about Pin and Context later in the section. For now, let’s focus on what the method returns, the Poll type:">首先，<code>Future</code> 的关联类型 <code>Output</code> 说明了未来的解析结果。
这类似于 <code>Iterator</code> 特性中的 <code>Item</code> 关联类型。
其次，<code>Future</code> 还有一个 <code>poll</code> 方法，该方法接受一个特殊的 <code>Pin</code>
引用作为其 <code>self</code> 参数和一个可变的 <code>Context</code> 类型引用，
并返回一个 <code>Poll&lt;Self::Output&gt;</code>。我们将在本节稍后讨论 <code>Pin</code> 和
<code>Context</code>。现在，让我们先关注方法的返回值，
即 <code>Poll</code> 类型：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}</span></code></pre></pre>
<p data-x-en="This Poll type is similar to an Option: it has one variant which has a value (Ready(T)), and one which does not (Pending). It means something quite different, though! The Pending variant indicates that the future still has work to do, so the caller will need to check again later. The Ready variant indicates that the Future has finished its work and the T value is available.">这个 <code>Poll</code> 类型类似于 <code>Option</code>：它有一个包含值的变体 (<code>Ready(T)</code>)，和一个不包含值的变体 (<code>Pending</code>)。然而，它的含义却大不相同！<code>Pending</code> 变体表示该未来还有工作要做，因此调用者需要稍后再次检查。<code>Ready</code> 变体表示 <code>Future</code> 已完成其工作，并且 <code>T</code> 值可用。</p>
<section class="note" aria-role="note">
<p data-x-en="Note: With most futures, the caller should not call poll again after the future has returned Ready. Many futures will panic if polled again after becoming ready! Futures which are safe to poll again will say so explicitly in their documentation. This is similar to how Iterator::next behaves!">注意：对于大多数 future，调用者不应在 future 返回 <code>Ready</code> 后再次调用 <code>poll</code>。许多 future 在变为就绪状态后再次被轮询时会 panic！可以在文档中明确说明可以再次轮询的 future。这类似于 <code>Iterator::next</code> 的行为！</p>
</section>
<p data-x-en="Under the hood, when you see code which uses await, Rust compiles that to code which calls poll. If you look back at Listing 17-4, where we printed out the page title for a single URL once it resolved, Rust compiles it into something kind of (although not exactly) like this:">在内部，当你看到使用 <code>await</code> 的代码时，Rust 会将其编译为调用 <code>poll</code> 的代码。如果你回顾一下列表 17-4，我们在其中打印出单个 URL 解析后的页面标题，Rust 会将其编译成类似这样的代码（虽然不完全相同）：</p>
<pre><code class="language-rust ignore">match page_title(url).poll() {
    Ready(page_title) =&gt; match page_title {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
    Pending =&gt; {
        // But what goes here?
    }
}</code></pre>
<p data-x-en="What should we do when the Future is still Pending? We need some way to try again… and again, and again, until the future is finally ready. In other words, a loop:">当 <code>Future</code> 仍然是 <code>Pending</code> 时，我们应该怎么办？我们需要某种方法来尝试... 再次，再再次，直到未来最终准备好。换句话说，一个循环：</p>
<pre><code class="language-rust ignore">let mut page_title_fut = page_title(url);
loop {
    match page_title_fut.poll() {
        Ready(value) =&gt; match page_title {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
        Pending =&gt; {
            // continue
        }
    }
}</code></pre>
<p data-x-en="If Rust compiled it to exactly that code, though, every await would be blocking—exactly the opposite of what we were going for! Instead, Rust needs makes sure that the loop can hand off control to something which can pause work on this future and work on other futures and check this one again later. That “something” is an async runtime, and this scheduling and coordination work is one of the main jobs for a runtime.">如果 Rust 将其编译为完全相同的代码，那么每个 <code>await</code> 都会是阻塞的——这与我们的目标完全相反！相反，Rust 需要确保循环可以将控制权交给某个可以暂停此未来的处理并处理其他未来并在稍后再次检查此未来的东西。这个“东西”是一个异步运行时，而这种调度和协调工作是运行时的主要任务之一。</p>
<p data-x-en="Recall our description (in the Counting section) of waiting on rx.recv. The recv call returns a Future, and awaiting it polls it. In our initial discussion, we noted that a runtime will pause the future until it’s ready with either Some(message) or None when the channel closes. With our deeper understanding of Future in place, and specifically Future::poll, we can see how that works. The runtime knows the future isn’t ready when it returns Poll::Pending. Conversely, the runtime knows the future is ready and advances it when poll returns Poll::Ready(Some(message)) or Poll::Ready(None).">回顾我们在<a href="ch17-02-concurrency-with-async.html">计数</a>部分对等待<code>rx.recv</code>的描述。<code>recv</code>调用返回一个<code>Future</code>，并且等待它会轮询它。在我们最初的讨论中，我们提到运行时会暂停该未来对象，直到它准备好返回<code>Some(message)</code>或在通道关闭时返回<code>None</code>。有了我们对<code>Future</code>的更深入理解，特别是<code>Future::poll</code>，我们可以看到它是如何工作的。当返回<code>Poll::Pending</code>时，运行时知道未来对象尚未准备好。相反，当<code>poll</code>返回<code>Poll::Ready(Some(message))</code>或<code>Poll::Ready(None)</code>时，运行时知道未来对象已准备好并推进它。</p>
<p data-x-en="The exact details of how a runtime does that are more than we will cover in even this deep dive section. The key here is to see the basic mechanic of futures: a runtime polls each future it is responsible for, putting it back to sleep when it is not yet ready.">确切的细节关于运行时如何做到这一点超出了我们即使在这一深入探讨部分的范围。关键在于理解未来的基机制：运行时<em>轮询</em>每个它负责的未来，在它们尚未准备好时将其重新置于休眠状态。</p>
<h3 id="pinning-and-the-pin-and-unpin-traits"><a class="header" href="#pinning-and-the-pin-and-unpin-traits">固定和 Pin 与 Unpin 特性</a></h3>
<p data-x-en="When we introduced the idea of pinning while working on Listing 17-16, we ran into a very gnarly error message. Here is the relevant part of it again:">当我们介绍在处理清单 17-16 时固定的概念时，遇到了一个非常棘手的错误信息。以下是它相关部分的再次展示：</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-16
cargo build
copy *only* the final `error` block from the errors
-->
<pre><code class="language-text">error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --&gt; src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`
</code></pre>
<p data-x-en="When we read this error message carefully, it not only tells us that we need to pin the values, but also tells us why pinning is required. The trpl::join_all function returns a struct called JoinAll. That struct is generic over a type F, which is constrained to implement the Future trait. Directly awaiting a future with await pins the future implicitly. That’s why we don’t need to use pin! everywhere we want to await futures.">当我们仔细阅读这个错误信息时，它不仅告诉我们需要固定这些值，还告诉我们为什么需要固定。`<code>trpl::join_all</code>` 函数返回一个名为 `<code>JoinAll</code>` 的结构体。该结构体泛型于类型 `<code>F</code>`，该类型被约束为实现 `<code>Future</code>` 特性。直接使用 `<code>await</code>` 等待一个未来会隐式地固定该未来。这就是为什么我们在想要等待未来的地方不需要到处使用 `<code>pin!</code>`。</p>
<p data-x-en="However, we’re not directly awaiting a future here. Instead, we construct a new future, JoinAll, by passing a collection of futures to the join_all function. The signature for join_all produces requires that the type of the items in the collection all implement the Future trait, and Box<T> only implements Future if the T that it wraps is a future which implements the Unpin trait.">然而，我们在这里并不是直接等待一个未来。相反，我们通过将一个未来集合传递给 <code>join_all</code> 函数来构造一个新的未来，<code>JoinAll</code>。<code>join_all</code> 的签名要求集合中的项目类型都实现了 <code>Future</code> 特性，而 <code>Box&lt;T&gt;</code> 只有在其包装的 <code>T</code> 是一个实现了 <code>Unpin</code> 特性的未来时才实现 <code>Future</code>。</p>
<p data-x-en="That’s a lot! But we can understand it, if we dive a little further into how the Future type actually works, in particular around pinning.">那确实很多！但是，如果我们进一步探讨 <code>Future</code> 类型的工作原理，特别是关于 <em>固定</em> 的部分，我们就可以理解了。</p>
<p data-x-en="Let’s look again at the definition of Future:">让我们再次看看 <code>Future</code> 的定义：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    // Required method
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p data-x-en="The cx parameter and its Context type is the key to how a runtime actually knows when to check any given future, while still being lazy. The details of how that works are beyond the scope of this chapter, though: you generally only need to worry about it when writing a custom Future implementation."><code>cx</code> 参数及其 <code>Context</code> 类型是运行时实际知道何时检查任何给定的 future，同时仍然保持惰性化的关键。尽管如此，这些细节超出了本章的范围：通常只有在编写自定义 <code>Future</code> 实现时才需要关注这些。</p>
<p data-x-en="Instead, we’ll focus on the type for self. This is the first time we’ve seen a method where self has a type annotation. A type annotation for self is similar to type annotations for other function parameters, with two key differences. First, when we specify the type of self in this way, we’re telling Rust what type self must be to call this method. Second, a type annotation on self can’t be just any type. It’s only allowed to be the type on which the method is implemented, a reference or smart pointer to that type, or a Pin wrapping a reference to that type. We’ll see more on this syntax in Chapter 18. For now, it’s enough to know that if we want to poll a future (to check whether it is Pending or Ready(Output)), we need a mutable reference to the type, which is wrapped in a Pin.">相反，我们将关注 <code>self</code> 的类型。这是我们第一次看到一个方法中 <code>self</code> 有类型注解。<code>self</code> 的类型注解与其他函数参数的类型注解类似，但有两个关键区别。首先，当我们以这种方式指定 <code>self</code> 的类型时，我们是在告诉 Rust 调用此方法时 <code>self</code> 必须是什么类型。其次，<code>self</code> 的类型注解不能是任意类型。它只能是实现该方法的类型、该类型的引用或智能指针，或者是包装了该类型引用的 <code>Pin</code>。我们将在第 18 章中看到更多关于这种语法的内容。目前，知道如果我们想轮询一个未来（检查它是否为 <code>Pending</code> 或 <code>Ready(Output)</code>），我们需要一个被 <code>Pin</code> 包装的类型的可变引用就足够了。</p>
<p data-x-en="Pin is a wrapper type. In some ways, it’s similar to the Box, Rc, and other smart pointer types we saw in Chapter 15, which also wrap other types. Unlike those, however, Pin only works with pointer types such as references (&amp; and &amp;mut) and smart pointers (Box, Rc, and so on). To be precise, Pin works with types which implement the Deref or DerefMut traits, which we covered in Chapter 15. You can think of this restriction as equivalent to only working with pointers, though, because implementing Deref or DerefMut means your type behaves similarly to a pointer type. Pin is also not a pointer itself, and it doesn’t have any behavior of its own the way Rc and Arc do with ref counting. It’s purely a tool the compiler can use to uphold the relevant guarantees, by wrapping pointers in the type."><code>Pin</code> 是一个包装类型。在某些方面，它类似于我们在第 15 章中看到的 <code>Box</code>、<code>Rc</code> 和其他智能指针类型，这些类型也包装了其他类型。然而，与这些不同的是，<code>Pin</code> 只与 <em>指针类型</em> 一起工作，例如引用 (<code>&amp;</code> 和 <code>&amp;mut</code>) 和智能指针 (<code>Box</code>、<code>Rc</code> 等)。具体来说，<code>Pin</code> 与实现了 <code>Deref</code> 或 <code>DerefMut</code> 特性的类型一起工作，我们在第 15 章中讨论了这些特性。你可以将这种限制视为等同于仅与指针一起工作，因为实现 <code>Deref</code> 或 <code>DerefMut</code> 意味着你的类型行为类似于指针类型。<code>Pin</code> 本身也不是指针，它没有像 <code>Rc</code> 和 <code>Arc</code> 那样具有引用计数的行为。它纯粹是编译器可以用来通过包装指针类型来维护相关保证的工具。</p>
<p data-x-en="Recalling that await is implemented in terms of calls to poll, this starts to explain the error message we saw above—but that was in terms of Unpin, not Pin. So what exactly are Pin and Unpin, how do they relate, and why does Future need self to be in a Pin type to call poll?">回想 <code>await</code> 是通过调用 <code>poll</code> 来实现的，这开始解释了我们上面看到的错误信息——但那是在 <code>Unpin</code> 的背景下，而不是 <code>Pin</code>。那么，<code>Pin</code> 和 <code>Unpin</code> 到底是什么，它们之间有什么关系，为什么 <code>Future</code> 需要 <code>self</code> 处于 <code>Pin</code> 类型中才能调用 <code>poll</code>？</p>
<p data-x-en="In Our First Async Program, we described how a series of await points in a future get compiled into a state machine—and noted how the compiler helps make sure that state machine follows all of Rust’s normal rules around safety, including borrowing and ownership. To make that work, Rust looks at what data is needed between each await point and the next await point or the end of the async block. It then creates a corresponding variant in the state machine it creates. Each variant gets the access it needs to the data that will be used in that section of the source code, whether by taking ownership of that data or by getting a mutable or immutable reference to it.">在<a href="ch17-01-futures-and-syntax.html#our-first-async-program">我们的第一个异步程序</a>中，我们描述了未来中的一个系列的await点如何被编译成一个状态机——并指出编译器如何帮助确保该状态机遵循Rust关于安全性的所有常规规则，包括借用和所有权。为了使这一点生效，Rust会查看每个await点与下一个await点或异步块结束之间所需的数据。然后，它在创建的状态机中创建相应的变体。每个变体都会获得对该部分源代码中将使用的数据的访问权限，无论是通过获取该数据的所有权还是通过获取其可变或不可变引用。</p>
<p data-x-en="So far so good: if we get anything wrong about the ownership or references in a given async block, the borrow checker will tell us. When we want to move around the future that corresponds to that block—like moving it into a Vec to pass to join_all, the way we did back in the “Working With Any Number of Futures” section—things get trickier.">到目前为止一切顺利：如果我们对给定异步块中的所有权或引用有任何错误，借用检查器会告诉我们。当我们想要移动与该块对应的未来对象时——比如将其移动到<code>Vec</code>中以传递给<code>join_all</code>，就像我们在<a href="ch17-03-more-futures.html#working-with-any-number-of-futures">“处理任意数量的未来对象”</a><!-- ignore -->部分所做的那样——事情会变得更复杂。</p>
<p data-x-en="When we move a future—whether by pushing into a data structure to use as an iterator with join_all, or returning them from a function—that actually means moving the state machine Rust creates for us. And unlike most other types in Rust, the futures Rust creates for async blocks can end up with references to themselves in the fields of any given variant, as in Figure 17-4 (a simplified illustration to help you get a feel for the idea, rather than digging into what are often fairly complicated details).">当我们移动一个未来——无论是通过将其推入数据结构以用作 <code>join_all</code> 的迭代器，还是从函数返回它们——这实际上意味着移动 Rust 为我们创建的状态机。与 Rust 中的大多数其他类型不同，Rust 为异步块创建的未来可以在任何给定变体的字段中最终包含对自身的引用，如图 17-4 所示（这是一个简化的图示，旨在帮助您理解这个概念，而不是深入探讨通常相当复杂的细节）。</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-04.svg" class="center">
<figcaption>Figure 17-4: A self-referential data type.</figcaption>
</figure>
<p data-x-en="By default, though, any object which has a reference to itself is unsafe to move, because references always point to the actual memory address of the thing they refer to. If you move the data structure itself, those internal references will be left pointing to the old location. However, that memory location is now invalid. For one thing, its value will not be updated when you make changes to the data structure. For another—and more importantly!—the computer is now free to reuse that memory for other things! You could end up reading completely unrelated data later.">默认情况下，任何具有指向自身引用的对象在移动时都是不安全的，因为引用总是指向它们所引用对象的实际内存地址。如果你移动了数据结构本身，那些内部引用将仍然指向旧的位置。然而，那个内存位置现在是无效的。一方面，当你对数据结构进行更改时，其值不会被更新。另一方面，更重要的是！计算机现在可以自由地将该内存用于其他事情！你可能会在稍后读取完全不相关的数据。</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-05.svg" class="center">
<figcaption>Figure 17-5: The unsafe result of moving a self-referential data type.</figcaption>
</figure>
<p data-x-en="In principle, the Rust compiler could try to update every reference to an object every time it gets moved. That would potentially be a lot of performance overhead, especially given there can be a whole web of references that need updating. On the other hand, if we could make sure the data structure in question doesn’t move in memory, we don’t have to update any references. This is exactly what Rust’s borrow checker requires: you can’t move an item which has any active references to it using safe code.">原则上，Rust 编译器可以尝试在每次对象移动时更新每个对该对象的引用。这可能会带来大量的性能开销，特别是考虑到可能需要更新的引用网络。另一方面，如果我们能确保该数据结构 <em>不会在内存中移动</em>，我们就不需要更新任何引用。这正是 Rust 的借用检查器所要求的：你不能使用安全代码移动任何有活动引用的项。</p>
<p data-x-en="Pin builds on that to give us the exact guarantee we need. When we pin a value by wrapping a pointer to that value in Pin, it can no longer move. Thus, if you have Pin<Box<SomeType>>, you actually pin the SomeType value, not the Box pointer. Figure 17-6 illustrates this:"><code>Pin</code> 在此基础上为我们提供了所需的精确保证。当我们通过将指向该值的指针包装在 <code>Pin</code> 中来 <em>固定</em> 一个值时，该值将不能再移动。因此，如果你有 <code>Pin&lt;Box&lt;SomeType&gt;&gt;</code>，你实际上固定的是 <code>SomeType</code> 值，<em>而不是</em> <code>Box</code> 指针。图 17-6 说明了这一点：</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-06.svg" class="center">
<figcaption>Figure 17-6: Pinning a `Box` which points to a self-referential future type.</figcaption>
</figure>
<p data-x-en="In fact, the Box pointer can still move around freely. Remember: we care about making sure the data ultimately being referenced stays in its place. If a pointer moves around, but the data it points to is in the same place, as in Figure 17-7, there’s no potential problem. (How you would do this with a Pin wrapping a Box is more than we’ll get into in this particular discussion, but it would make for a good exercise! If you look at the docs for the types as well as the std::pin module, you might be able to work out how you would do that.) The key is that the self-referential type itself cannot move, because it is still pinned.">事实上，<code>Box</code> 指针仍然可以自由移动。记住：我们关心的是确保最终被引用的数据保持在原位。如果指针移动了，但其所指向的数据仍在同一位置，如图 17-7 所示，就没有潜在的问题。（如何使用 <code>Pin</code> 包装 <code>Box</code> 来实现这一点超出了我们当前讨论的范围，但这将是一个很好的练习！如果你查看这些类型的文档以及 <code>std::pin</code> 模块，你可能会弄清楚如何做到这一点。）关键是自引用类型本身不能移动，因为它仍然是固定的。</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-07.svg" class="center">
<figcaption>Figure 17-7: Moving a `Box` which points to a self-referential future type.</figcaption>
</figure>
<p data-x-en="However, most types are perfectly safe to move around, even if they happen to be behind a Pin pointer. We only need to think about pinning when items have internal references. Primitive values such as numbers and booleans don’t have any internal references, so they’re obviously safe. Neither do most types you normally work with in Rust. A Vec, for example, doesn’t have any internal references it needs to keep up to date this way, so you can move it around without worrying. If you have a Pin<Vec<String>>, you’d have to do everything via the safe but restrictive APIs provided by Pin, even though a Vec<String> is always safe to move if there are no other references to it. We need a way to tell the compiler that it’s actually just fine to move items around in cases such as these. For that, we have Unpin.">然而，大多数类型即使在 <code>Pin</code> 指针后面也是完全安全的。我们只有在项目具有内部引用时才需要考虑固定。像数字和布尔值这样的原始值没有任何内部引用，因此它们显然是安全的。你通常在 Rust 中使用的大多数类型也是如此。例如，<code>Vec</code> 没有任何需要保持更新的内部引用，因此你可以随意移动它而无需担心。如果你有一个 <code>Pin&lt;Vec&lt;String&gt;&gt;</code>，即使 <code>Vec&lt;String&gt;</code> 在没有其他引用的情况下总是可以安全移动的，你也必须通过 <code>Pin</code> 提供的安全但受限的 API 来做所有事情。我们需要一种方法来告诉编译器在这些情况下实际上可以安全地移动项目。为此，我们有 <code>Unpin</code>。</p>
<p data-x-en="Unpin is a marker trait, similar to the Send and Sync traits we saw in Chapter 16. Recall that marker traits have no functionality of their own. They exist only to tell the compiler that it’s safe to use the type which implements a given trait in a particular context. Unpin informs the compiler that a given type does not need to uphold any particular guarantees about whether the value in question can be moved."><code>Unpin</code> 是一个标记特征，类似于我们在第 16 章中看到的 <code>Send</code> 和 <code>Sync</code> 特征。回想一下，标记特征本身没有任何功能。它们仅存在于告诉编译器，实现给定特征的类型在特定上下文中使用是安全的。<code>Unpin</code> 告知编译器，给定的类型不需要维持任何关于该值是否可以移动的特定保证。</p>
<p data-x-en="Just as with Send and Sync, the compiler implements Unpin automatically for all types where it can prove it is safe. The special case, again similar to Send and Sync, is the case where Unpin is not implemented for a type. The notation for this is impl !Unpin for SomeType, where SomeType is the name of a type which does need to uphold those guarantees to be safe whenever a pointer to that type is used in a Pin.">正如对 <code>Send</code> 和 <code>Sync</code> 一样，编译器会自动为所有可以证明安全的类型实现 <code>Unpin</code>。特殊情况，同样类似于 <code>Send</code> 和 <code>Sync</code>，是 <code>Unpin</code> <em>未</em> 为某个类型实现的情况。这种表示法是 <code>impl !Unpin for SomeType</code>，其中 <code>SomeType</code> 是需要在使用该类型的指针时确保这些保证以确保安全的类型的名称。</p>
<p data-x-en="In other words, there are two things to keep in mind about the relationship between Pin and Unpin. First, Unpin is the “normal” case, and !Unpin is the special case. Second, whether a type implements Unpin or !Unpin only matters when using a pinned pointer to that type like Pin<&amp;mut SomeType>.">换句话说，关于 <code>Pin</code> 和 <code>Unpin</code> 之间的关系，有两点需要注意。首先，<code>Unpin</code> 是“正常”情况，而 <code>!Unpin</code> 是特殊情况。其次，一个类型是否实现了 <code>Unpin</code> 或 <code>!Unpin</code> <em>仅在</em> 使用指向该类型的固定指针（如 <code>Pin&lt;&amp;mut SomeType&gt;</code>）时才重要。</p>
<p data-x-en="To make that concrete, think about a String: it has a length and the Unicode characters which make it up. We can wrap a String in Pin, as seen in Figure 17-8. However, String automatically implements Unpin, the same as most other types in Rust.">为了具体说明这一点，考虑一个 <code>String</code>：它有一个长度和组成它的 Unicode 字符。我们可以在 <code>Pin</code> 中包装一个 <code>String</code>，如图 17-8 所示。然而，<code>String</code> 自动实现了 <code>Unpin</code>，就像 Rust 中的大多数其他类型一样。</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-08.svg" class="center">
<figcaption>Figure 17-8: Pinning a String, with a dotted line indicating that the String implements the `Unpin` trait, so it is not pinned.</figcaption>
</figure>
<p data-x-en="As a result, we can do things which would be illegal if String implemented !Unpin instead, such as replace one string with another at the exact same location in memory as in Figure 17-9. This doesn’t violate the Pin contract, because String has no internal references that make it unsafe to move around! That is precisely why it implements Unpin rather than !Unpin.">因此，我们可以做一些如果 <code>String</code> 实现了 <code>!Unpin</code> 就会非法的事情，比如在内存中的确切相同位置用另一个字符串替换一个字符串，如图17-9所示。这不会违反 <code>Pin</code> 协议，因为 <code>String</code> 没有内部引用使其移动不安全！这正是它实现 <code>Unpin</code> 而不是 <code>!Unpin</code> 的原因。</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-09.svg" class="center">
<figcaption>Figure 17-9: Replacing the String with an entirely different String in memory.</figcaption>
</figure>
<p data-x-en="Now we know enough to understand the errors reported for that join_all call from back in Listing 17-17. We originally tried to move the futures produced by async blocks into a Vec<Box<dyn Future<Output = ()>>>, but as we’ve seen, those futures may have internal references, so they don’t implement Unpin. They need to be pinned, and then we can pass the Pin type into the Vec, confident that the underlying data in the futures will not be moved.">现在我们已经了解了足够的知识，可以理解在清单 17-17 中报告的 <code>join_all</code> 调用的错误。我们最初尝试将由 async 块生成的 future 移动到 <code>Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;</code> 中，但正如我们所见，这些 future 可能有内部引用，因此它们不实现 <code>Unpin</code>。它们需要被固定，然后我们可以将 <code>Pin</code> 类型传递给 <code>Vec</code>，确信 future 中的底层数据 <em>不会</em> 被移动。</p>
<p data-x-en="Pin and Unpin are mostly important for building lower-level libraries, or when you’re building a runtime itself, rather than for day to day Rust code. When you see these traits in error messages, though, now you’ll have a better idea of how to fix the code!"><code>Pin</code> 和 <code>Unpin</code> 主要对于构建底层库或构建运行时本身非常重要，而不是用于日常的 Rust 代码。当你在错误消息中看到这些特征时，现在你将更好地了解如何修复代码！</p>
<section class="note" aria-role="note">
<p data-x-en="Note: This combination of Pin and Unpin allows a whole class of complex types to be safe in Rust which are otherwise difficult to implement because they’re self-referential. Types which require Pin show up most commonly in async Rust today, but you might—very rarely!—see it in other contexts, too.">注意：这种 <code>Pin</code> 和 <code>Unpin</code> 的组合使得一类复杂的类型在 Rust 中是安全的，而这些类型由于是自引用的，通常很难实现。需要 <code>Pin</code> 的类型在今天的异步 Rust 中最常见，但你也可能——非常罕见！——在其他上下文中看到它。</p>
<p data-x-en="The specifics of how Pin and Unpin work, and the rules they’re required to uphold, are covered extensively in the API documentation for std::pin, so if you’d like to understand them more deeply, that’s a great place to start."><code>Pin</code> 和 <code>Unpin</code> 的具体工作方式以及它们需要遵守的规则，在 <code>std::pin</code> 的 API 文档中进行了详尽的介绍，因此如果你想更深入地了解它们，这是一个很好的起点。</p>
<p data-x-en="If you want to understand how things work “under the hood” in even more detail, the official Asynchronous Programming in Rust book has you covered:">如果您想更详细地了解“底层”工作原理，官方的<a href="https://rust-lang.github.io/async-book/"><em>Rust 中的异步编程</em></a>书籍会为您解答：</p>
<ul>
<li><a href="https://rust-lang.github.io/async-book/02_execution/01_chapter.html">Chapter 2: Under the Hood: Executing Futures and Tasks</a></li>
<li><a href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html">Chapter 4: Pinning</a></li>
</ul>
</section>
<h3 id="the-stream-trait"><a class="header" href="#the-stream-trait">流特质</a></h3>
<p data-x-en="Now that we have a deeper grasp on the Future, Pin, and Unpin traits, we can turn our attention to the Stream trait. As described in the section introducing streams, streams are similar to asynchronous iterators. Unlike Iterator and Future, there is no definition of a Stream trait in the standard library as of the time of writing, but there is a very common definition from the futures crate used throughout the ecosystem.">现在我们对 <code>Future</code>、<code>Pin</code> 和 <code>Unpin</code> 特性有了更深入的了解，我们可以将注意力转向 <code>Stream</code> 特性。正如在介绍流的部分所述，流类似于异步迭代器。与 <code>Iterator</code> 和 <code>Future</code> 不同，截至本文撰写时，标准库中没有 <code>Stream</code> 特性的定义，但 <code>futures</code> 库中有一个非常常见的定义，在整个生态系统中广泛使用。</p>
<p data-x-en="Let’s review the definitions of the Iterator and Future traits, so we can build up to how a Stream trait that merges them together might look. From Iterator, we have the idea of a sequence: its next method provides an Option<Self::Item>. From Future, we have the idea of readiness over time: its poll method provides a Poll<Self::Output>. To represent a sequence of items which become ready over time, we define a Stream trait which puts those features together:">让我们回顾一下 <code>Iterator</code> 和 <code>Future</code> 特性的定义，这样我们就可以逐步了解如何将它们合并到一个 <code>Stream</code> 特性中。从 <code>Iterator</code> 中，我们有序列的概念：其 <code>next</code> 方法提供一个 <code>Option&lt;Self::Item&gt;</code>。从 <code>Future</code> 中，我们有随时间变化的准备状态的概念：其 <code>poll</code> 方法提供一个 <code>Poll&lt;Self::Output&gt;</code>。为了表示随时间变化的项目序列，我们定义了一个 <code>Stream</code> 特性，将这些特性结合在一起：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

trait Stream {
    type Item;

    fn poll_next(
        self: Pin&lt;&amp;mut Self&gt;,
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p data-x-en="The Stream trait defines an associated type Item for the type of the items produced by the stream. This is similar to Iterator: there may be zero to many of these, and unlike Future, where there is always a single Output (even if it’s the unit type ())."><code>Stream</code> 特性定义了一个关联类型 <code>Item</code>，用于表示流产生的项的类型。这与 <code>Iterator</code> 类似：可能有零个到多个这样的项，而与 <code>Future</code> 不同，<code>Future</code> 始终只有一个 <code>Output</code>（即使它是单元类型 <code>()</code>）。</p>
<p data-x-en="Stream also defines a method to get those items. We call it poll_next, to make it clear that it polls in the same way Future::poll does and produces a sequence of items in the same way Iterator::next does. Its return type combines Poll with Option. The outer type is Poll, because it has to be checked for readiness, just as a future does. The inner type is Option, because it needs to signal whether there are more messages, just as an iterator does."><code>Stream</code> 还定义了一个方法来获取这些项。我们称之为 <code>poll_next</code>，以明确它以与 <code>Future::poll</code> 相同的方式进行轮询，并以与 <code>Iterator::next</code> 相同的方式生成一系列项。其返回类型将 <code>Poll</code> 与 <code>Option</code> 结合在一起。外部类型是 <code>Poll</code>，因为它需要像未来一样检查就绪状态。内部类型是 <code>Option</code>，因为它需要像迭代器一样指示是否还有更多消息。</p>
<p data-x-en="Something very similar to this will likely end up standardized as part of Rust’s standard library. In the meantime, it’s part of the toolkit of most runtimes, so you can rely on it, and everything we cover below should generally apply!">与这非常相似的内容很可能会成为 Rust 标准库的一部分。在此期间，它已经是大多数运行时工具包的一部分，因此你可以依赖它，下面涵盖的所有内容通常都适用！</p>
<p data-x-en="In the example we saw in the section on streaming, though, we didn’t use poll_next or Stream, but instead used next and StreamExt. We could work directly in terms of the poll_next API by hand-writing our own Stream state machines, of course, just as we could work with futures directly via their poll method. Using await is much nicer, though, so the StreamExt trait supplies the next method so we can do just that.">在我们之前在流处理部分看到的例子中，我们并没有使用<code>poll_next</code> <em>或</em> <code>Stream</code>，而是使用了<code>next</code>和<code>StreamExt</code>。我们<em>可以</em>通过手动编写自己的<code>Stream</code>状态机来直接使用<code>poll_next</code> API，当然，我们<em>也可以</em>通过它们的<code>poll</code>方法直接处理未来对象。然而，使用<code>await</code>要方便得多，因此<code>StreamExt</code>特质提供了<code>next</code>方法，使我们能够这样做。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::pin::Pin;
</span><span class="boring">use std::task::{Context, Poll};
</span><span class="boring">
</span><span class="boring">trait Stream {
</span><span class="boring">    type Item;
</span><span class="boring">    fn poll_next(
</span><span class="boring">        self: Pin&lt;&amp;mut Self&gt;,
</span><span class="boring">        cx: &amp;mut Context&lt;'_&gt;,
</span><span class="boring">    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>trait StreamExt: Stream {
    async fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
    where
        Self: Unpin;

    // other methods...
}
<span class="boring">}</span></code></pre></pre>
<!--
TODO: update this if/when tokio/etc. update their MSRV and switch to using async functions
in traits, since the lack thereof is the reason they do not yet have this.
-->
<section class="note" aria-role="note">
<p data-x-en="Note: The actual definition we used earlier in the chapter looks slightly different than this, because it supports versions of Rust which did not yet support using async functions in traits. As a result, it looks like this:">注意：我们在本章前面使用的实际定义与此略有不同，因为它支持尚未支持在特质中使用异步函数的 Rust 版本。因此，它看起来像这样：</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Next&lt;'_, Self&gt; where Self: Unpin;</code></pre>
<p data-x-en="That Next type is a struct which implements Future and gives a way to name the lifetime of the reference to self with Next<'_, Self>, so that await can work with this method!">那个 <code>Next</code> 类型是一个 <code>struct</code>，它实现了 <code>Future</code> 并提供了一种方法来命名对 <code>self</code> 的引用的生命周期，使用 <code>Next&lt;'_, Self&gt;</code>，这样 <code>await</code> 就可以与这个方法一起工作！</p>
</section>
<p data-x-en="The StreamExt trait is also the home of all the interesting methods available to use with streams. StreamExt is automatically implemented for every type which implements Stream, but these traits are defined separately so that the community can iterate on the foundational trait distinctly from the convenience APIs."><code>StreamExt</code> 特性也是所有可用于流的有趣方法的所在地。<code>StreamExt</code> 会自动为每个实现了 <code>Stream</code> 的类型实现，但这些特性是单独定义的，以便社区可以独立于基础特性迭代便利性 API。</p>
<p data-x-en="In the version of StreamExt used in the trpl crate, the trait not only defines the next method, it also supplies an implementation of next, which correctly handles the details of calling Stream::poll_next. This means that even when you need to write your own streaming data type, you only have to implement Stream, and then anyone who uses your data type can use StreamExt and its methods with it automatically.">在用于 <code>trpl</code> crate 的 <code>StreamExt</code> 版本中，该 trait 不仅定义了 <code>next</code> 方法，还提供了 <code>next</code> 方法的实现，该实现正确处理了调用 <code>Stream::poll_next</code> 的细节。这意味着，即使你需要编写自己的流数据类型，你也 <em>只需</em> 实现 <code>Stream</code>，然后任何使用你数据类型的人可以自动使用 <code>StreamExt</code> 及其方法。</p>
<p data-x-en="That’s all we’re going to cover for the lower-level details on these traits. To wrap up, let’s consider how futures (including streams), tasks, and threads all fit together!">这就是我们对这些特质的底层细节的所有介绍。为了总结，让我们考虑一下未来（包括流）、任务和线程是如何协同工作的！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-04-streams.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-06-futures-tasks-threads.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-04-streams.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-06-futures-tasks-threads.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    

</body></html>