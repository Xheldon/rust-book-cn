<!DOCTYPE html><html lang="zh-CN" class="light sidebar-visible" dir="ltr"><head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>特性面向对象语言 - 《Rust编程语言》</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    <meta name="title" content="Rust 中文"><meta property="og:title" content="Rust 中文"><meta name="description" content="Rust 中文文档"><meta property="og:description" content="Rust 中文文档"><meta name="url" content="https://rust.xheldon.com"><meta property="og:url" content="https://rust.xheldon.com"><script src="https://www.googletagmanager.com/gtag/js?id=G-V7NE1X37EX"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-V7NE1X37EX')</script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486286026923411"></script><style>/* hover 显示原文 */
p[data-x-en],
li[data-x-en] {
  position: relative;
}
p[data-x-en]:hover::after,
li[data-x-en]:hover::after {
  visibility: visible;
  opacity: 1;
}
p[data-x-en]::after,
li[data-x-en]::after {
  content: attr(data-x-en);
  display: block;
  font-size: 12px;
  transition: all 0.2s 0.3s;
  visibility: hidden;
  opacity: 0;
  background: var(--searchbar-bg);
  z-index: 99;
  border-radius: 4px;
  padding: 5px 10px;
  position: absolute;
  top: 100%;
  left: 0;
}
/* 译者注释内容 */
div[type='comment'] {
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  background: #eee;
}
div[type='comment']::before {
  content: '译者注: ';
  font-weight: 900;
}
header a.logo {
  position: relative;
}
header a.logo::after {
  content: '中文';
  position: absolute;
  left: calc(100% + 5px);
  font-size: 12px;
  width: 50px;
  top: -5px;
}
#banner-info {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  font-size: 12px;
  padding: 0;
  z-index: 999;
}
#add-info {
  font-size: 14px;
}
blockquote {
  border-left: 5px solid #ccc;
  padding-left: 10px;
  margin-left: 0;
}
.content {
  overflow-y: unset !important;
}
</style></head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky"><div id="banner-info">本文档为 AI + 人工翻译，hover 可以显示原文。当前页翻译有问题？<a style="cursor: pointer;" href="https://github.com/Xheldon/rust-book-cn/blob/main/dict/ch18-01-what-is-oo.json" target="_blank">我来翻译！</a></div>
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    <a href="https://github.com/Xheldon/rust-book-cn" target="_blank"><i class="fa fa-language"></i></a><a href="https://www.xheldon.com" target="_blank"><i class="fa fa-id-card"></i></a></div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="characteristics-of-object-oriented-languages"><a class="header" href="#characteristics-of-object-oriented-languages">面向对象语言的特性</a></h2>
<p data-x-en="There is no consensus in the programming community about what features a language must have to be considered object oriented. Rust is influenced by many programming paradigms, including OOP; for example, we explored the features that came from functional programming in Chapter 13. Arguably, OOP languages share certain common characteristics, namely objects, encapsulation, and inheritance. Let’s look at what each of those characteristics means and whether Rust supports it.">在编程社区中，对于一种语言必须具备哪些特性才能被视为面向对象并没有共识。Rust 受到了许多编程范式的影响，包括面向对象编程；例如，我们在第 13 章中探讨了来自函数式编程的特性。可以说，面向对象语言具有一些共同的特征，即对象、封装和继承。让我们看看每个特征的含义以及 Rust 是否支持它们。</p>
<h3 id="objects-contain-data-and-behavior"><a class="header" href="#objects-contain-data-and-behavior">对象包含数据和行为</a></h3>
<p data-x-en="The book Design Patterns: Elements of Reusable Object-Oriented Software by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley, 1994), colloquially referred to as The Gang of Four book, is a catalog of object-oriented design patterns. It defines OOP in this way:">由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides (Addison-Wesley, 1994) 撰写的书籍 <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>，俗称 <em>The Gang of Four</em> 书，是一本关于面向对象设计模式的目录。它以这种方式定义 OOP：</p>
<blockquote>
<p data-x-en="Object-oriented programs are made up of objects. An object packages both data and the procedures that operate on that data. The procedures are typically called methods or operations.">面向对象的程序由对象组成。一个<em>对象</em>封装了数据和操作这些数据的过程。这些过程通常被称为<em>方法</em>或<em>操作</em>。</p>
</blockquote>
<p data-x-en="Using this definition, Rust is object oriented: structs and enums have data, and impl blocks provide methods on structs and enums. Even though structs and enums with methods aren’t called objects, they provide the same functionality, according to the Gang of Four’s definition of objects.">根据这个定义，Rust 是面向对象的：结构体和枚举有数据，<code>impl</code> 块为结构体和枚举提供方法。即使带有方法的结构体和枚举不<em>称为</em>对象，它们根据四人组对对象的定义提供了相同的功能。</p>
<h3 id="encapsulation-that-hides-implementation-details"><a class="header" href="#encapsulation-that-hides-implementation-details">隐藏实现细节的封装</a></h3>
<p data-x-en="Another aspect commonly associated with OOP is the idea of encapsulation, which means that the implementation details of an object aren’t accessible to code using that object. Therefore, the only way to interact with an object is through its public API; code using the object shouldn’t be able to reach into the object’s internals and change data or behavior directly. This enables the programmer to change and refactor an object’s internals without needing to change the code that uses the object.">与 OOP 常常相关的另一个方面是 <em>封装</em> 的概念，这意味着对象的实现细节对于使用该对象的代码是不可访问的。因此，与对象交互的唯一方式是通过其公共 API；使用对象的代码不应该能够触及对象的内部并直接更改数据或行为。这使得程序员可以在不需更改使用对象的代码的情况下更改和重构对象的内部。</p>
<p data-x-en="We discussed how to control encapsulation in Chapter 7: we can use the pub keyword to decide which modules, types, functions, and methods in our code should be public, and by default everything else is private. For example, we can define a struct AveragedCollection that has a field containing a vector of i32 values. The struct can also have a field that contains the average of the values in the vector, meaning the average doesn’t have to be computed on demand whenever anyone needs it. In other words, AveragedCollection will cache the calculated average for us. Listing 18-1 has the definition of the AveragedCollection struct.">我们在第7章讨论了如何控制封装：我们可以使用<code>pub</code>关键字来决定代码中的哪些模块、类型、函数和方法应该是公共的，而默认情况下其他一切都是私有的。例如，我们可以定义一个包含<i32>值向量的字段的结构体<code>AveragedCollection</code>。该结构体还可以包含一个字段，该字段包含向量中值的平均数，这意味着每当有人需要时，平均数不必按需计算。换句话说，<code>AveragedCollection</code>将为我们缓存计算出的平均数。列表18-1给出了<code>AveragedCollection</code>结构体的定义。</i32></p>
<figure class="listing" id="listing-18-1">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}</code></pre>
<figcaption><a href="#listing-18-1">Listing 18-1</a>: An <code>AveragedCollection</code> struct that maintains a list of integers and the average of the items in the collection</figcaption>
</figure>
<p data-x-en="The struct is marked pub so that other code can use it, but the fields within the struct remain private. This is important in this case because we want to ensure that whenever a value is added or removed from the list, the average is also updated. We do this by implementing add, remove, and average methods on the struct, as shown in Listing 18-2.">这个结构体被标记为<code>pub</code>，以便其他代码可以使用它，但结构体内的字段仍然保持私有。这在本例中很重要，因为我们要确保每当向列表中添加或删除值时，平均值也会被更新。我们通过在结构体上实现<code>add</code>、<code>remove</code>和<code>average</code>方法来实现这一点，如清单18-2所示。</p>
<figure class="listing" id="listing-18-2">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}</code></pre>
<figcaption><a href="#listing-18-2">Listing 18-2</a>: Implementations of the public methods <code>add</code>, <code>remove</code>, and <code>average</code> on <code>AveragedCollection</code></figcaption>
</figure>
<p data-x-en="The public methods add, remove, and average are the only ways to access or modify data in an instance of AveragedCollection. When an item is added to list using the add method or removed using the remove method, the implementations of each call the private update_average method that handles updating the average field as well.">公共方法 <code>add</code>、<code>remove</code> 和 <code>average</code> 是访问或修改 <code>AveragedCollection</code> 实例中数据的唯一方式。当使用 <code>add</code> 方法向 <code>list</code> 添加项目或使用 <code>remove</code> 方法移除项目时，每个方法的实现都会调用私有的 <code>update_average</code> 方法，该方法负责更新 <code>average</code> 字段。</p>
<p data-x-en="We leave the list and average fields private so there is no way for external code to add or remove items to or from the list field directly; otherwise, the average field might become out of sync when the list changes. The average method returns the value in the average field, allowing external code to read the average but not modify it.">我们把 <code>list</code> 和 <code>average</code> 字段设为私有，这样外部代码就无法直接向 <code>list</code> 字段添加或删除项目；否则，当 <code>list</code> 发生变化时，<code>average</code> 字段可能会不同步。<code>average</code> 方法返回 <code>average</code> 字段中的值，允许外部代码读取 <code>average</code> 但不能修改它。</p>
<p data-x-en="Because we’ve encapsulated the implementation details of the struct AveragedCollection, we can easily change aspects, such as the data structure, in the future. For instance, we could use a HashSet<i32> instead of a Vec<i32> for the list field. As long as the signatures of the add, remove, and average public methods stayed the same, code using AveragedCollection wouldn’t need to change. If we made list public instead, this wouldn’t necessarily be the case: HashSet<i32> and Vec<i32> have different methods for adding and removing items, so the external code would likely have to change if it were modifying list directly.">因为我们已经封装了 <code>AveragedCollection</code> 结构体的实现细节，所以我们可以轻松地在未来更改某些方面，例如数据结构。例如，我们可以使用 <code>HashSet&lt;i32&gt;</code> 而不是 <code>Vec&lt;i32&gt;</code> 作为 <code>list</code> 字段。只要 <code>add</code>、<code>remove</code> 和 <code>average</code> 公共方法的签名保持不变，使用 <code>AveragedCollection</code> 的代码就不需要更改。如果我们把 <code>list</code> 设为公共的，情况就不一定如此了：<code>HashSet&lt;i32&gt;</code> 和 <code>Vec&lt;i32&gt;</code> 在添加和删除项目时有不同的方法，因此如果外部代码直接修改 <code>list</code>，很可能需要更改。</p>
<p data-x-en="If encapsulation is a required aspect for a language to be considered object oriented, then Rust meets that requirement. The option to use pub or not for different parts of code enables encapsulation of implementation details.">如果封装是语言被认为是面向对象的必要方面，那么 Rust 满足这一要求。选择使用 <code>pub</code> 或不使用 <code>pub</code> 为代码的不同部分启用实现细节的封装。</p>
<h3 id="inheritance-as-a-type-system-and-as-code-sharing"><a class="header" href="#inheritance-as-a-type-system-and-as-code-sharing">继承作为类型系统和代码共享</a></h3>
<p data-x-en="Inheritance is a mechanism whereby an object can inherit elements from another object’s definition, thus gaining the parent object’s data and behavior without you having to define them again."><em>继承</em>是一种机制，通过这种机制，一个对象可以从另一个对象的定义中继承元素，从而获得父对象的数据和行为，而无需再次定义它们。</p>
<p data-x-en="If a language must have inheritance to be object oriented, then Rust is not such a language. There is no way to define a struct that inherits the parent struct’s fields and method implementations without using a macro.">如果一种语言必须具有继承才能成为面向对象的语言，那么 Rust 就不是这样的语言。没有办法定义一个结构体来继承父结构体的字段和方法实现，除非使用宏。</p>
<p data-x-en="However, if you’re used to having inheritance in your programming toolbox, you can use other solutions in Rust, depending on your reason for reaching for inheritance in the first place.">但是，如果您习惯于在编程工具箱中使用继承，您可以根据最初使用继承的原因在 Rust 中使用其他解决方案。</p>
<p data-x-en="You would choose inheritance for two main reasons. One is for reuse of code: you can implement particular behavior for one type, and inheritance enables you to reuse that implementation for a different type. You can do this in a limited way in Rust code using default trait method implementations, which you saw in Listing 10-14 when we added a default implementation of the summarize method on the Summary trait. Any type implementing the Summary trait would have the summarize method available on it without any further code. This is similar to a parent class having an implementation of a method and an inheriting child class also having the implementation of the method. We can also override the default implementation of the summarize method when we implement the Summary trait, which is similar to a child class overriding the implementation of a method inherited from a parent class.">你会出于两个主要原因选择继承。一个是代码重用：
你可以在一个类型上实现特定的行为，继承使你能够
在不同的类型上重用该实现。你可以在 Rust 代码中以有限的方式使用默认特征方法实现来实现这一点，我们在
清单 10-14 中添加了 <code>Summary</code> 特征的 <code>summarize</code> 方法的默认实现时已经看到了这一点。任何实现了 <code>Summary</code> 特征的类型都会
在没有进一步代码的情况下拥有 <code>summarize</code> 方法。这类似于父类有一个方法的实现，继承的子类也有该方法的实现。当我们在实现 <code>Summary</code> 特征时，还可以覆盖 <code>summarize</code> 方法的默认实现，这类似于子类覆盖从父类继承的方法的实现。</p>
<p data-x-en="The other reason to use inheritance relates to the type system: to enable a child type to be used in the same places as the parent type. This is also called polymorphism, which means that you can substitute multiple objects for each other at runtime if they share certain characteristics.">使用继承的另一个原因与类型系统有关：使子类型能够在与父类型相同的地方使用。这也可以称为<em>多态性</em>，这意味着如果多个对象共享某些特性，你可以在运行时用一个对象替代另一个对象。</p>
<section class="note" aria-role="note">
<h3 id="polymorphism"><a class="header" href="#polymorphism">多态性</a></h3>
<p data-x-en="To many people, polymorphism is synonymous with inheritance. But it’s actually a more general concept that refers to code that can work with data of multiple types. For inheritance, those types are generally subclasses.">对许多人来说，多态性等同于继承。但实际上，它是一个更广泛的概念，指的是可以处理多种类型数据的代码。对于继承，这些类型通常是子类。</p>
<p data-x-en="Rust instead uses generics to abstract over different possible types and trait bounds to impose constraints on what those types must provide. This is sometimes called bounded parametric polymorphism.">Rust 相反使用泛型来抽象出不同的可能类型，并使用特质边界来对这些类型必须提供的内容施加约束。这有时被称为<em>有界参数多态</em>。</p>
</section>
<p data-x-en="Rust has chosen a different set of tradeoffs by not offering inheritance. Inheritance is often at risk of sharing more code than necessary. Subclasses shouldn’t always share all characteristics of their parent class but will do so with inheritance. This can make a program’s design less flexible. It also introduces the possibility of calling methods on subclasses that don’t make sense or that cause errors because the methods don’t apply to the subclass. In addition, some languages will only allow single inheritance (meaning a subclass can only inherit from one class), further restricting the flexibility of a program’s design.">Rust 通过不提供继承选择了一组不同的权衡。
继承通常会冒着共享比必要更多的代码的风险。子类
不应该总是共享其父类的所有特征，但在继承中会这样做。
这会使程序的设计变得不那么灵活。它还
引入了在子类上调用没有意义或导致错误的方法的可能性，因为这些方法不适用于子类。此外，一些语言只允许 <em>单一继承</em>（意味着一个子类只能继承自一个类），进一步限制了程序设计的灵活性。</p>
<p data-x-en="For these reasons, Rust takes the different approach of using trait objects instead of inheritance to enable polymorphism. Let’s look at how trait objects work.">出于这些原因，Rust 采用了使用特质对象（trait objects）而不是继承来实现多态的不同方法。让我们看看特质对象是如何工作的。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch18-00-oop.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch18-02-trait-objects.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch18-00-oop.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch18-02-trait-objects.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    

</body></html>