<!DOCTYPE html><html lang="zh-CN" class="light sidebar-visible" dir="ltr"><head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>实现面向对象的设计模式 - 《Rust编程语言》</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    <meta name="title" content="Rust 中文"><meta property="og:title" content="Rust 中文"><meta name="description" content="Rust 中文文档"><meta property="og:description" content="Rust 中文文档"><meta name="url" content="https://rust.xheldon.com"><meta property="og:url" content="https://rust.xheldon.com"><script src="https://www.googletagmanager.com/gtag/js?id=G-V7NE1X37EX"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-V7NE1X37EX')</script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486286026923411"></script><style>/* hover 显示原文 */
p[data-x-en],
li[data-x-en] {
  position: relative;
}
p[data-x-en]:hover::after,
li[data-x-en]:hover::after {
  visibility: visible;
  opacity: 1;
}
p[data-x-en]::after,
li[data-x-en]::after {
  content: attr(data-x-en);
  display: block;
  font-size: 12px;
  transition: all 0.2s 0.3s;
  visibility: hidden;
  opacity: 0;
  background: var(--searchbar-bg);
  z-index: 99;
  border-radius: 4px;
  padding: 5px 10px;
  position: absolute;
  top: 100%;
  left: 0;
}
/* 译者注释内容 */
div[type='comment'] {
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  background: #eee;
}
div[type='comment']::before {
  content: '译者注: ';
  font-weight: 900;
}
header a.logo {
  position: relative;
}
header a.logo::after {
  content: '中文';
  position: absolute;
  left: calc(100% + 5px);
  font-size: 12px;
  width: 50px;
  top: -5px;
}
#banner-info {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  font-size: 12px;
  padding: 0;
  z-index: 999;
}
#add-info {
  font-size: 14px;
}
blockquote {
  border-left: 5px solid #ccc;
  padding-left: 10px;
  margin-left: 0;
}
.content {
  overflow-y: unset !important;
}
</style></head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky"><div id="banner-info">本文档为 AI + 人工翻译，hover 可以显示原文。当前页翻译有问题？<a style="cursor: pointer;" href="https://github.com/Xheldon/rust-book-cn/blob/main/dict/ch18-03-oo-design-patterns.json" target="_blank">我来翻译！</a></div>
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    <a href="https://github.com/Xheldon/rust-book-cn" target="_blank"><i class="fa fa-language"></i></a><a href="https://www.xheldon.com" target="_blank"><i class="fa fa-id-card"></i></a></div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="implementing-an-object-oriented-design-pattern"><a class="header" href="#implementing-an-object-oriented-design-pattern">实现面向对象的设计模式</a></h2>
<p data-x-en="The state pattern is an object-oriented design pattern. The crux of the pattern is that we define a set of states a value can have internally. The states are represented by a set of state objects, and the value’s behavior changes based on its state. We’re going to work through an example of a blog post struct that has a field to hold its state, which will be a state object from the set “draft,” “review,” or “published.”"><em>状态模式</em> 是一种面向对象的设计模式。该模式的核心在于我们定义了一个值可以内部拥有一组状态。这些状态由一组 <em>状态对象</em> 表示，值的行为会根据其状态而变化。我们将通过一个博客文章结构体的例子来说明，该结构体有一个字段用于保存其状态，该状态对象将从“草稿”、“审核”或“已发布”这组状态中选择。</p>
<p data-x-en="The state objects share functionality: in Rust, of course, we use structs and traits rather than objects and inheritance. Each state object is responsible for its own behavior and for governing when it should change into another state. The value that holds a state object knows nothing about the different behavior of the states or when to transition between states.">状态对象共享功能：在 Rust 中，当然，我们使用结构体和特质而不是对象和继承。每个状态对象负责其自身的行为以及何时应转换为另一种状态。持有状态对象的值对不同状态的行为或何时在状态之间转换一无所知。</p>
<p data-x-en="The advantage of using the state pattern is that, when the business requirements of the program change, we won’t need to change the code of the value holding the state or the code that uses the value. We’ll only need to update the code inside one of the state objects to change its rules or perhaps add more state objects.">使用状态模式的优点是，当程序的业务需求发生变化时，我们不需要更改持有状态的值的代码或使用该值的代码。我们只需要更新状态对象之一内部的代码以更改其规则，或者可能添加更多的状态对象。</p>
<p data-x-en="First we’re going to implement the state pattern in a more traditional object-oriented way, then we’ll use an approach that’s a bit more natural in Rust. Let’s dig in to incrementally implement a blog post workflow using the state pattern.">首先，我们将以一种更传统的面向对象方式实现状态模式，然后我们将使用一种在 Rust 中更为自然的方法。让我们逐步实现使用状态模式的博客文章工作流程。</p>
<p data-x-en="The final functionality will look like this:">最终的功能将如下所示：</p>
<ol>
<li data-x-en="A blog post starts as an empty draft.">一篇博客文章始于一个空白草稿。</li>
<li data-x-en="When the draft is done, a review of the post is requested.">当草稿完成后，请求对帖子进行审查。</li>
<li data-x-en="When the post is approved, it gets published.">当帖子被批准后，它就会发布。</li>
<li data-x-en="Only published blog posts return content to print, so unapproved posts can’t accidentally be published.">只有已发布的博客文章才会返回内容以供打印，因此未获批准的文章不会意外发布。</li>
</ol>
<p data-x-en="Any other changes attempted on a post should have no effect. For example, if we try to approve a draft blog post before we’ve requested a review, the post should remain an unpublished draft.">任何尝试对帖子进行的其他更改都不应产生影响。例如，如果我们尝试在请求审阅之前批准草稿博客文章，文章应保持未发布的草稿状态。</p>
<h3 id="a-traditional-object-oriented-attempt"><a class="header" href="#a-traditional-object-oriented-attempt">一次传统的面向对象尝试</a></h3>
<p data-x-en="There are infinite ways to structure code to solve the same problem, each with different trade-offs. This section’s implementation is more of a traditional object-oriented style, which is possible to write in Rust, but doesn’t take advantage of some of Rust’s strengths. Later, we’ll demonstrate a different solution that still uses the object-oriented design pattern but is structured in a way that might look less familiar to programmers with object-oriented experience. We’ll compare the two solutions to experience the trade-offs of designing Rust code differently than code in other languages.">有无限种方法可以组织代码来解决同一个问题，每种方法都有不同的权衡。本节的实现更偏向于传统的面向对象风格，这在 Rust 中是可能实现的，但并没有充分利用 Rust 的一些优势。稍后，我们将展示一个不同的解决方案，该方案仍然使用面向对象的设计模式，但其结构可能对具有面向对象经验的程序员来说看起来不太熟悉。我们将比较这两种解决方案，以体验用不同于其他语言的方式来设计 Rust 代码的权衡。</p>
<p data-x-en="Listing 18-11 shows this workflow in code form: this is an example usage of the API we’ll implement in a library crate named blog. This won’t compile yet because we haven’t implemented the blog crate.">列表 18-11 以代码形式展示了此工作流程：这是我们将要在名为 <code>blog</code> 的库 crate 中实现的 API 的示例用法。这还不能编译，因为我们还没有实现 <code>blog</code> crate。</p>
<figure class="listing" id="listing-18-11">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre>
<figcaption><a href="#listing-18-11">Listing 18-11</a>: Code that demonstrates the desired behavior we want our <code>blog</code> crate to have</figcaption>
</figure>
<p data-x-en="We want to allow the user to create a new draft blog post with Post::new. We want to allow text to be added to the blog post. If we try to get the post’s content immediately, before approval, we shouldn’t get any text because the post is still a draft. We’ve added assert_eq! in the code for demonstration purposes. An excellent unit test for this would be to assert that a draft blog post returns an empty string from the content method, but we’re not going to write tests for this example.">我们希望允许用户使用 <code>Post::new</code> 创建新的草稿博客文章。我们希望允许向博客文章中添加文本。如果我们试图在批准之前立即获取文章的内容，我们不应该获取任何文本，因为文章仍然是草稿。我们在代码中添加了 <code>assert_eq!</code> 以作演示。一个很好的单元测试是断言草稿博客文章从 <code>content</code> 方法返回一个空字符串，但在这个例子中我们不会编写测试。</p>
<p data-x-en="Next, we want to enable a request for a review of the post, and we want content to return an empty string while waiting for the review. When the post receives approval, it should get published, meaning the text of the post will be returned when content is called.">接下来，我们希望启用对帖子的审查请求，并且在等待审查期间，希望<code>content</code>返回一个空字符串。当帖子获得批准后，它应该被发布，这意味着在调用<code>content</code>时将返回帖子的文本。</p>
<p data-x-en="Notice that the only type we’re interacting with from the crate is the Post type. This type will use the state pattern and will hold a value that will be one of three state objects representing the various states a post can be in—draft, review, or published. Changing from one state to another will be managed internally within the Post type. The states change in response to the methods called by our library’s users on the Post instance, but they don’t have to manage the state changes directly. Also, users can’t make a mistake with the states, such as publishing a post before it’s reviewed.">请注意，我们从 crate 中交互的唯一类型是 <code>Post</code> 类型。这种类型将使用状态模式，并将持有一个值，该值将是表示帖子可以处于的三种状态之一的状态对象——草稿、审核或已发布。从一个状态转换到另一个状态将由 <code>Post</code> 类型内部管理。状态的变化是响应库用户在 <code>Post</code> 实例上调用的方法，但他们不必直接管理状态变化。此外，用户不会在状态上出错，例如在未审核之前发布帖子。</p>
<h4 id="defining-post-and-creating-a-new-instance-in-the-draft-state"><a class="header" href="#defining-post-and-creating-a-new-instance-in-the-draft-state">定义 <code>Post</code> 和在草稿状态下创建新实例</a></h4>
<p data-x-en="Let’s get started on the implementation of the library! We know we need a public Post struct that holds some content, so we’ll start with the definition of the struct and an associated public new function to create an instance of Post, as shown in Listing 18-12. We’ll also make a private State trait that will define the behavior that all state objects for a Post must have.">让我们开始实现这个库！我们知道我们需要一个持有某些内容的公共 <code>Post</code> 结构体，所以我们从定义这个结构体和一个关联的公共 <code>new</code> 函数开始，用于创建 <code>Post</code> 的实例，如清单 18-12 所示。我们还将创建一个私有的 <code>State</code> 特性，它将定义所有 <code>Post</code> 状态对象必须具有的行为。</p>
<p data-x-en="Then Post will hold a trait object of Box<dyn State> inside an Option<T> in a private field named state to hold the state object. You’ll see why the Option<T> is necessary in a bit.">然后 <code>Post</code> 将在名为 <code>state</code> 的私有字段中持有 <code>Box&lt;dyn State&gt;</code> 特性对象，该对象位于 <code>Option&lt;T&gt;</code> 内部。你稍后会看到为什么需要 <code>Option&lt;T&gt;</code>。</p>
<figure class="listing" id="listing-18-12">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}</code></pre>
<figcaption><a href="#listing-18-12">Listing 18-12</a>: Definition of a <code>Post</code> struct and a <code>new</code> function that creates a new <code>Post</code> instance, a <code>State</code> trait, and a <code>Draft</code> struct</figcaption>
</figure>
<p data-x-en="The State trait defines the behavior shared by different post states. The state objects are Draft, PendingReview, and Published, and they will all implement the State trait. For now, the trait doesn’t have any methods, and we’ll start by defining just the Draft state because that is the state we want a post to start in."><code>State</code> 特性定义了不同帖子状态共享的行为。状态对象是 <code>Draft</code>、<code>PendingReview</code> 和 <code>Published</code>，它们都将实现 <code>State</code> 特性。目前，该特性没有任何方法，我们将从定义 <code>Draft</code> 状态开始，因为这是我们希望帖子开始的状态。</p>
<p data-x-en="When we create a new Post, we set its state field to a Some value that holds a Box. This Box points to a new instance of the Draft struct. This ensures that whenever we create a new instance of Post, it will start out as a draft. Because the state field of Post is private, there is no way to create a Post in any other state! In the Post::new function, we set the content field to a new, empty String.">当我们创建一个新的<code>Post</code>时，我们将其<code>state</code>字段设置为一个包含<code>Box</code>的<code>Some</code>值。这个<code>Box</code>指向一个新的<code>Draft</code>结构体实例。这确保了每当我们创建一个新的<code>Post</code>实例时，它都会以草稿状态开始。因为<code>Post</code>的<code>state</code>字段是私有的，所以没有办法创建处于其他状态的<code>Post</code>！在<code>Post::new</code>函数中，我们将<code>content</code>字段设置为一个新的、空的<code>String</code>。</p>
<h4 id="storing-the-text-of-the-post-content"><a class="header" href="#storing-the-text-of-the-post-content">存储帖子内容的文本</a></h4>
<p data-x-en="We saw in Listing 18-11 that we want to be able to call a method named add_text and pass it a &amp;str that is then added as the text content of the blog post. We implement this as a method, rather than exposing the content field as pub, so that later we can implement a method that will control how the content field’s data is read. The add_text method is pretty straightforward, so let’s add the implementation in Listing 18-13 to the impl Post block.">我们在清单 18-11 中看到，我们希望能够调用一个名为 <code>add_text</code> 的方法，并传递一个 <code>&amp;str</code>，然后将其作为博客文章的文本内容添加。我们将其实现为一个方法，而不是将 <code>content</code> 字段公开为 <code>pub</code>，这样我们可以在以后实现一个控制如何读取 <code>content</code> 字段数据的方法。<code>add_text</code> 方法相当简单，因此让我们在 <code>impl Post</code> 块中添加清单 18-13 中的实现。</p>
<figure class="listing" id="listing-18-13">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<figcaption><a href="#listing-18-13">Listing 18-13</a>: Implementing the <code>add_text</code> method to add text to a post’s <code>content</code></figcaption>
</figure>
<p data-x-en="The add_text method takes a mutable reference to self because we’re changing the Post instance that we’re calling add_text on. We then call push_str on the String in content and pass the text argument to add to the saved content. This behavior doesn’t depend on the state the post is in, so it’s not part of the state pattern. The add_text method doesn’t interact with the state field at all, but it is part of the behavior we want to support."><code>add_text</code> 方法接受一个可变的 <code>self</code> 引用，因为我们正在更改调用 <code>add_text</code> 的 <code>Post</code> 实例。然后我们在 <code>content</code> 中的 <code>String</code> 上调用 <code>push_str</code>，并将 <code>text</code> 参数传递给要添加到已保存的 <code>content</code> 中。这种行为不依赖于帖子的状态，因此它不属于状态模式。<code>add_text</code> 方法根本不与 <code>state</code> 字段交互，但它是我们想要支持的行为的一部分。</p>
<h4 id="ensuring-the-content-of-a-draft-post-is-empty"><a class="header" href="#ensuring-the-content-of-a-draft-post-is-empty">确保草稿帖子的内容为空</a></h4>
<p data-x-en="Even after we’ve called add_text and added some content to our post, we still want the content method to return an empty string slice because the post is still in the draft state, as shown on line 7 of Listing 18-11. For now, let’s implement the content method with the simplest thing that will fulfill this requirement: always returning an empty string slice. We’ll change this later once we implement the ability to change a post’s state so it can be published. So far, posts can only be in the draft state, so the post content should always be empty. Listing 18-14 shows this placeholder implementation.">即使在我们调用 <code>add_text</code> 并向帖子添加了一些内容之后，我们仍然希望 <code>content</code> 方法返回一个空字符串切片，因为帖子仍然处于草稿状态，如清单 18-11 的第 7 行所示。现在，让我们用最简单的方法实现 <code>content</code> 方法来满足这个要求：始终返回一个空字符串切片。我们将在实现更改帖子状态以发布的能力后更改这一点。到目前为止，帖子只能处于草稿状态，因此帖子内容应始终为空。清单 18-14 显示了这个占位符实现。</p>
<figure class="listing" id="listing-18-14">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        ""
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<figcaption><a href="#listing-18-14">Listing 18-14</a>: Adding a placeholder implementation for the <code>content</code> method on <code>Post</code> that always returns an empty string slice</figcaption>
</figure>
<p data-x-en="With this added content method, everything in Listing 18-11 up to line 7 works as intended.">有了这个添加的 <code>content</code> 方法，清单 18-11 中直到第 7 行的所有内容都按预期工作。</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="requesting-a-review-of-the-post-changes-its-state"></a></p>
<h4 id="requesting-a-review-changes-the-posts-state"><a class="header" href="#requesting-a-review-changes-the-posts-state">请求审查会改变帖子的状态</a></h4>
<p data-x-en="Next, we need to add functionality to request a review of a post, which should change its state from Draft to PendingReview. Listing 18-15 shows this code.">接下来，我们需要添加请求审查帖子的功能，这应该会将其状态从<code>Draft</code>更改为<code>PendingReview</code>。清单18-15显示了这段代码。</p>
<figure class="listing" id="listing-18-15">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<figcaption><a href="#listing-18-15">Listing 18-15</a>: Implementing <code>request_review</code> methods on <code>Post</code> and the <code>State</code> trait</figcaption>
</figure>
<p data-x-en="We give Post a public method named request_review that will take a mutable reference to self. Then we call an internal request_review method on the current state of Post, and this second request_review method consumes the current state and returns a new state.">我们给 <code>Post</code> 提供一个名为 <code>request_review</code> 的公共方法，该方法将接受一个可变的 <code>self</code> 引用。然后我们在 <code>Post</code> 的当前状态上调用一个内部的 <code>request_review</code> 方法，这个第二个 <code>request_review</code> 方法会消耗当前状态并返回一个新状态。</p>
<p data-x-en="We add the request_review method to the State trait; all types that implement the trait will now need to implement the request_review method. Note that rather than having self, &amp;self, or &amp;mut self as the first parameter of the method, we have self: Box<Self>. This syntax means the method is only valid when called on a Box holding the type. This syntax takes ownership of Box<Self>, invalidating the old state so the state value of the Post can transform into a new state.">我们向 <code>State</code> 特性添加了 <code>request_review</code> 方法；所有实现该特性的类型现在都需要实现 <code>request_review</code> 方法。请注意，方法的第一个参数不是 <code>self</code>、<code>&amp;self</code> 或 <code>&amp;mut self</code>，而是 <code>self: Box&lt;Self&gt;</code>。这种语法意味着该方法仅在持有该类型的 <code>Box</code> 上调用时才有效。这种语法获取了 <code>Box&lt;Self&gt;</code> 的所有权，使旧状态失效，从而使 <code>Post</code> 的状态值可以转换为新状态。</p>
<p data-x-en="To consume the old state, the request_review method needs to take ownership of the state value. This is where the Option in the state field of Post comes in: we call the take method to take the Some value out of the state field and leave a None in its place because Rust doesn’t let us have unpopulated fields in structs. This lets us move the state value out of Post rather than borrowing it. Then we’ll set the post’s state value to the result of this operation.">为了消耗旧状态，<code>request_review</code> 方法需要获取状态值的所有权。这就是 <code>Post</code> 结构体中 <code>state</code> 字段的 <code>Option</code> 发挥作用的地方：我们调用 <code>take</code> 方法从 <code>state</code> 字段中取出 <code>Some</code> 值，并在其位置留下一个 <code>None</code>，因为 Rust 不允许我们在结构体中留下未填充的字段。这使我们能够将 <code>state</code> 值移出 <code>Post</code> 而不是借用它。然后我们将帖子的 <code>state</code> 值设置为此次操作的结果。</p>
<p data-x-en="We need to set state to None temporarily rather than setting it directly with code like self.state = self.state.request_review(); to get ownership of the state value. This ensures Post can’t use the old state value after we’ve transformed it into a new state.">我们需要将<code>state</code>暂时设置为<code>None</code>，而不是直接使用像<code>self.state = self.state.request_review();</code>这样的代码来获取<code>state</code>值的所有权。这确保在我们将旧的<code>state</code>值转换为新状态后，<code>Post</code>不能使用旧的<code>state</code>值。</p>
<p data-x-en="The request_review method on Draft returns a new, boxed instance of a new PendingReview struct, which represents the state when a post is waiting for a review. The PendingReview struct also implements the request_review method but doesn’t do any transformations. Rather, it returns itself because when we request a review on a post already in the PendingReview state, it should stay in the PendingReview state."><code>Draft</code> 上的 <code>request_review</code> 方法返回一个新的、装箱的 <code>PendingReview</code> 结构体的新实例，该结构体表示帖子等待审核的状态。<code>PendingReview</code> 结构体也实现了 <code>request_review</code> 方法，但不执行任何转换。相反，它返回自身，因为在已经处于 <code>PendingReview</code> 状态的帖子上请求审核时，它应该保持在 <code>PendingReview</code> 状态。</p>
<p data-x-en="Now we can start seeing the advantages of the state pattern: the request_review method on Post is the same no matter its state value. Each state is responsible for its own rules.">现在我们可以开始看到状态模式的优势：<code>request_review</code> 方法在 <code>Post</code> 上是相同的，无论其 <code>state</code> 值如何。每个状态都负责自己的规则。</p>
<p data-x-en="We’ll leave the content method on Post as is, returning an empty string slice. We can now have a Post in the PendingReview state as well as in the Draft state, but we want the same behavior in the PendingReview state. Listing 18-11 now works up to line 10!">我们将保留 <code>Post</code> 上的 <code>content</code> 方法，返回一个空字符串切片。我们现在可以有一个处于 <code>PendingReview</code> 状态的 <code>Post</code>，以及处于 <code>Draft</code> 状态的 <code>Post</code>，但我们希望 <code>PendingReview</code> 状态具有相同的行为。列表 18-11 现在可以工作到第 10 行！</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a></p>
<h4 id="adding-approve-to-change-the-behavior-of-content"><a class="header" href="#adding-approve-to-change-the-behavior-of-content">添加 <code>approve</code> 以更改 <code>content</code> 的行为</a></h4>
<p data-x-en="The approve method will be similar to the request_review method: it will set state to the value that the current state says it should have when that state is approved, as shown in Listing 18-16."><code>approve</code> 方法将类似于 <code>request_review</code> 方法：它将把 <code>state</code> 设置为当前状态在被批准时应具有的值，如清单 18-16 所示。</p>
<figure class="listing" id="listing-18-16">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<figcaption><a href="#listing-18-16">Listing 18-16</a>: Implementing the <code>approve</code> method on <code>Post</code> and the <code>State</code> trait</figcaption>
</figure>
<p data-x-en="We add the approve method to the State trait and add a new struct that implements State, the Published state.">我们向 <code>State</code> 特性添加 <code>approve</code> 方法，并添加一个新的结构体来实现 <code>State</code>，即 <code>Published</code> 状态。</p>
<p data-x-en="Similar to the way request_review on PendingReview works, if we call the approve method on a Draft, it will have no effect because approve will return self. When we call approve on PendingReview, it returns a new, boxed instance of the Published struct. The Published struct implements the State trait, and for both the request_review method and the approve method, it returns itself because the post should stay in the Published state in those cases.">类似于 <code>PendingReview</code> 上的 <code>request_review</code> 方法，如果我们调用 <code>Draft</code> 上的 <code>approve</code> 方法，它将不会产生任何效果，因为 <code>approve</code> 会返回 <code>self</code>。当我们调用 <code>PendingReview</code> 上的 <code>approve</code> 方法时，它会返回一个新的、装箱的 <code>Published</code> 结构体实例。<code>Published</code> 结构体实现了 <code>State</code> 特性，对于 <code>request_review</code> 方法和 <code>approve</code> 方法，它都会返回自身，因为在这些情况下，帖子应该保持在 <code>Published</code> 状态。</p>
<p data-x-en="Now we need to update the content method on Post. We want the value returned from content to depend on the current state of the Post, so we’re going to have the Post delegate to a content method defined on its state, as shown in Listing 18-17.">现在我们需要更新 <code>Post</code> 上的 <code>content</code> 方法。我们希望从 <code>content</code> 返回的值取决于 <code>Post</code> 的当前状态，因此我们将让 <code>Post</code> 委托给其 <code>state</code> 上定义的 <code>content</code> 方法，如清单 18-17 所示。</p>
<figure class="listing" id="listing-18-17">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-18-17">Listing 18-17</a>: Updating the <code>content</code> method on <code>Post</code> to delegate to a <code>content</code> method on <code>State</code></figcaption>
</figure>
<p data-x-en="Because the goal is to keep all of these rules inside the structs that implement State, we call a content method on the value in state and pass the post instance (that is, self) as an argument. Then we return the value that’s returned from using the content method on the state value.">因为目标是将所有这些规则保留在实现 <code>State</code> 的结构体内部，所以我们对 <code>state</code> 中的值调用 <code>content</code> 方法，并将帖子实例（即 <code>self</code>）作为参数传递。然后我们返回使用 <code>content</code> 方法对 <code>state</code> 值调用后返回的值。</p>
<p data-x-en="We call the as_ref method on the Option because we want a reference to the value inside the Option rather than ownership of the value. Because state is an Option<Box<dyn State>>, when we call as_ref, an Option<&amp;Box<dyn State>> is returned. If we didn’t call as_ref, we would get an error because we can’t move state out of the borrowed &amp;self of the function parameter.">我们对 <code>Option</code> 调用 <code>as_ref</code> 方法是因为我们想要获取 <code>Option</code> 内部值的引用而不是值的所有权。因为 <code>state</code> 是一个 <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>，当我们调用 <code>as_ref</code> 时，返回的是一个 <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code>。如果我们不调用 <code>as_ref</code>，我们会得到一个错误，因为我们不能从函数参数的借用 <code>&amp;self</code> 中移动 <code>state</code>。</p>
<p data-x-en="We then call the unwrap method, which we know will never panic because we know the methods on Post ensure that state will always contain a Some value when those methods are done. This is one of the cases we talked about in “Cases in Which You Have More Information Than the Compiler” in Chapter 9 when we know that a None value is never possible, even though the compiler isn’t able to understand that.">然后我们调用 <code>unwrap</code> 方法，我们知道它永远不会 panic，因为我们知道 <code>Post</code> 上的方法确保当这些方法执行完毕时，<code>state</code> 始终会包含一个 <code>Some</code> 值。这是我们在 <a href="ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">“你比编译器拥有更多信息的情况”</a><!-- ignore --> 第 9 章中讨论的一种情况，即我们知道 <code>None</code> 值是不可能的，即使编译器无法理解这一点。</p>
<p data-x-en="At this point, when we call content on the &amp;Box<dyn State>, deref coercion will take effect on the &amp; and the Box so the content method will ultimately be called on the type that implements the State trait. That means we need to add content to the State trait definition, and that is where we’ll put the logic for what content to return depending on which state we have, as shown in Listing 18-18.">在这个时候，当我们对 <code>&amp;Box&lt;dyn State&gt;</code> 调用 <code>content</code> 时，解引用强制会作用于 <code>&amp;</code> 和 <code>Box</code>，因此 <code>content</code> 方法最终会被调用在实现了 <code>State</code> 特性的类型上。这意味着我们需要将 <code>content</code> 添加到 <code>State</code> 特性定义中，这就是我们将根据所处的状态来决定返回什么内容的逻辑放置的地方，如清单 18-18 所示。</p>
<figure class="listing" id="listing-18-18">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        ""
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}</code></pre>
<figcaption><a href="#listing-18-18">Listing 18-18</a>: Adding the <code>content</code> method to the <code>State</code> trait</figcaption>
</figure>
<p data-x-en="We add a default implementation for the content method that returns an empty string slice. That means we don’t need to implement content on the Draft and PendingReview structs. The Published struct will override the content method and return the value in post.content. While convenient, having the content method on State determine the content of the Post is blurring the lines between the responsibility of State and the responsibility of Post.">我们为<code>content</code>方法添加了一个默认实现，返回一个空的字符串切片。这意味着我们不需要在<code>Draft</code>和<code>PendingReview</code>结构体上实现<code>content</code>。<code>Published</code>结构体将覆盖<code>content</code>方法并返回<code>post.content</code>中的值。虽然方便，但让<code>State</code>上的<code>content</code>方法决定<code>Post</code>的内容是在模糊<code>State</code>和<code>Post</code>职责之间的界限。</p>
<p data-x-en="Note that we need lifetime annotations on this method, as we discussed in Chapter 10. We’re taking a reference to a post as an argument and returning a reference to part of that post, so the lifetime of the returned reference is related to the lifetime of the post argument.">请注意，我们需要在这个方法上添加生命周期注解，正如我们在第10章中讨论的那样。我们接受一个对<code>post</code>的引用作为参数，并返回该<code>post</code>的一部分的引用，因此返回的引用的生命周期与<code>post</code>参数的生命周期相关。</p>
<p data-x-en="And we’re done—all of Listing 18-11 now works! We’ve implemented the state pattern with the rules of the blog post workflow. The logic related to the rules lives in the state objects rather than being scattered throughout Post.">而且我们完成了—清单 18-11 现在全部可以工作了！我们已经使用博客文章工作流的规则实现了状态模式。与规则相关的逻辑存在于状态对象中，而不是分散在 <code>Post</code> 中。</p>
<section class="note" aria-role="note">
<h3 id="why-not-an-enum"><a class="header" href="#why-not-an-enum">为什么不使用枚举？</a></h3>
<p data-x-en="You may have been wondering why we didn’t use an enum with the different possible post states as variants. That’s certainly a possible solution; try it and compare the end results to see which you prefer! One disadvantage of using an enum is that every place that checks the value of the enum will need a match expression or similar to handle every possible variant. This could get more repetitive than this trait object solution.">你可能一直在想为什么我们没有使用一个<code>enum</code>，将不同的帖子状态作为变体。这当然是一种可能的解决方案；尝试一下并比较最终结果，看看你更喜欢哪个！使用枚举的一个缺点是，每个检查枚举值的地方都需要一个<code>match</code>表达式或类似的方法来处理每个可能的变体。这可能会比这个特质对象解决方案更重复。</p>
</section>
<h4 id="trade-offs-of-the-state-pattern"><a class="header" href="#trade-offs-of-the-state-pattern">状态模式的权衡</a></h4>
<p data-x-en="We’ve shown that Rust is capable of implementing the object-oriented state pattern to encapsulate the different kinds of behavior a post should have in each state. The methods on Post know nothing about the various behaviors. The way we organized the code, we have to look in only one place to know the different ways a published post can behave: the implementation of the State trait on the Published struct.">我们已经证明了Rust能够实现面向对象的状态模式，以封装帖子在每个状态下应具有的不同行为。<code>Post</code>上的方法对各种行为一无所知。我们组织代码的方式，只需要查看一个地方就可以知道已发布帖子的不同行为：<code>Published</code>结构体上<code>State</code>特征的实现。</p>
<p data-x-en="If we were to create an alternative implementation that didn’t use the state pattern, we might instead use match expressions in the methods on Post or even in the main code that checks the state of the post and changes behavior in those places. That would mean we would have to look in several places to understand all the implications of a post being in the published state.">如果我们创建一个不使用状态模式的替代实现，我们可能会在 <code>Post</code> 的方法中或甚至在检查帖子状态并在此处更改行为的 <code>main</code> 代码中使用 <code>match</code> 表达式。这意味着我们必须查看多个地方才能理解帖子处于已发布状态的所有影响。</p>
<p data-x-en="With the state pattern, the Post methods and the places we use Post don’t need match expressions, and to add a new state, we would only need to add a new struct and implement the trait methods on that one struct in one location.">使用状态模式，<code>Post</code> 方法和使用 <code>Post</code> 的地方不需要 <code>match</code> 表达式，要添加一个新状态，我们只需要添加一个新的结构体并在该结构体上实现特质方法。</p>
<p data-x-en="The implementation using the state pattern is easy to extend to add more functionality. To see the simplicity of maintaining code that uses the state pattern, try a few of these suggestions:">使用状态模式的实现很容易扩展以添加更多功能。要了解使用状态模式维护代码的简单性，请尝试以下一些建议：</p>
<ul>
<li data-x-en="Add a reject method that changes the post’s state from PendingReview back to Draft.">添加一个 <code>reject</code> 方法，将帖子的状态从 <code>PendingReview</code> 变回 <code>Draft</code>。</li>
<li data-x-en="Require two calls to approve before the state can be changed to Published.">需要两次调用 <code>approve</code> 才能将状态更改为 <code>Published</code>。</li>
<li data-x-en="Allow users to add text content only when a post is in the Draft state. Hint: have the state object responsible for what might change about the content but not responsible for modifying the Post.">允许用户仅在帖子处于<code>Draft</code>状态时添加文本内容。
提示：让状态对象负责内容可能发生的变化，但不负责修改<code>Post</code>。</li>
</ul>
<p data-x-en="One downside of the state pattern is that, because the states implement the transitions between states, some of the states are coupled to each other. If we add another state between PendingReview and Published, such as Scheduled, we would have to change the code in PendingReview to transition to Scheduled instead. It would be less work if PendingReview didn’t need to change with the addition of a new state, but that would mean switching to another design pattern.">状态模式的一个缺点是，由于状态实现了状态之间的转换，某些状态之间是耦合的。如果我们添加一个在 <code>PendingReview</code> 和 <code>Published</code> 之间的新状态，例如 <code>Scheduled</code>，我们不得不更改 <code>PendingReview</code> 中的代码以转换到 <code>Scheduled</code>。如果 <code>PendingReview</code> 不需要随着新状态的添加而改变，工作量会更小，但这意味着需要切换到另一种设计模式。</p>
<p data-x-en="Another downside is that we’ve duplicated some logic. To eliminate some of the duplication, we might try to make default implementations for the request_review and approve methods on the State trait that return self. However, this wouldn’t work: when using State as a trait object, the trait doesn’t know what the concrete self will be exactly, so the return type isn’t known at compile time. (This is one of the dyn compatibility rules mentioned earlier.)">另一个缺点是我们复制了一些逻辑。为了减少一些重复，我们可能会尝试为 <code>State</code> 特性上的 <code>request_review</code> 和 <code>approve</code> 方法提供默认实现，这些方法返回 <code>self</code>。然而，这行不通：当将 <code>State</code> 用作特性对象时，特性不知道具体的 <code>self</code> 会是什么，因此返回类型在编译时是未知的。（这是前面提到的 <code>dyn</code> 兼容性规则之一。）</p>
<p data-x-en="Other duplication includes the similar implementations of the request_review and approve methods on Post. Both methods use Option::take with the state field of Post, and if state is Some, they delegate to the wrapped value’s implementation of the same method and set the new value of the state field to the result. If we had a lot of methods on Post that followed this pattern, we might consider defining a macro to eliminate the repetition (see “Macros” in Chapter 20).">其他重复包括 <code>Post</code> 上 <code>request_review</code> 和 <code>approve</code> 方法的类似实现。这两个方法都使用 <code>Option::take</code> 与 <code>Post</code> 的 <code>state</code> 字段，如果 <code>state</code> 是 <code>Some</code>，它们会委托给包装值的同名方法的实现，并将 <code>state</code> 字段的新值设置为结果。如果我们有很多遵循这种模式的 <code>Post</code> 方法，我们可能会考虑定义一个宏来消除重复（参见<a href="ch20-05-macros.html#macros">“宏”</a><!-- ignore --> 第20章）。</p>
<p data-x-en="By implementing the state pattern exactly as it’s defined for object-oriented languages, we’re not taking as full advantage of Rust’s strengths as we could. Let’s look at some changes we can make to the blog crate that can make invalid states and transitions into compile-time errors.">通过完全按照面向对象语言中定义的状态模式实现，我们并没有充分利用 Rust 的优势。让我们看看可以对 <code>blog</code> crate 做一些什么改动，以便将无效状态和转换变成编译时错误。</p>
<h3 id="encoding-states-and-behavior-as-types"><a class="header" href="#encoding-states-and-behavior-as-types">将状态和行为编码为类型</a></h3>
<p data-x-en="We’ll show you how to rethink the state pattern to get a different set of trade-offs. Rather than encapsulating the states and transitions completely so outside code has no knowledge of them, we’ll encode the states into different types. Consequently, Rust’s type checking system will prevent attempts to use draft posts where only published posts are allowed by issuing a compiler error.">我们将向您展示如何重新思考状态模式以获得不同的权衡。而不是完全封装状态和转换，使外部代码对它们一无所知，我们将状态编码为不同的类型。因此，Rust 的类型检查系统将通过发出编译器错误来防止在仅允许已发布帖子的地方使用草稿帖子。</p>
<p data-x-en="Let’s consider the first part of main in Listing 18-11:">让我们考虑一下清单 18-11 中 <code>main</code> 的第一部分：</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!("", post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!("I ate a salad for lunch today", post.content());
</span>}</code></pre>
</figure>
<p data-x-en="We still enable the creation of new posts in the draft state using Post::new and the ability to add text to the post’s content. But instead of having a content method on a draft post that returns an empty string, we’ll make it so draft posts don’t have the content method at all. That way, if we try to get a draft post’s content, we’ll get a compiler error telling us the method doesn’t exist. As a result, it will be impossible for us to accidentally display draft post content in production because that code won’t even compile. Listing 18-19 shows the definition of a Post struct and a DraftPost struct, as well as methods on each.">我们仍然允许使用 <code>Post::new</code> 创建新的草稿状态的帖子，并且可以向帖子内容中添加文本。但是，我们不再为草稿帖子提供返回空字符串的 <code>content</code> 方法，而是完全不为草稿帖子提供 <code>content</code> 方法。这样一来，如果我们尝试获取草稿帖子的内容，将会得到一个编译器错误，提示该方法不存在。因此，我们不可能在生产环境中意外显示草稿帖子的内容，因为那段代码根本无法编译。清单 18-19 显示了 <code>Post</code> 结构体和 <code>DraftPost</code> 结构体的定义，以及每个结构体上的方法。</p>
<figure class="listing" id="listing-18-19">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}</code></pre>
<figcaption><a href="#listing-18-19">Listing 18-19</a>: A <code>Post</code> with a <code>content</code> method and <code>DraftPost</code> without a <code>content</code> method</figcaption>
</figure>
<p data-x-en="Both the Post and DraftPost structs have a private content field that stores the blog post text. The structs no longer have the state field because we’re moving the encoding of the state to the types of the structs. The Post struct will represent a published post, and it has a content method that returns the content."><code>Post</code> 和 <code>DraftPost</code> 结构体都有一个私有的 <code>content</code> 字段，用于存储博客文章的文本。这些结构体不再有 <code>state</code> 字段，因为我们正在将状态的编码转移到结构体的类型上。<code>Post</code> 结构体将表示已发布的文章，并且它有一个 <code>content</code> 方法，用于返回 <code>content</code>。</p>
<p data-x-en="We still have a Post::new function, but instead of returning an instance of Post, it returns an instance of DraftPost. Because content is private and there aren’t any functions that return Post, it’s not possible to create an instance of Post right now.">我们仍然有一个 <code>Post::new</code> 函数，但它返回的是 <code>DraftPost</code> 的实例，而不是 <code>Post</code> 的实例。因为 <code>content</code> 是私有的，并且没有返回 <code>Post</code> 的函数，所以目前无法创建 <code>Post</code> 的实例。</p>
<p data-x-en="The DraftPost struct has an add_text method, so we can add text to content as before, but note that DraftPost does not have a content method defined! So now the program ensures all posts start as draft posts, and draft posts don’t have their content available for display. Any attempt to get around these constraints will result in a compiler error."><code>DraftPost</code> 结构体有一个 <code>add_text</code> 方法，因此我们可以像以前一样向 <code>content</code> 添加文本，但请注意，<code>DraftPost</code> 没有定义 <code>content</code> 方法！因此，现在程序确保所有帖子都以草稿形式开始，而草稿帖子的内容无法显示。任何试图绕过这些限制的行为都会导致编译错误。</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="implementing-transitions-as-transformations-into-different-types"></a></p>
<p data-x-en="So how do we get a published post? We want to enforce the rule that a draft post has to be reviewed and approved before it can be published. A post in the pending review state should still not display any content. Let’s implement these constraints by adding another struct, PendingReviewPost, defining the request_review method on DraftPost to return a PendingReviewPost and defining an approve method on PendingReviewPost to return a Post, as shown in Listing 18-20.">那么我们如何获得一个已发布的帖子呢？我们希望强制执行这样的规则：草稿帖子必须经过审核和批准后才能发布。处于待审核状态的帖子仍然不应显示任何内容。让我们通过添加另一个结构体<code>PendingReviewPost</code>来实现这些约束，在<code>DraftPost</code>上定义<code>request_review</code>方法以返回一个<code>PendingReviewPost</code>，并在<code>PendingReviewPost</code>上定义一个<code>approve</code>方法以返回一个<code>Post</code>，如清单18-20所示。</p>
<figure class="listing" id="listing-18-20">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}</code></pre>
<figcaption><a href="#listing-18-20">Listing 18-20</a>: A <code>PendingReviewPost</code> that gets created by calling <code>request_review</code> on <code>DraftPost</code> and an <code>approve</code> method that turns a <code>PendingReviewPost</code> into a published <code>Post</code></figcaption>
</figure>
<p data-x-en="The request_review and approve methods take ownership of self, thus consuming the DraftPost and PendingReviewPost instances and transforming them into a PendingReviewPost and a published Post, respectively. This way, we won’t have any lingering DraftPost instances after we’ve called request_review on them, and so forth. The PendingReviewPost struct doesn’t have a content method defined on it, so attempting to read its content results in a compiler error, as with DraftPost. Because the only way to get a published Post instance that does have a content method defined is to call the approve method on a PendingReviewPost, and the only way to get a PendingReviewPost is to call the request_review method on a DraftPost, we’ve now encoded the blog post workflow into the type system."><code>request_review</code> 和 <code>approve</code> 方法获取 <code>self</code> 的所有权，因此
消耗了 <code>DraftPost</code> 和 <code>PendingReviewPost</code> 实例，并将它们分别转换为
<code>PendingReviewPost</code> 和已发布的 <code>Post</code>。这样，
在我们对它们调用 <code>request_review</code> 之后，就不会有任何剩余的 <code>DraftPost</code> 实例，依此类推。<code>PendingReviewPost</code> 结构体上没有定义 <code>content</code> 方法，因此尝试读取其内容
会导致编译器错误，就像 <code>DraftPost</code> 一样。因为只有通过调用
<code>approve</code> 方法在 <code>PendingReviewPost</code> 上才能获得一个已发布的 <code>Post</code> 实例，而该实例定义了 <code>content</code> 方法，且获得 <code>PendingReviewPost</code> 的唯一方法是调用 <code>request_review</code> 方法在 <code>DraftPost</code> 上，
我们现在已将博客文章的工作流程编码到类型系统中。</p>
<p data-x-en="But we also have to make some small changes to main. The request_review and approve methods return new instances rather than modifying the struct they’re called on, so we need to add more let post = shadowing assignments to save the returned instances. We also can’t have the assertions about the draft and pending review posts’ contents be empty strings, nor do we need them: we can’t compile code that tries to use the content of posts in those states any longer. The updated code in main is shown in Listing 18-21.">但我们还需要对 <code>main</code> 做一些小的修改。<code>request_review</code> 和 <code>approve</code> 方法返回新的实例而不是修改它们被调用的结构体，因此我们需要添加更多的 <code>let post =</code> 隐藏赋值来保存返回的实例。我们也不能再有关于草稿和待审帖子内容为空字符串的断言，我们也不需要它们：我们不能再编译尝试使用这些状态帖子内容的代码。更新后的 <code>main</code> 代码如清单 18-21 所示。</p>
<figure class="listing" id="listing-18-21">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre>
<figcaption><a href="#listing-18-21">Listing 18-21</a>: Modifications to <code>main</code> to use the new implementation of the blog post workflow</figcaption>
</figure>
<p data-x-en="The changes we needed to make to main to reassign post mean that this implementation doesn’t quite follow the object-oriented state pattern anymore: the transformations between the states are no longer encapsulated entirely within the Post implementation. However, our gain is that invalid states are now impossible because of the type system and the type checking that happens at compile time! This ensures that certain bugs, such as display of the content of an unpublished post, will be discovered before they make it to production.">我们需要对 <code>main</code> 进行的更改以重新分配 <code>post</code> 意味着这种实现不再完全遵循面向对象的状态模式：状态之间的转换不再完全封装在 <code>Post</code> 实现中。然而，我们的收获是，由于类型系统和编译时的类型检查，现在不可能出现无效状态！这确保了某些错误（例如显示未发布帖子的内容）在进入生产环境之前就会被发现。</p>
<p data-x-en="Try the tasks suggested at the start of this section on the blog crate as it is after Listing 18-21 to see what you think about the design of this version of the code. Note that some of the tasks might be completed already in this design.">尝试本节开头建议的任务，针对列表 18-21 之后的 <code>blog</code> crate，看看你对这个版本代码的设计有什么看法。请注意，某些任务在这个设计中可能已经完成。</p>
<p data-x-en="We’ve seen that even though Rust is capable of implementing object-oriented design patterns, other patterns, such as encoding state into the type system, are also available in Rust. These patterns have different trade-offs. Although you might be very familiar with object-oriented patterns, rethinking the problem to take advantage of Rust’s features can provide benefits, such as preventing some bugs at compile time. Object-oriented patterns won’t always be the best solution in Rust due to certain features, like ownership, that object-oriented languages don’t have.">我们已经看到，尽管 Rust 能够实现面向对象的设计模式，但其他模式，如将状态编码到类型系统中，在 Rust 中也是可用的。这些模式有不同的权衡。虽然你可能非常熟悉面向对象的模式，但重新思考问题以利用 Rust 的特性可以带来好处，例如在编译时防止某些错误。由于某些特性（如所有权）是面向对象语言所没有的，因此面向对象的模式在 Rust 中并不总是最佳解决方案。</p>
<h2 id="summary"><a class="header" href="#summary">摘要</a></h2>
<p data-x-en="Regardless of whether you think Rust is an object-oriented language after reading this chapter, you now know that you can use trait objects to get some object-oriented features in Rust. Dynamic dispatch can give your code some flexibility in exchange for a bit of runtime performance. You can use this flexibility to implement object-oriented patterns that can help your code’s maintainability. Rust also has other features, like ownership, that object-oriented languages don’t have. An object-oriented pattern won’t always be the best way to take advantage of Rust’s strengths, but it is an available option.">无论你在阅读本章后是否认为Rust是一种面向对象的语言，你现在知道你可以使用特征对象在Rust中获得一些面向对象的特性。动态分发可以让你的代码在牺牲一些运行时性能的情况下获得一定的灵活性。你可以利用这种灵活性来实现有助于代码可维护性的面向对象模式。Rust还具有其他面向对象语言所没有的特性，如所有权。面向对象的模式并不总是利用Rust优势的最佳方式，但它是一个可用的选项。</p>
<p data-x-en="Next, we’ll look at patterns, which are another of Rust’s features that enable lots of flexibility. We’ve looked at them briefly throughout the book but haven’t seen their full capability yet. Let’s go!">接下来，我们将研究模式，这是 Rust 的另一个特性，它提供了很大的灵活性。我们在书中简要地看过它们，但还没有看到它们的全部功能。让我们开始吧！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch18-02-trait-objects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch19-00-patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch18-02-trait-objects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch19-00-patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    

</body></html>