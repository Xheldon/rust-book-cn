<!DOCTYPE html><html lang="zh-CN" class="light sidebar-visible" dir="ltr"><head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>模式语法 - 《Rust 编程语言》</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    <meta name="title" content="Rust 中文"><meta property="og:title" content="Rust 中文"><meta name="description" content="Rust 中文文档"><meta property="og:description" content="Rust 中文文档"><meta name="url" content="https://rust.xheldon.com"><meta property="og:url" content="https://rust.xheldon.com"><script src="https://www.googletagmanager.com/gtag/js?id=G-V7NE1X37EX"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-V7NE1X37EX')</script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486286026923411"></script><style>/* hover 显示原文 */
p[data-x-en],
li[data-x-en] {
  position: relative;
}
p[data-x-en]:hover::after,
li[data-x-en]:hover::after {
  visibility: visible;
  opacity: 1;
}
p[data-x-en]::after,
li[data-x-en]::after {
  content: attr(data-x-en);
  display: block;
  font-size: 12px;
  transition: all 0.2s 0.3s;
  visibility: hidden;
  opacity: 0;
  background: var(--searchbar-bg);
  z-index: 99;
  border-radius: 4px;
  padding: 5px 10px;
  position: absolute;
  top: 100%;
  left: 0;
}
/* 译者注释内容 */
div[type='comment'] {
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  background: #eee;
}
div[type='comment']::before {
  content: '译者注: ';
  font-weight: 900;
}
header a.logo {
  position: relative;
}
header a.logo::after {
  content: '中文';
  position: absolute;
  left: calc(100% + 5px);
  font-size: 12px;
  width: 50px;
  top: -5px;
}
#banner-info {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  font-size: 12px;
  padding: 0;
  z-index: 999;
}
#add-info {
  font-size: 14px;
}
blockquote {
  border-left: 5px solid #ccc;
  padding-left: 10px;
  margin-left: 0;
}
.content {
  overflow-y: unset !important;
}
</style></head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky"><div id="banner-info">本文档为 AI + 人工翻译，hover 可以显示原文。当前页翻译有问题？<a style="cursor: pointer;" href="https://github.com/Xheldon/rust-book-cn/blob/main/dict/ch19-03-pattern-syntax.json" target="_blank">我来翻译！</a></div>
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    <a href="https://github.com/Xheldon/rust-book-cn" target="_blank"><i class="fa fa-language"></i></a><a href="https://www.xheldon.com" target="_blank"><i class="fa fa-id-card"></i></a></div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="pattern-syntax"><a class="header" href="#pattern-syntax">模式语法</a></h2>
<p data-x-en="In this section, we gather all the syntax valid in patterns and discuss why and when you might want to use each one.">在本节中，我们收集了所有在模式中有效的语法，并讨论了为什么以及何时可能需要使用每一种。</p>
<h3 id="matching-literals"><a class="header" href="#matching-literals">匹配字面量</a></h3>
<p data-x-en="As you saw in Chapter 6, you can match patterns against literals directly. The following code gives some examples:">正如你在第 6 章中看到的，你可以直接将模式与字面量匹配。以下代码给出了一些示例：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p data-x-en="This code prints one because the value in x is 1. This syntax is useful when you want your code to take an action if it gets a particular concrete value.">这段代码打印<code>one</code>，因为<code>x</code>中的值是1。当您希望代码在获得特定的具体值时采取行动时，这种语法非常有用。</p>
<h3 id="matching-named-variables"><a class="header" href="#matching-named-variables">匹配命名变量</a></h3>
<p data-x-en="Named variables are irrefutable patterns that match any value, and we’ve used them many times in the book. However, there is a complication when you use named variables in match, if let, or while let expressions. Because each of these kinds of expression starts a new scope, variables declared as part of a pattern inside the expression will shadow those with the same name outside, as is the case with all variables. In Listing 19-11, we declare a variable named x with the value Some(5) and a variable y with the value 10. We then create a match expression on the value x. Look at the patterns in the match arms and println! at the end, and try to figure out what the code will print before running this code or reading further.">命名变量是不可反驳的模式，可以匹配任何值，我们在书中多次使用了它们。然而，当你在 <code>match</code>、<code>if let</code> 或 <code>while let</code> 表达式中使用命名变量时，会出现一个复杂情况。因为这些表达式中的每一种都会开始一个新的作用域，所以在表达式内部作为模式声明的变量会遮蔽外部同名的变量，这与所有变量的情况一样。在清单 19-11 中，我们声明了一个名为 <code>x</code> 的变量，其值为 <code>Some(5)</code>，以及一个值为 <code>10</code> 的变量 <code>y</code>。然后，我们对值 <code>x</code> 创建了一个 <code>match</code> 表达式。查看匹配臂中的模式和最后的 <code>println!</code>，并尝试在运行此代码或继续阅读之前，弄清楚代码将打印什么。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(y) =&gt; println!("Matched, y = {y}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-11: A <code>match</code> expression with an arm that introduces a new variable which shadows an existing variable <code>y</code></figcaption>
</figure>
<p data-x-en="Let’s walk through what happens when the match expression runs. The pattern in the first match arm doesn’t match the defined value of x, so the code continues.">让我们逐步了解当 <code>match</code> 表达式运行时发生了什么。第一个匹配臂中的模式与定义的 <code>x</code> 值不匹配，因此代码继续执行。</p>
<p data-x-en="The pattern in the second match arm introduces a new variable named y that will match any value inside a Some value. Because we’re in a new scope inside the match expression, this is a new y variable, not the y we declared at the beginning with the value 10. This new y binding will match any value inside a Some, which is what we have in x. Therefore, this new y binds to the inner value of the Some in x. That value is 5, so the expression for that arm executes and prints Matched, y = 5.">第二个匹配臂中的模式引入了一个名为 <code>y</code> 的新变量，该变量将匹配 <code>Some</code> 值中的任何值。因为我们处于 <code>match</code> 表达式内的新作用域中，这是一个新的 <code>y</code> 变量，而不是我们在开头声明的值为 10 的 <code>y</code>。这个新的 <code>y</code> 绑定将匹配 <code>Some</code> 中的任何值，这正是我们在 <code>x</code> 中所拥有的。因此，这个新的 <code>y</code> 绑定到 <code>x</code> 中 <code>Some</code> 的内部值。该值为 <code>5</code>，所以该臂的表达式执行并打印 <code>Matched, y = 5</code>。</p>
<p data-x-en="If x had been a None value instead of Some(5), the patterns in the first two arms wouldn’t have matched, so the value would have matched to the underscore. We didn’t introduce the x variable in the pattern of the underscore arm, so the x in the expression is still the outer x that hasn’t been shadowed. In this hypothetical case, the match would print Default case, x = None.">如果 <code>x</code> 是一个 <code>None</code> 值而不是 <code>Some(5)</code>，前两个分支的模式将不会匹配，因此值将匹配到下划线。我们在下划线分支的模式中没有引入 <code>x</code> 变量，因此表达式中的 <code>x</code> 仍然是未被遮蔽的外部 <code>x</code>。在这种假设情况下，<code>match</code> 将会打印 <code>Default case, x = None</code>。</p>
<p data-x-en="When the match expression is done, its scope ends, and so does the scope of the inner y. The last println! produces at the end: x = Some(5), y = 10.">当 <code>match</code> 表达式结束时，其作用域结束，内部的 <code>y</code> 的作用域也随之结束。最后一个 <code>println!</code> 产生 <code>at the end: x = Some(5), y = 10</code>。</p>
<p data-x-en="To create a match expression that compares the values of the outer x and y, rather than introducing a new variable which shadows the existing y variable, we would need to use a match guard conditional instead. We’ll talk about match guards later in the “Extra Conditionals with Match Guards” section.">要创建一个比较外部 <code>x</code> 和 <code>y</code> 值的 <code>match</code> 表达式，而不是引入一个新的变量来遮盖现有的 <code>y</code> 变量，我们需要使用匹配卫条件。我们将在 <a href="#extra-conditionals-with-match-guards">“使用匹配卫条件的额外条件”</a> 部分讨论匹配卫条件。</p>
<h3 id="multiple-patterns"><a class="header" href="#multiple-patterns">多个模式</a></h3>
<p data-x-en="You can match multiple patterns using the | syntax, which is the pattern or operator. For example, in the following code we match the value of x against the match arms, the first of which has an or option, meaning if the value of x matches either of the values in that arm, that arm’s code will run:">您可以使用 <code>|</code> 语法匹配多个模式，这是模式 <em>或</em>
运算符。例如，在以下代码中，我们根据 <code>x</code> 的值进行匹配，其中第一个匹配臂有一个 <em>或</em> 选项，这意味着如果 <code>x</code> 的值与该臂中的任何一个值匹配，该臂的代码将运行：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!("one or two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p data-x-en="This code prints one or two.">这段代码打印<code>one or two</code>。</p>
<h3 id="matching-ranges-of-values-with-"><a class="header" href="#matching-ranges-of-values-with-">使用 <code>..=</code> 匹配值的范围</a></h3>
<p data-x-en="The ..= syntax allows us to match to an inclusive range of values. In the following code, when a pattern matches any of the values within the given range, that arm will execute:"><code>..=</code> 语法允许我们匹配一个包含范围内的值。在以下代码中，当模式匹配给定范围内的任何值时，该分支将执行：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!("one through five"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p data-x-en="If x is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient for multiple match values than using the | operator to express the same idea; if we were to use | we would have to specify 1 | 2 | 3 | 4 | 5. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!">如果 <code>x</code> 是 1、2、3、4 或 5，第一个分支将匹配。这种语法对于多个匹配值来说比使用 <code>|</code> 运算符表达相同的概念更方便；如果我们使用 <code>|</code>，则必须指定 <code>1 | 2 | 3 | 4 | 5</code>。指定一个范围要短得多，特别是如果我们想匹配，比如说，1 到 1,000 之间的任何数字！</p>
<p data-x-en="The compiler checks that the range isn’t empty at compile time, and because the only types for which Rust can tell if a range is empty or not are char and numeric values, ranges are only allowed with numeric or char values.">编译器在编译时检查范围是否为空，因为只有对于 <code>char</code> 和数值类型，Rust 才能判断一个范围是否为空，所以范围仅允许使用数值或 <code>char</code> 值。</p>
<p data-x-en="Here is an example using ranges of char values:">这里是一个使用 <code>char</code> 值范围的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!("early ASCII letter"),
        'k'..='z' =&gt; println!("late ASCII letter"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p data-x-en="Rust can tell that 'c' is within the first pattern’s range and prints early ASCII letter.">Rust 可以判断出 <code>'c'</code> 在第一个模式的范围内，并打印 <code>early ASCII letter</code>。</p>
<h3 id="destructuring-to-break-apart-values"><a class="header" href="#destructuring-to-break-apart-values">解构以拆分值</a></h3>
<p data-x-en="We can also use patterns to destructure structs, enums, and tuples to use different parts of these values. Let’s walk through each value.">我们也可以使用模式来解构结构体、枚举和元组，以使用这些值的不同部分。让我们逐一了解每个值。</p>
<h4 id="destructuring-structs"><a class="header" href="#destructuring-structs">解构结构体</a></h4>
<p data-x-en="Listing 19-12 shows a Point struct with two fields, x and y, that we can break apart using a pattern with a let statement.">列表 19-12 显示了一个带有两个字段 <code>x</code> 和 <code>y</code> 的 <code>Point</code> 结构体，我们可以使用带有 <code>let</code> 语句的模式将其拆分。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
<figcaption>Listing 19-12: Destructuring a struct’s fields into separate variables</figcaption>
</figure>
<p data-x-en="This code creates the variables a and b that match the values of the x and y fields of the p struct. This example shows that the names of the variables in the pattern don’t have to match the field names of the struct. However, it’s common to match the variable names to the field names to make it easier to remember which variables came from which fields. Because of this common usage, and because writing let Point { x: x, y: y } = p; contains a lot of duplication, Rust has a shorthand for patterns that match struct fields: you only need to list the name of the struct field, and the variables created from the pattern will have the same names. Listing 19-13 behaves in the same way as the code in Listing 19-12, but the variables created in the let pattern are x and y instead of a and b.">这段代码创建了与 <code>p</code> 结构体的 <code>x</code> 和 <code>y</code> 字段值匹配的变量 <code>a</code> 和 <code>b</code>。这个例子表明，模式中的变量名称不必与结构体的字段名称匹配。然而，为了更容易记住哪些变量来自哪些字段，通常会将变量名称与字段名称匹配。由于这种常见的用法，以及编写 <code>let Point { x: x, y: y } = p;</code> 包含了大量的重复，Rust 为匹配结构体字段的模式提供了一种简写：你只需要列出结构体字段的名称，从模式创建的变量将具有相同的名称。列表 19-13 的行为与列表 19-12 中的代码相同，但在 <code>let</code> 模式中创建的变量是 <code>x</code> 和 <code>y</code> 而不是 <code>a</code> 和 <code>b</code>。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
<figcaption>Listing 19-13: Destructuring struct fields using struct field shorthand</figcaption>
</figure>
<p data-x-en="This code creates the variables x and y that match the x and y fields of the p variable. The outcome is that the variables x and y contain the values from the p struct.">这段代码创建了与 <code>p</code> 变量的 <code>x</code> 和 <code>y</code> 字段匹配的变量 <code>x</code> 和 <code>y</code>。结果是变量 <code>x</code> 和 <code>y</code> 包含了 <code>p</code> 结构体中的值。</p>
<p data-x-en="We can also destructure with literal values as part of the struct pattern rather than creating variables for all the fields. Doing so allows us to test some of the fields for particular values while creating variables to destructure the other fields.">我们也可以在结构体模式中使用字面值来解构，而不是为所有字段创建变量。这样做允许我们测试某些字段的特定值，同时为其他字段创建变量来解构。</p>
<p data-x-en="In Listing 19-14, we have a match expression that separates Point values into three cases: points that lie directly on the x axis (which is true when y = 0), on the y axis (x = 0), or neither.">在清单 19-14 中，我们有一个 <code>match</code> 表达式，它将 <code>Point</code> 值分为三种情况：直接位于 <code>x</code> 轴上的点（当 <code>y = 0</code> 时为真），位于 <code>y</code> 轴上的点（<code>x = 0</code>），或两者都不是。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!("On the x axis at {x}"),
        Point { x: 0, y } =&gt; println!("On the y axis at {y}"),
        Point { x, y } =&gt; {
            println!("On neither axis: ({x}, {y})");
        }
    }
}</code></pre></pre>
<figcaption>Listing 19-14: Destructuring and matching literal values in one pattern</figcaption>
</figure>
<p data-x-en="The first arm will match any point that lies on the x axis by specifying that the y field matches if its value matches the literal 0. The pattern still creates an x variable that we can use in the code for this arm.">第一个分支将通过指定 <code>y</code> 字段的值匹配字面值 <code>0</code> 来匹配任何位于 <code>x</code> 轴上的点。该模式仍然创建一个我们可以在该分支的代码中使用的 <code>x</code> 变量。</p>
<p data-x-en="Similarly, the second arm matches any point on the y axis by specifying that the x field matches if its value is 0 and creates a variable y for the value of the y field. The third arm doesn’t specify any literals, so it matches any other Point and creates variables for both the x and y fields.">同样，第二个分支通过指定 <code>x</code> 字段的值为 <code>0</code> 来匹配 <code>y</code> 轴上的任何点，并为 <code>y</code> 字段的值创建一个变量 <code>y</code>。第三个分支没有指定任何字面量，因此它匹配任何其他 <code>Point</code>，并为 <code>x</code> 和 <code>y</code> 字段创建变量。</p>
<p data-x-en="In this example, the value p matches the second arm by virtue of x containing a 0, so this code will print On the y axis at 7.">在这个例子中，值 <code>p</code> 由于 <code>x</code> 包含 0 而匹配第二个分支，因此这段代码将打印 <code>On the y axis at 7</code>。</p>
<p data-x-en="Remember that a match expression stops checking arms once it has found the first matching pattern, so even though Point { x: 0, y: 0} is on the x axis and the y axis, this code would only print On the x axis at 0.">记住，<code>match</code> 表达式在找到第一个匹配的模式后就会停止检查其他分支，因此即使 <code>Point { x: 0, y: 0}</code> 位于 <code>x</code> 轴和 <code>y</code> 轴上，这段代码也只会打印 <code>On the x axis at 0</code>。</p>
<h4 id="destructuring-enums"><a class="header" href="#destructuring-enums">解构枚举</a></h4>
<p data-x-en="We’ve destructured enums in this book (for example, Listing 6-5 in Chapter 6), but haven’t yet explicitly discussed that the pattern to destructure an enum corresponds to the way the data stored within the enum is defined. As an example, in Listing 19-15 we use the Message enum from Listing 6-2 and write a match with patterns that will destructure each inner value.">我们在本书中已经解构了枚举（例如，第 6 章的示例 6-5），但尚未明确讨论解构枚举的模式对应于枚举中存储的数据的定义方式。例如，在示例 19-15 中，我们使用了来自示例 6-2 的 <code>Message</code> 枚举，并编写了一个 <code>match</code>，其中的模式将解构每个内部值。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } =&gt; {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) =&gt; {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!("Change the color to red {r}, green {g}, and blue {b}");
        }
    }
}</code></pre></pre>
<figcaption>Listing 19-15: Destructuring enum variants that hold different kinds of values</figcaption>
</figure>
<p data-x-en="This code will print Change the color to red 0, green 160, and blue 255. Try changing the value of msg to see the code from the other arms run.">这段代码将打印 <code>将颜色更改为红色 0，绿色 160，和蓝色 255</code>。尝试更改 <code>msg</code> 的值以查看其他分支的代码运行。</p>
<p data-x-en="For enum variants without any data, like Message::Quit, we can’t destructure the value any further. We can only match on the literal Message::Quit value, and no variables are in that pattern.">对于没有数据的枚举变体，如<code>Message::Quit</code>，我们无法进一步解构该值。我们只能匹配字面值<code>Message::Quit</code>，并且该模式中没有变量。</p>
<p data-x-en="For struct-like enum variants, such as Message::Move, we can use a pattern similar to the pattern we specify to match structs. After the variant name, we place curly brackets and then list the fields with variables so we break apart the pieces to use in the code for this arm. Here we use the shorthand form as we did in Listing 19-13.">对于类似结构体的枚举变体，如<code>Message::Move</code>，我们可以使用与匹配结构体时指定的模式相似的模式。在变体名称之后，我们放置大括号，然后列出带有变量的字段，以便将各个部分拆分出来，在此臂的代码中使用。在这里，我们使用了简写形式，就像我们在清单19-13中所做的那样。</p>
<p data-x-en="For tuple-like enum variants, like Message::Write that holds a tuple with one element and Message::ChangeColor that holds a tuple with three elements, the pattern is similar to the pattern we specify to match tuples. The number of variables in the pattern must match the number of elements in the variant we’re matching.">对于像 <code>Message::Write</code> 这样持有一个元素的元组的枚举变体，以及像 <code>Message::ChangeColor</code> 这样持有三个元素的元组的枚举变体，模式与我们指定用于匹配元组的模式相似。模式中的变量数量必须与我们要匹配的变体中的元素数量相匹配。</p>
<h4 id="destructuring-nested-structs-and-enums"><a class="header" href="#destructuring-nested-structs-and-enums">解构嵌套的结构体和枚举</a></h4>
<p data-x-en="So far, our examples have all been matching structs or enums one level deep, but matching can work on nested items too! For example, we can refactor the code in Listing 19-15 to support RGB and HSV colors in the ChangeColor message, as shown in Listing 19-16.">到目前为止，我们的示例都只匹配了一层深度的结构体或枚举，但匹配也可以作用于嵌套项！例如，我们可以重构列表 19-15 中的代码，以支持 <code>ChangeColor</code> 消息中的 RGB 和 HSV 颜色，如列表 19-16 所示。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!("Change color to hue {h}, saturation {s}, value {v}");
        }
        _ =&gt; (),
    }
}</code></pre></pre>
<figcaption>Listing 19-16: Matching on nested enums</figcaption>
</figure>
<p data-x-en="The pattern of the first arm in the match expression matches a Message::ChangeColor enum variant that contains a Color::Rgb variant; then the pattern binds to the three inner i32 values. The pattern of the second arm also matches a Message::ChangeColor enum variant, but the inner enum matches Color::Hsv instead. We can specify these complex conditions in one match expression, even though two enums are involved."><code>match</code> 表达式的第一臂的模式匹配包含 <code>Color::Rgb</code> 变体的 <code>Message::ChangeColor</code> 枚举变体；然后模式绑定到三个内部的 <code>i32</code> 值。第二臂的模式也匹配 <code>Message::ChangeColor</code> 枚举变体，但内部枚举匹配的是 <code>Color::Hsv</code>。即使涉及两个枚举，我们也可以在一个 <code>match</code> 表达式中指定这些复杂的条件。</p>
<h4 id="destructuring-structs-and-tuples"><a class="header" href="#destructuring-structs-and-tuples">解构结构体和元组</a></h4>
<p data-x-en="We can mix, match, and nest destructuring patterns in even more complex ways. The following example shows a complicated destructure where we nest structs and tuples inside a tuple and destructure all the primitive values out:">我们可以更复杂地混合、匹配和嵌套解构模式。<br>以下示例展示了一个复杂的解构，其中我们在元组中嵌套了结构体和元组，并解构出所有的原始值：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p data-x-en="This code lets us break complex types into their component parts so we can use the values we’re interested in separately.">这段代码让我们可以将复杂类型分解为其组成部分，这样我们就可以单独使用我们感兴趣的值。</p>
<p data-x-en="Destructuring with patterns is a convenient way to use pieces of values, such as the value from each field in a struct, separately from each other.">使用模式解构是一种方便地单独使用值的各个部分的方法，例如从结构体的每个字段中分别获取值。</p>
<h3 id="ignoring-values-in-a-pattern"><a class="header" href="#ignoring-values-in-a-pattern">在模式中忽略值</a></h3>
<p data-x-en="You’ve seen that it’s sometimes useful to ignore values in a pattern, such as in the last arm of a match, to get a catch-all that doesn’t actually do anything but does account for all remaining possible values. There are a few ways to ignore entire values or parts of values in a pattern: using the _ pattern (which you’ve seen), using the _ pattern within another pattern, using a name that starts with an underscore, or using .. to ignore remaining parts of a value. Let’s explore how and why to use each of these patterns.">你已经看到，在模式中有时忽略值是有用的，例如在 <code>match</code> 的最后一个分支中，得到一个实际上不执行任何操作但确实考虑了所有剩余可能值的通配。有几种方法可以在模式中忽略整个值或值的部分：使用 <code>_</code> 模式（你已经见过），在另一个模式中使用 <code>_</code> 模式，使用以下划线开头的名称，或使用 <code>..</code> 忽略值的剩余部分。让我们探讨如何以及为什么使用这些模式。</p>
<h4 id="ignoring-an-entire-value-with-_"><a class="header" href="#ignoring-an-entire-value-with-_">使用 <code>_</code> 忽略整个值</a></h4>
<p data-x-en="We’ve used the underscore as a wildcard pattern that will match any value but not bind to the value. This is especially useful as the last arm in a match expression, but we can also use it in any pattern, including function parameters, as shown in Listing 19-17.">我们使用下划线作为通配符模式，它可以匹配任何值但不会绑定到该值。这在 <code>match</code> 表达式的最后一个分支中特别有用，但我们也可以在任何模式中使用它，包括函数参数，如列表 19-17 所示。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {y}");
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
<figcaption>Listing 19-17: Using <code>_</code> in a function signature</figcaption>
</figure>
<p data-x-en="This code will completely ignore the value 3 passed as the first argument, and will print This code only uses the y parameter: 4.">这段代码将完全忽略作为第一个参数传递的值<code>3</code>，并将打印<code>This code only uses the y parameter: 4</code>。</p>
<p data-x-en="In most cases when you no longer need a particular function parameter, you would change the signature so it doesn’t include the unused parameter. Ignoring a function parameter can be especially useful in cases when, for example, you’re implementing a trait when you need a certain type signature but the function body in your implementation doesn’t need one of the parameters. You then avoid getting a compiler warning about unused function parameters, as you would if you used a name instead.">在大多数情况下，当你不再需要某个特定的函数参数时，你会更改签名以不包括这个未使用的参数。忽略函数参数在某些情况下特别有用，例如，当你实现一个特质时，需要特定的类型签名，但你的实现中的函数体不需要其中一个参数。这样，你可以避免因使用名称而产生的未使用函数参数的编译器警告。</p>
<h4 id="ignoring-parts-of-a-value-with-a-nested-_"><a class="header" href="#ignoring-parts-of-a-value-with-a-nested-_">使用嵌套的 <code>_</code> 忽略值的部分</a></h4>
<p data-x-en="We can also use _ inside another pattern to ignore just part of a value, for example, when we want to test for only part of a value but have no use for the other parts in the corresponding code we want to run. Listing 19-18 shows code responsible for managing a setting’s value. The business requirements are that the user should not be allowed to overwrite an existing customization of a setting but can unset the setting and give it a value if it is currently unset.">我们也可以在另一个模式中使用 <code>_</code> 来忽略值的一部分，例如，当我们只想测试值的一部分但在相应的代码中不需要其他部分时。列表 19-18 显示了负责管理设置值的代码。业务需求是用户不应被允许覆盖现有设置的自定义，但可以在设置当前未设置时取消设置并为其赋值。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("Can't overwrite an existing customized value");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {setting_value:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-18: Using an underscore within patterns that match <code>Some</code> variants when we don’t need to use the value inside the <code>Some</code></figcaption>
</figure>
<p data-x-en="This code will print Can't overwrite an existing customized value and then setting is Some(5). In the first match arm, we don’t need to match on or use the values inside either Some variant, but we do need to test for the case when setting_value and new_setting_value are the Some variant. In that case, we print the reason for not changing setting_value, and it doesn’t get changed.">这段代码将打印 <code>Can't overwrite an existing customized value</code> 然后
<code>setting is Some(5)</code>。在第一个 match 分支中，我们不需要匹配或使用
<code>Some</code> 变体中的任何值，但我们需要测试 <code>setting_value</code> 和 <code>new_setting_value</code>
是 <code>Some</code> 变体的情况。在这种情况下，我们打印不更改 <code>setting_value</code> 的原因，且它不会被更改。</p>
<p data-x-en="In all other cases (if either setting_value or new_setting_value are None) expressed by the _ pattern in the second arm, we want to allow new_setting_value to become setting_value.">在所有其他情况下（如果 <code>setting_value</code> 或 <code>new_setting_value</code> 为 <code>None</code>），在第二个分支中用 <code>_</code> 模式表示，我们希望允许 <code>new_setting_value</code> 变为 <code>setting_value</code>。</p>
<p data-x-en="We can also use underscores in multiple places within one pattern to ignore particular values. Listing 19-19 shows an example of ignoring the second and fourth values in a tuple of five items.">我们也可以在同一个模式中的多个地方使用下划线来忽略特定的值。列表 19-19 显示了一个例子，忽略了五个元素元组中的第二个和第四个值。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("Some numbers: {first}, {third}, {fifth}")
        }
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-19: Ignoring multiple parts of a tuple</figcaption>
</figure>
<p data-x-en="This code will print Some numbers: 2, 8, 32, and the values 4 and 16 will be ignored.">这段代码将打印 <code>Some numbers: 2, 8, 32</code>，并且值 4 和 16 将被忽略。</p>
<h4 id="ignoring-an-unused-variable-by-starting-its-name-with-_"><a class="header" href="#ignoring-an-unused-variable-by-starting-its-name-with-_">通过在名称前加<code>_</code>来忽略未使用的变量</a></h4>
<p data-x-en="If you create a variable but don’t use it anywhere, Rust will usually issue a warning because an unused variable could be a bug. However, sometimes it’s useful to be able to create a variable you won’t use yet, such as when you’re prototyping or just starting a project. In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore. In Listing 19-20, we create two unused variables, but when we compile this code, we should only get a warning about one of them.">如果您创建了一个变量但没有在任何地方使用它，Rust 通常会发出警告，因为未使用的变量可能是错误。但是，有时能够创建一个您暂时不会使用的变量是有用的，例如在原型设计或刚开始一个项目时。在这种情况下，您可以通过在变量名称前加上下划线来告诉 Rust 不要警告您有关未使用的变量。在清单 19-20 中，我们创建了两个未使用的变量，但当我们编译此代码时，我们应该只收到其中一个变量的警告。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
<figcaption>Listing 19-20: Starting a variable name with an underscore to avoid getting unused variable warnings</figcaption>
</figure>
<p data-x-en="Here we get a warning about not using the variable y, but we don’t get a warning about not using _x.">这里我们得到了一个关于未使用变量<code>y</code>的警告，但没有关于未使用<code>_x</code>的警告。</p>
<p data-x-en="Note that there is a subtle difference between using only _ and using a name that starts with an underscore. The syntax _x still binds the value to the variable, whereas _ doesn’t bind at all. To show a case where this distinction matters, Listing 19-21 will provide us with an error.">请注意，仅使用 <code>_</code> 和使用以下划线开头的名称之间存在细微差别。<code>_x</code> 仍然将值绑定到变量，而 <code>_</code> 则完全不绑定。为了展示这种区别的重要性，列表 19-21 将会给我们一个错误。</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre>
<figcaption>Listing 19-21: An unused variable starting with an underscore still binds the value, which might take ownership of the value</figcaption>
</figure>
<p data-x-en="We’ll receive an error because the s value will still be moved into _s, which prevents us from using s again. However, using the underscore by itself doesn’t ever bind to the value. Listing 19-22 will compile without any errors because s doesn’t get moved into _.">我们将收到一个错误，因为 <code>s</code> 值仍然会被移动到 <code>_s</code>，这阻止了我们再次使用 <code>s</code>。然而，仅使用下划线本身并不会绑定到该值。列表 19-22 将不会出现任何错误地编译，因为 <code>s</code> 没有被移动到 <code>_</code>。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-22: Using an underscore does not bind the value</figcaption>
</figure>
<p data-x-en="This code works just fine because we never bind s to anything; it isn’t moved.">这段代码运行得很好，因为我们从未将 <code>s</code> 绑定到任何东西上；它没有被移动。</p>
<h4 id="ignoring-remaining-parts-of-a-value-with-"><a class="header" href="#ignoring-remaining-parts-of-a-value-with-">使用 <code>..</code> 忽略值的剩余部分</a></h4>
<p data-x-en="With values that have many parts, we can use the .. syntax to use specific parts and ignore the rest, avoiding the need to list underscores for each ignored value. The .. pattern ignores any parts of a value that we haven’t explicitly matched in the rest of the pattern. In Listing 19-23, we have a Point struct that holds a coordinate in three-dimensional space. In the match expression, we want to operate only on the x coordinate and ignore the values in the y and z fields.">对于包含多个部分的值，我们可以使用 <code>..</code> 语法来使用特定部分并忽略其余部分，从而避免为每个忽略的值列出下划线。<code>..</code> 模式会忽略我们未在模式其余部分显式匹配的值的任何部分。在清单 19-23 中，我们有一个表示三维空间坐标的 <code>Point</code> 结构体。在 <code>match</code> 表达式中，我们只想操作 <code>x</code> 坐标并忽略 <code>y</code> 和 <code>z</code> 字段的值。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x is {x}"),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-23: Ignoring all fields of a <code>Point</code> except for <code>x</code> by using <code>..</code></figcaption>
</figure>
<p data-x-en="We list the x value and then just include the .. pattern. This is quicker than having to list y: _ and z: _, particularly when we’re working with structs that have lots of fields in situations where only one or two fields are relevant.">我们列出 <code>x</code> 值，然后只包含 <code>..</code> 模式。这比列出 <code>y: _</code> 和 <code>z: _</code> 更快捷，特别是在处理具有许多字段的结构体时，只有其中一个或两个字段是相关的。</p>
<p data-x-en="The syntax .. will expand to as many values as it needs to be. Listing 19-24 shows how to use .. with a tuple.">语法 <code>..</code> 会扩展为它需要的尽可能多的值。列表 19-24
展示了如何在元组中使用 <code>..</code>。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("Some numbers: {first}, {last}");
        }
    }
}</code></pre></pre>
<figcaption>Listing 19-24: Matching only the first and last values in a tuple and ignoring all other values</figcaption>
</figure>
<p data-x-en="In this code, the first and last value are matched with first and last. The .. will match and ignore everything in the middle.">在这个代码中，第一个和最后一个值分别与<code>first</code>和<code>last</code>匹配。<code>..</code>将匹配并忽略中间的所有内容。</p>
<p data-x-en="However, using .. must be unambiguous. If it is unclear which values are intended for matching and which should be ignored, Rust will give us an error. Listing 19-25 shows an example of using .. ambiguously, so it will not compile.">然而，使用 <code>..</code> 必须是明确的。如果不清楚哪些值是用于匹配的，哪些值应该被忽略，Rust 会给我们一个错误。列表 19-25 显示了一个使用 <code>..</code> 模棱两可的例子，因此它将无法编译。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("Some numbers: {second}")
        },
    }
}</code></pre>
<figcaption>Listing 19-25: An attempt to use <code>..</code> in an ambiguous way</figcaption>
</figure>
<p data-x-en="When we compile this example, we get this error:">当我们编译这个示例时，我们得到以下错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p data-x-en="It’s impossible for Rust to determine how many values in the tuple to ignore before matching a value with second and then how many further values to ignore thereafter. This code could mean that we want to ignore 2, bind second to 4, and then ignore 8, 16, and 32; or that we want to ignore 2 and 4, bind second to 8, and then ignore 16 and 32; and so forth. The variable name second doesn’t mean anything special to Rust, so we get a compiler error because using .. in two places like this is ambiguous.">在匹配 <code>second</code> 之前，Rust 无法确定元组中有多少个值需要忽略，以及之后还需要忽略多少个值。这段代码可能意味着我们想要忽略 <code>2</code>，将 <code>second</code> 绑定到 <code>4</code>，然后忽略 <code>8</code>、<code>16</code> 和 <code>32</code>；或者我们想要忽略 <code>2</code> 和 <code>4</code>，将 <code>second</code> 绑定到 <code>8</code>，然后忽略 <code>16</code> 和 <code>32</code>；等等。变量名 <code>second</code> 对 Rust 没有特殊意义，因此由于在这种情况下使用 <code>..</code> 是模糊的，我们会得到一个编译错误。</p>
<h3 id="extra-conditionals-with-match-guards"><a class="header" href="#extra-conditionals-with-match-guards">使用匹配卫语句的额外条件</a></h3>
<p data-x-en="A match guard is an additional if condition, specified after the pattern in a match arm, that must also match for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows. They are only available in match expressions, not in if let or while let expressions.">一个 <em>匹配卫士</em> 是一个额外的 <code>if</code> 条件，在 <code>match</code> 分支的模式之后指定，该分支被选择之前此条件也必须匹配。匹配卫士对于表达比单独的模式更复杂的想法非常有用。它们仅在 <code>match</code> 表达式中可用，而在 <code>if let</code> 或 <code>while let</code> 表达式中不可用。</p>
<p data-x-en="The condition can use variables created in the pattern. Listing 19-26 shows a match where the first arm has the pattern Some(x) and also has a match guard of if x % 2 == 0 (which will be true if the number is even).">条件可以使用在模式中创建的变量。列表 19-26 显示了一个 <code>match</code>，其中第一个分支的模式为 <code>Some(x)</code>，并且还有一个匹配卫士 <code>if x % 2 == 0</code>（如果数字是偶数，这将为真）。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!("The number {x} is even"),
        Some(x) =&gt; println!("The number {x} is odd"),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-26: Adding a match guard to a pattern</figcaption>
</figure>
<p data-x-en="This example will print The number 4 is even. When num is compared to the pattern in the first arm, it matches, because Some(4) matches Some(x). Then the match guard checks whether the remainder of dividing x by 2 is equal to 0, and because it is, the first arm is selected.">这个示例将打印 <code>The number 4 is even</code>。当 <code>num</code> 与第一个分支中的模式进行比较时，它匹配，因为 <code>Some(4)</code> 匹配 <code>Some(x)</code>。然后匹配卫士检查 <code>x</code> 除以 2 的余数是否等于 0，因为确实等于 0，所以选择了第一个分支。</p>
<p data-x-en="If num had been Some(5) instead, the match guard in the first arm would have been false because the remainder of 5 divided by 2 is 1, which is not equal to 0. Rust would then go to the second arm, which would match because the second arm doesn’t have a match guard and therefore matches any Some variant.">如果 <code>num</code> 是 <code>Some(5)</code>，第一个分支的匹配卫士将为假，因为 5 除以 2 的余数是 1，不等于 0。Rust 然后会转到第二个分支，该分支会匹配，因为第二个分支没有匹配卫士，因此匹配任何 <code>Some</code> 变体。</p>
<p data-x-en="There is no way to express the if x % 2 == 0 condition within a pattern, so the match guard gives us the ability to express this logic. The downside of this additional expressiveness is that the compiler doesn’t try to check for exhaustiveness when match guard expressions are involved.">无法在模式中表达 <code>if x % 2 == 0</code> 这个条件，因此
匹配卫语句使我们能够表达这种逻辑。这种额外表达性的缺点是
当涉及匹配卫语句表达式时，编译器不会尝试检查是否穷尽。</p>
<p data-x-en="In Listing 19-11, we mentioned that we could use match guards to solve our pattern-shadowing problem. Recall that we created a new variable inside the pattern in the match expression instead of using the variable outside the match. That new variable meant we couldn’t test against the value of the outer variable. Listing 19-27 shows how we can use a match guard to fix this problem.">在清单 19-11 中，我们提到可以使用匹配卫语来解决我们的模式遮蔽问题。回想一下，我们在 <code>match</code> 表达式的模式中创建了一个新变量，而不是使用 <code>match</code> 外部的变量。这个新变量意味着我们无法测试外部变量的值。清单 19-27 显示了如何使用匹配卫语来解决这个问题。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(n) if n == y =&gt; println!("Matched, n = {n}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
}</code></pre></pre>
<figcaption>Listing 19-27: Using a match guard to test for equality with an outer variable</figcaption>
</figure>
<p data-x-en="This code will now print Default case, x = Some(5). The pattern in the second match arm doesn’t introduce a new variable y that would shadow the outer y, meaning we can use the outer y in the match guard. Instead of specifying the pattern as Some(y), which would have shadowed the outer y, we specify Some(n). This creates a new variable n that doesn’t shadow anything because there is no n variable outside the match.">这段代码现在将打印 <code>Default case, x = Some(5)</code>。第二个 match 分支中的模式不会引入一个新的变量 <code>y</code> 来遮蔽外部的 <code>y</code>，这意味着我们可以在 match 守卫中使用外部的 <code>y</code>。我们指定模式为 <code>Some(n)</code> 而不是 <code>Some(y)</code>，后者会遮蔽外部的 <code>y</code>。这创建了一个新的变量 <code>n</code>，它不会遮蔽任何东西，因为在 <code>match</code> 外部没有 <code>n</code> 变量。</p>
<p data-x-en="The match guard if n == y is not a pattern and therefore doesn’t introduce new variables. This y is the outer y rather than a new y shadowing it, and we can look for a value that has the same value as the outer y by comparing n to y.">匹配卫士 <code>if n == y</code> 不是模式，因此不会引入新的变量。这个 <code>y</code> <em>是</em> 外部的 <code>y</code> 而不是新的 <code>y</code> 遮蔽它，我们可以通过比较 <code>n</code> 和 <code>y</code> 来查找与外部 <code>y</code> 具有相同值的值。</p>
<p data-x-en="You can also use the or operator | in a match guard to specify multiple patterns; the match guard condition will apply to all the patterns. Listing 19-28 shows the precedence when combining a pattern that uses | with a match guard. The important part of this example is that the if y match guard applies to 4, 5, and 6, even though it might look like if y only applies to 6.">您还可以在匹配卫士中使用 <em>或</em> 操作符 <code>|</code> 来指定多个模式；匹配卫士条件将适用于所有模式。列表 19-28 显示了将使用 <code>|</code> 的模式与匹配卫士结合时的优先级。此示例的重要部分是 <code>if y</code> 匹配卫士适用于 <code>4</code>、<code>5</code> 和 <code>6</code>，即使看起来 <code>if y</code> 仅适用于 <code>6</code>。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!("yes"),
        _ =&gt; println!("no"),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-28: Combining multiple patterns with a match guard</figcaption>
</figure>
<p data-x-en="The match condition states that the arm only matches if the value of x is equal to 4, 5, or 6 and if y is true. When this code runs, the pattern of the first arm matches because x is 4, but the match guard if y is false, so the first arm is not chosen. The code moves on to the second arm, which does match, and this program prints no. The reason is that the if condition applies to the whole pattern 4 | 5 | 6, not only to the last value 6. In other words, the precedence of a match guard in relation to a pattern behaves like this:">匹配条件指出，只有当 <code>x</code> 的值等于 <code>4</code>、<code>5</code> 或 <code>6</code> <em>并且</em> <code>y</code> 为 <code>true</code> 时，该臂才匹配。当此代码运行时，第一个臂的模式匹配因为 <code>x</code> 为 <code>4</code>，但匹配卫士 <code>if y</code> 为假，所以第一个臂未被选择。代码继续到第二个臂，该臂匹配，此程序打印 <code>no</code>。原因是 <code>if</code> 条件适用于整个模式 <code>4 | 5 | 6</code>，而不仅仅是最后一个值 <code>6</code>。换句话说，匹配卫士相对于模式的优先级行为如下：</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p data-x-en="rather than this:">而不是这个:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p data-x-en="After running the code, the precedence behavior is evident: if the match guard were applied only to the final value in the list of values specified using the | operator, the arm would have matched and the program would have printed yes.">在运行代码后，优先级行为很明显：如果匹配卫士仅应用于使用 <code>|</code> 操作符指定的值列表中的最后一个值，该臂就会匹配，程序将打印 <code>yes</code>。</p>
<h3 id="-bindings"><a class="header" href="#-bindings"><code>@</code> 绑定</a></h3>
<p data-x-en="The at operator @ lets us create a variable that holds a value at the same time as we’re testing that value for a pattern match. In Listing 19-29, we want to test that a Message::Hello id field is within the range 3..=7. We also want to bind the value to the variable id_variable so we can use it in the code associated with the arm. We could name this variable id, the same as the field, but for this example we’ll use a different name."><em>at</em> 操作符 <code>@</code> 让我们可以在测试值是否符合模式的同时创建一个持有该值的变量。在清单 19-29 中，我们希望测试 <code>Message::Hello</code> 的 <code>id</code> 字段是否在范围 <code>3..=7</code> 内。我们还想将该值绑定到变量 <code>id_variable</code>，以便在与该分支关联的代码中使用。我们可以将此变量命名为 <code>id</code>，与字段同名，但在这个例子中我们将使用不同的名称。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!("Found an id in range: {id_variable}"),
        Message::Hello { id: 10..=12 } =&gt; {
            println!("Found an id in another range")
        }
        Message::Hello { id } =&gt; println!("Found some other id: {id}"),
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 19-29: Using <code>@</code> to bind to a value in a pattern while also testing it</figcaption>
</figure>
<p data-x-en="This example will print Found an id in range: 5. By specifying id_variable @ before the range 3..=7, we’re capturing whatever value matched the range while also testing that the value matched the range pattern.">这个示例将打印 <code>Found an id in range: 5</code>。通过在范围 <code>3..=7</code> 之前指定 <code>id_variable @</code>，我们不仅测试了值是否匹配范围模式，还捕获了匹配范围的值。</p>
<p data-x-en="In the second arm, where we only have a range specified in the pattern, the code associated with the arm doesn’t have a variable that contains the actual value of the id field. The id field’s value could have been 10, 11, or 12, but the code that goes with that pattern doesn’t know which it is. The pattern code isn’t able to use the value from the id field, because we haven’t saved the id value in a variable.">在第二个分支中，我们只在模式中指定了一个范围，与该分支关联的代码没有包含 <code>id</code> 字段实际值的变量。<code>id</code> 字段的值可能是 10、11 或 12，但与该模式关联的代码不知道具体是哪个值。模式代码无法使用 <code>id</code> 字段的值，因为我们没有将 <code>id</code> 值保存在变量中。</p>
<p data-x-en="In the last arm, where we’ve specified a variable without a range, we do have the value available to use in the arm’s code in a variable named id. The reason is that we’ve used the struct field shorthand syntax. But we haven’t applied any test to the value in the id field in this arm, as we did with the first two arms: any value would match this pattern.">在最后一个分支中，我们指定了一个没有范围的变量，我们确实有值可以在分支的代码中使用，变量名为<code>id</code>。原因是使用了结构体字段简写语法。但是在这个分支中，我们没有对<code>id</code>字段中的值进行任何测试，而前两个分支中我们进行了测试：任何值都会匹配这个模式。</p>
<p data-x-en="Using @ lets us test a value and save it in a variable within one pattern.">使用 <code>@</code> 可以让我们在一个模式中测试一个值并将其保存在一个变量中。</p>
<h2 id="summary"><a class="header" href="#summary">摘要</a></h2>
<p data-x-en="Rust’s patterns are very useful in distinguishing between different kinds of data. When used in match expressions, Rust ensures your patterns cover every possible value, or your program won’t compile. Patterns in let statements and function parameters make those constructs more useful, enabling the destructuring of values into smaller parts and assigning those parts to variables. We can create simple or complex patterns to suit our needs.">Rust 的模式非常有用，可以区分不同类型的数据。当在 <code>match</code> 表达式中使用时，Rust 确保您的模式覆盖了所有可能的值，否则程序将无法编译。在 <code>let</code> 语句和函数参数中的模式使这些构造更加有用，能够将值解构为更小的部分，并将这些部分分配给变量。我们可以创建简单或复杂的模式以满足我们的需求。</p>
<p data-x-en="Next, for the penultimate chapter of the book, we’ll look at some advanced aspects of a variety of Rust’s features.">接下来，对于本书的倒数第二章，我们将探讨 Rust 各种特性的一些高级方面。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-02-refutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-00-advanced-features.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-02-refutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-00-advanced-features.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    

</body></html>