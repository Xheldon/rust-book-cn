<!DOCTYPE html><html lang="zh-CN" class="light sidebar-visible" dir="ltr"><head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unsafe Rust - Rust 编程语言</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    <meta name="title" content="Rust 中文"><meta property="og:title" content="Rust 中文"><meta name="description" content="Rust 中文文档"><meta property="og:description" content="Rust 中文文档"><meta name="url" content="https://rust.xheldon.com"><meta property="og:url" content="https://rust.xheldon.com"><script src="https://www.googletagmanager.com/gtag/js?id=G-V7NE1X37EX"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-V7NE1X37EX')</script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486286026923411"></script><style>/* hover 显示原文 */
p[data-x-en],
li[data-x-en] {
  position: relative;
}
p[data-x-en]:hover::after,
li[data-x-en]:hover::after {
  visibility: visible;
  opacity: 1;
}
p[data-x-en]::after,
li[data-x-en]::after {
  content: attr(data-x-en);
  display: block;
  font-size: 12px;
  transition: all 0.2s 0.3s;
  visibility: hidden;
  opacity: 0;
  background: var(--searchbar-bg);
  z-index: 99;
  border-radius: 4px;
  padding: 5px 10px;
  position: absolute;
  top: 100%;
  left: 0;
}
/* 译者注释内容 */
div[type='comment'] {
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  background: #eee;
}
div[type='comment']::before {
  content: '译者注: ';
  font-weight: 900;
}
header a.logo {
  position: relative;
}
header a.logo::after {
  content: '中文';
  position: absolute;
  left: calc(100% + 5px);
  font-size: 12px;
  width: 50px;
  top: -5px;
}
#banner-info {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  font-size: 12px;
  padding: 0;
  z-index: 999;
}
#add-info {
  font-size: 14px;
}
blockquote {
  border-left: 5px solid #ccc;
  padding-left: 10px;
  margin-left: 0;
}
.content {
  overflow-y: unset !important;
}
</style></head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky"><div id="banner-info">本文档为 AI + 人工翻译，hover 可以显示原文。当前页翻译有问题？<a style="cursor: pointer;" href="https://github.com/Xheldon/rust-book-cn/blob/main/dict/ch20-01-unsafe-rust.json" target="_blank">我来翻译！</a></div>
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    <a href="https://github.com/Xheldon/rust-book-cn" target="_blank"><i class="fa fa-language"></i></a><a href="https://www.xheldon.com" target="_blank"><i class="fa fa-id-card"></i></a></div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="unsafe-rust"><a class="header" href="#unsafe-rust">不安全的 Rust</a></h2>
<p data-x-en="All the code we’ve discussed so far has had Rust’s memory safety guarantees enforced at compile time. However, Rust has a second language hidden inside it that doesn’t enforce these memory safety guarantees: it’s called unsafe Rust and works just like regular Rust, but gives us extra superpowers.">我们迄今为止讨论的所有代码都在编译时强制执行了 Rust 的内存安全保证。然而，Rust 有一种隐藏在其中的第二种语言，它不强制执行这些内存安全保证：它被称为 <em>不安全的 Rust</em>，它就像普通的 Rust 一样工作，但赋予我们额外的超能力。</p>
<p data-x-en="Unsafe Rust exists because, by nature, static analysis is conservative. When the compiler tries to determine whether or not code upholds the guarantees, it’s better for it to reject some valid programs than to accept some invalid programs. Although the code might be okay, if the Rust compiler doesn’t have enough information to be confident, it will reject the code. In these cases, you can use unsafe code to tell the compiler, “Trust me, I know what I’m doing.” Be warned, however, that you use unsafe Rust at your own risk: if you use unsafe code incorrectly, problems can occur due to memory unsafety, such as null pointer dereferencing.">Unsafe Rust 存在的原因在于，静态分析本质上是保守的。当编译器尝试确定代码是否遵守保证时，拒绝一些有效的程序总比接受一些无效的程序要好。虽然代码<em>可能</em>是正确的，但如果 Rust 编译器没有足够的信息来确信，它将拒绝该代码。在这种情况下，您可以使用不安全的代码来告诉编译器，“相信我，我知道自己在做什么。” 但是请注意，您使用不安全的 Rust 时风险自负：如果您不正确地使用不安全的代码，可能会由于内存不安全问题（如空指针解引用）而出现问题。</p>
<p data-x-en="Another reason Rust has an unsafe alter ego is that the underlying computer hardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you couldn’t do certain tasks. Rust needs to allow you to do low-level systems programming, such as directly interacting with the operating system or even writing your own operating system. Working with low-level systems programming is one of the goals of the language. Let’s explore what we can do with unsafe Rust and how to do it.">另一个原因是底层计算机硬件本质上是不安全的。如果 Rust 不允许你执行不安全的操作，你就无法完成某些任务。Rust 需要允许你进行低级系统编程，例如直接与操作系统交互，甚至编写你自己的操作系统。进行低级系统编程是该语言的目标之一。让我们探索使用不安全的 Rust 可以做什么以及如何做。</p>
<h3 id="unsafe-superpowers"><a class="header" href="#unsafe-superpowers">不安全的超级能力</a></h3>
<p data-x-en="To switch to unsafe Rust, use the unsafe keyword and then start a new block that holds the unsafe code. You can take five actions in unsafe Rust that you can’t in safe Rust, which we call unsafe superpowers. Those superpowers include the ability to:">要切换到不安全的 Rust，使用 <code>unsafe</code> 关键字，然后开始一个新的块
来包含不安全的代码。在不安全的 Rust 中，你可以执行五种在安全的 Rust 中无法执行的操作，我们称之为 <em>不安全的超能力</em>。这些超能力包括：</p>
<ul>
<li data-x-en="Dereference a raw pointer">解引用原始指针</li>
<li data-x-en="Call an unsafe function or method">调用不安全的函数或方法</li>
<li data-x-en="Access or modify a mutable static variable">访问或修改可变静态变量</li>
<li data-x-en="Implement an unsafe trait">实现一个不安全的特质</li>
<li data-x-en="Access fields of a union">访问 <code>union</code> 的字段</li>
</ul>
<p data-x-en="It’s important to understand that unsafe doesn’t turn off the borrow checker or disable any of Rust’s other safety checks: if you use a reference in unsafe code, it will still be checked. The unsafe keyword only gives you access to these five features that are then not checked by the compiler for memory safety. You’ll still get some degree of safety inside of an unsafe block.">理解 <code>unsafe</code> 并不会关闭借用检查器或禁用 Rust 的其他任何安全检查：如果你在不安全代码中使用引用，它仍然会被检查。<code>unsafe</code> 关键字只给你访问这五个特性，这些特性不会被编译器检查以确保内存安全。你仍然会在不安全块内获得一定程度的安全性。</p>
<p data-x-en="In addition, unsafe does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you’ll ensure the code inside an unsafe block will access memory in a valid way.">此外，<code>unsafe</code> 并不意味着块内的代码一定是危险的或肯定会有内存安全问题：其意图是，作为程序员，您将确保 <code>unsafe</code> 块内的代码将以有效的方式访问内存。</p>
<p data-x-en="People are fallible and mistakes will happen, but by requiring these five unsafe operations to be inside blocks annotated with unsafe, you’ll know that any errors related to memory safety must be within an unsafe block. Keep unsafe blocks small; you’ll be thankful later when you investigate memory bugs.">人们会犯错，但通过要求这五种不安全操作必须位于带有 <code>unsafe</code> 注解的块中，您将知道任何与内存安全相关的错误都必须在 <code>unsafe</code> 块内。保持 <code>unsafe</code> 块小；当您日后调查内存错误时，您会感谢自己。</p>
<p data-x-en="To isolate unsafe code as much as possible, it’s best to enclose such code within a safe abstraction and provide a safe API, which we’ll discuss later in the chapter when we examine unsafe functions and methods. Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited. Wrapping unsafe code in a safe abstraction prevents uses of unsafe from leaking out into all the places that you or your users might want to use the functionality implemented with unsafe code, because using a safe abstraction is safe.">为了尽可能地隔离不安全的代码，最好将此类代码封装在安全的抽象中，并提供一个安全的API，我们将在本章后面讨论不安全的函数和方法时详细探讨。标准库的某些部分是通过安全抽象实现的，这些抽象覆盖了已经经过审核的不安全代码。将不安全的代码封装在安全的抽象中，可以防止<code>unsafe</code>的使用泄露到你或你的用户可能想要使用通过<code>unsafe</code>代码实现的功能的所有地方，因为使用安全的抽象是安全的。</p>
<p data-x-en="Let’s look at each of the five unsafe superpowers in turn. We’ll also look at some abstractions that provide a safe interface to unsafe code.">让我们逐一看看这五种不安全的超能力。我们还将看看一些提供安全接口的抽象来访问不安全代码。</p>
<h3 id="dereferencing-a-raw-pointer"><a class="header" href="#dereferencing-a-raw-pointer">解引用原始指针</a></h3>
<p data-x-en="In “Dangling References” in Chapter 4, we mentioned that the compiler ensures references are always valid. Unsafe Rust has two new types called raw pointers that are similar to references. As with references, raw pointers can be immutable or mutable and are written as *const T and *mut T, respectively. The asterisk isn’t the dereference operator; it’s part of the type name. In the context of raw pointers, immutable means that the pointer can’t be directly assigned to after being dereferenced.">在<a href="ch04-02-references-and-borrowing.html#dangling-references">“悬垂引用”</a><!-- ignore -->一章中，我们提到编译器确保引用始终有效。不安全的 Rust 引入了两种新的类型，称为<em>原始指针</em>，它们与引用类似。与引用一样，原始指针可以是不可变的或可变的，分别写为<code>*const T</code>和<code>*mut T</code>。星号不是解引用运算符；它是类型名称的一部分。在原始指针的上下文中，<em>不可变</em>意味着指针在解引用后不能直接赋值。</p>
<p data-x-en="Different from references and smart pointers, raw pointers:">不同于引用和智能指针，原始指针：</p>
<ul>
<li data-x-en="Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location">允许通过同时拥有不可变和可变指针或多个可变指针来忽略借用规则。</li>
<li data-x-en="Aren’t guaranteed to point to valid memory">不一定指向有效的内存</li>
<li data-x-en="Are allowed to be null">允许为空</li>
<li data-x-en="Don’t implement any automatic cleanup">不要实现任何自动清理</li>
</ul>
<p data-x-en="By opting out of having Rust enforce these guarantees, you can give up guaranteed safety in exchange for greater performance or the ability to interface with another language or hardware where Rust’s guarantees don’t apply.">通过选择不使用 Rust 强制执行这些保证，您可以放弃保证的安全性，以换取更高的性能或与另一种语言或硬件接口的能力，这些语言或硬件不受 Rust 的保证约束。</p>
<p data-x-en="Listing 20-1 shows how to create an immutable and a mutable raw pointer.">列表 20-1 显示了如何创建不可变和可变的原始指针。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-1: Creating raw pointers with the raw borrow operators</figcaption>
</figure>
<p data-x-en="Notice that we don’t include the unsafe keyword in this code. We can create raw pointers in safe code; we just can’t dereference raw pointers outside an unsafe block, as you’ll see in a bit.">请注意，我们在代码中没有包含 <code>unsafe</code> 关键字。我们可以在安全代码中创建原始指针；我们只是不能在 <code>unsafe</code> 块之外解引用原始指针，你将在稍后看到这一点。</p>
<p data-x-en="We’ve created raw pointers by using the raw borrow operators: &amp;raw const num creates a *const i32 immutable raw pointer, and &amp;raw mut num creates a *mut i32 mutable raw pointer. Because we created them directly from a local variable, we know these particular raw pointers are valid, but we can’t make that assumption about just any raw pointer.">我们通过使用原始借用操作符创建了原始指针：<code>&amp;raw const num</code> 创建一个 <code>*const i32</code> 不可变原始指针，而 <code>&amp;raw mut num</code> 创建一个 <code>*mut i32</code> 可变原始指针。因为它们是直接从一个局部变量创建的，我们知道这些特定的原始指针是有效的，但我们不能对任何原始指针都做出这样的假设。</p>
<p data-x-en="To demonstrate this, next we’ll create a raw pointer whose validity we can’t be so certain of, using as to cast a value instead of using the raw borrow operators. Listing 20-2 shows how to create a raw pointer to an arbitrary location in memory. Trying to use arbitrary memory is undefined: there might be data at that address or there might not, the compiler might optimize the code so there is no memory access, or the program might terminate with a segmentation fault. Usually, there is no good reason to write code like this, especially in cases where you can use a raw borrow operator instead, but it is possible.">为了演示这一点，接下来我们将创建一个原始指针，其有效性我们不能那么确定，使用 <code>as</code> 将值进行类型转换，而不是使用原始借用操作符。列表 20-2 展示了如何创建指向内存中任意位置的原始指针。尝试使用任意内存是未定义的：该地址可能有数据，也可能没有，编译器可能会优化代码以不访问内存，或者程序可能会以段错误终止。通常，编写这样的代码没有充分的理由，特别是在可以使用原始借用操作符的情况下，但这是可能的。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-2: Creating a raw pointer to an arbitrary memory address</figcaption>
</figure>
<p data-x-en="Recall that we can create raw pointers in safe code, but we can’t dereference raw pointers and read the data being pointed to. In Listing 20-3, we use the dereference operator * on a raw pointer that requires an unsafe block.">回想一下，我们可以在安全代码中创建原始指针，但我们不能<em>解引用</em>
原始指针并读取被指向的数据。在示例 20-3 中，我们对需要一个 <code>unsafe</code> 块的原始指针使用了解引用运算符 <code>*</code>。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-3: Dereferencing raw pointers within an <code>unsafe</code> block</figcaption>
</figure>
<p data-x-en="Creating a pointer does no harm; it’s only when we try to access the value that it points at that we might end up dealing with an invalid value.">创建指针本身并无害；只有当我们尝试访问它所指向的值时，我们才可能会遇到无效值。</p>
<p data-x-en="Note also that in Listing 20-1 and 20-3, we created *const i32 and *mut i32 raw pointers that both pointed to the same memory location, where num is stored. If we instead tried to create an immutable and a mutable reference to num, the code would not have compiled because Rust’s ownership rules don’t allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!">请注意，在清单 20-1 和 20-3 中，我们创建了 <code>*const i32</code> 和 <code>*mut i32</code>
原始指针，它们都指向存储 <code>num</code> 的同一内存位置。如果我们尝试创建一个不可变引用和一个可变引用到 <code>num</code>，代码将无法编译，因为 Rust 的所有权规则不允许同时存在可变引用和任何不可变引用。使用原始指针，我们可以创建一个可变指针和一个不可变指针到同一位置，并通过可变指针更改数据，这可能会导致数据竞争。小心！</p>
<p data-x-en="With all of these dangers, why would you ever use raw pointers? One major use case is when interfacing with C code, as you’ll see in the next section, “Calling an Unsafe Function or Method.” Another case is when building up safe abstractions that the borrow checker doesn’t understand. We’ll introduce unsafe functions and then look at an example of a safe abstraction that uses unsafe code.">有了所有这些危险，为什么还要使用原始指针？一个主要的用例是在与C代码接口时，正如你将在下一节中看到的，
<a href="#calling-an-unsafe-function-or-method">“调用不安全的函数或方法。”</a><!-- ignore --> 另一个用例是在构建借用检查器不理解的安全抽象时。
我们将介绍不安全的函数，然后看一个使用不安全代码的安全抽象示例。</p>
<h3 id="calling-an-unsafe-function-or-method"><a class="header" href="#calling-an-unsafe-function-or-method">调用不安全的函数或方法</a></h3>
<p data-x-en="The second type of operation you can perform in an unsafe block is calling unsafe functions. Unsafe functions and methods look exactly like regular functions and methods, but they have an extra unsafe before the rest of the definition. The unsafe keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can’t guarantee we’ve met these requirements. By calling an unsafe function within an unsafe block, we’re saying that we’ve read this function’s documentation and we take responsibility for upholding the function’s contracts.">在unsafe块中可以执行的第二种操作是调用unsafe函数。Unsafe函数和方法看起来与普通的函数和方法完全一样，但它们在定义的其余部分之前有一个额外的<code>unsafe</code>。在这种上下文中，<code>unsafe</code>关键字表示该函数有我们需要在调用此函数时遵守的要求，因为Rust不能保证我们已经满足了这些要求。通过在<code>unsafe</code>块中调用unsafe函数，我们表示我们已经阅读了此函数的文档，并且我们负责遵守函数的契约。</p>
<p data-x-en="Here is an unsafe function named dangerous that doesn’t do anything in its body:">这里是一个名为 <code>dangerous</code> 的不安全函数，其函数体中没有任何操作：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre></pre>
<p data-x-en="We must call the dangerous function within a separate unsafe block. If we try to call dangerous without the unsafe block, we’ll get an error:">我们必须在单独的 <code>unsafe</code> 块中调用 <code>dangerous</code> 函数。如果我们尝试在没有 <code>unsafe</code> 块的情况下调用 <code>dangerous</code>，我们将得到一个错误：</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p data-x-en="With the unsafe block, we’re asserting to Rust that we’ve read the function’s documentation, we understand how to use it properly, and we’ve verified that we’re fulfilling the contract of the function.">通过<code>unsafe</code>代码块，我们向Rust断言我们已经阅读了函数的文档，我们理解如何正确使用它，并且我们已经验证了我们正在履行函数的契约。</p>
<p data-x-en="To perform unsafe operations in the body of an unsafe function, you still need to use an unsafe block, just as within a regular function, and the compiler will warn you if you forget. This helps to keep unsafe blocks as small as possible, as unsafe operations may not be needed across the whole function body.">要在不安全函数的主体中执行不安全操作，您仍然需要使用<code>unsafe</code>块，就像在普通函数中一样，如果忘记了，编译器会警告您。这有助于将<code>unsafe</code>块保持尽可能小，因为整个函数体可能不需要不安全操作。</p>
<h4 id="creating-a-safe-abstraction-over-unsafe-code"><a class="header" href="#creating-a-safe-abstraction-over-unsafe-code">在不安全代码上创建安全抽象</a></h4>
<p data-x-en="Just because a function contains unsafe code doesn’t mean we need to mark the entire function as unsafe. In fact, wrapping unsafe code in a safe function is a common abstraction. As an example, let’s study the split_at_mut function from the standard library, which requires some unsafe code. We’ll explore how we might implement it. This safe method is defined on mutable slices: it takes one slice and makes it two by splitting the slice at the index given as an argument. Listing 20-4 shows how to use split_at_mut.">仅仅因为一个函数包含不安全的代码，并不意味着我们需要将整个函数标记为不安全。事实上，将不安全的代码包装在安全的函数中是一种常见的抽象。例如，让我们研究一下标准库中的 <code>split_at_mut</code> 函数，它需要一些不安全的代码。我们将探讨如何实现它。这个安全方法定义在可变切片上：它接受一个切片并通过在给定的索引处分割切片来将其变成两个。列表 20-4 显示了如何使用 <code>split_at_mut</code>。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-4: Using the safe <code>split_at_mut</code> function</figcaption>
</figure>
<p data-x-en="We can’t implement this function using only safe Rust. An attempt might look something like Listing 20-5, which won’t compile. For simplicity, we’ll implement split_at_mut as a function rather than a method and only for slices of i32 values rather than for a generic type T.">我们不能仅使用安全的 Rust 来实现这个函数。尝试实现可能看起来像列表 20-5，但这不会编译。为了简单起见，我们将实现 <code>split_at_mut</code> 作为函数而不是方法，并且只针对 <code>i32</code> 类型的切片，而不是泛型 <code>T</code>。</p>
<figure class="listing">
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre>
<figcaption>Listing 20-5: An attempted implementation of <code>split_at_mut</code> using only safe Rust</figcaption>
</figure>
<p data-x-en="This function first gets the total length of the slice. Then it asserts that the index given as a parameter is within the slice by checking whether it’s less than or equal to the length. The assertion means that if we pass an index that is greater than the length to split the slice at, the function will panic before it attempts to use that index.">这个函数首先获取切片的总长度。然后它通过检查索引是否小于或等于长度来断言作为参数给出的索引在切片范围内。这个断言意味着，如果我们传递一个大于长度的索引来分割切片，函数将在尝试使用该索引之前崩溃。</p>
<p data-x-en="Then we return two mutable slices in a tuple: one from the start of the original slice to the mid index and another from mid to the end of the slice.">然后我们返回一个元组，其中包含两个可变切片：一个从原始切片的开始到<code>mid</code>索引，另一个从<code>mid</code>到切片的末尾。</p>
<p data-x-en="When we try to compile the code in Listing 20-5, we’ll get an error.">当我们尝试编译列表 20-5 中的代码时，我们会遇到一个错误。</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`
  |
  = help: use `.split_at_mut(position)` to obtain two mutable non-overlapping sub-slices

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p data-x-en="Rust’s borrow checker can’t understand that we’re borrowing different parts of the slice; it only knows that we’re borrowing from the same slice twice. Borrowing different parts of a slice is fundamentally okay because the two slices aren’t overlapping, but Rust isn’t smart enough to know this. When we know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.">Rust 的借用检查器无法理解我们正在借用切片的不同部分；它只知道我们正在从同一个切片中借用两次。借用切片的不同部分本质上是没问题的，因为这两个切片并不重叠，但 Rust 并不够智能来理解这一点。当我们知道代码是安全的，但 Rust 却不知道时，就该使用不安全的代码了。</p>
<p data-x-en="Listing 20-6 shows how to use an unsafe block, a raw pointer, and some calls to unsafe functions to make the implementation of split_at_mut work.">列表 20-6 显示了如何使用 <code>unsafe</code> 块、原始指针和一些不安全函数的调用来使 <code>split_at_mut</code> 的实现工作。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-6: Using unsafe code in the implementation of the <code>split_at_mut</code> function</figcaption>
</figure>
<p data-x-en="Recall from “The Slice Type” in Chapter 4 that slices are a pointer to some data and the length of the slice. We use the len method to get the length of a slice and the as_mut_ptr method to access the raw pointer of a slice. In this case, because we have a mutable slice to i32 values, as_mut_ptr returns a raw pointer with the type *mut i32, which we’ve stored in the variable ptr.">回想第 4 章<a href="ch04-03-slices.html#the-slice-type">“切片类型”</a><!-- ignore -->中
切片是指向某些数据的指针和切片的长度。我们使用<code>len</code>
方法获取切片的长度，使用<code>as_mut_ptr</code>方法访问切片的原始指针。在这种情况下，因为我们有一个可变的<code>i32</code>
值切片，<code>as_mut_ptr</code>返回一个类型为<code>*mut i32</code>的原始指针，我们将其存储在变量<code>ptr</code>中。</p>
<p data-x-en="We keep the assertion that the mid index is within the slice. Then we get to the unsafe code: the slice::from_raw_parts_mut function takes a raw pointer and a length, and it creates a slice. We use it to create a slice that starts from ptr and is mid items long. Then we call the add method on ptr with mid as an argument to get a raw pointer that starts at mid, and we create a slice using that pointer and the remaining number of items after mid as the length.">我们保持 <code>mid</code> 索引在切片内的断言。然后我们进入不安全的代码：<code>slice::from_raw_parts_mut</code> 函数接受一个原始指针和一个长度，并创建一个切片。我们用它来创建一个从 <code>ptr</code> 开始且长度为 <code>mid</code> 的切片。然后我们在 <code>ptr</code> 上调用 <code>add</code> 方法，参数为 <code>mid</code>，以获取一个从 <code>mid</code> 开始的原始指针，并使用该指针和 <code>mid</code> 之后剩余的项目数作为长度来创建一个切片。</p>
<p data-x-en="The function slice::from_raw_parts_mut is unsafe because it takes a raw pointer and must trust that this pointer is valid. The add method on raw pointers is also unsafe because it must trust that the offset location is also a valid pointer. Therefore, we had to put an unsafe block around our calls to slice::from_raw_parts_mut and add so we could call them. By looking at the code and by adding the assertion that mid must be less than or equal to len, we can tell that all the raw pointers used within the unsafe block will be valid pointers to data within the slice. This is an acceptable and appropriate use of unsafe.">函数 <code>slice::from_raw_parts_mut</code> 是不安全的，因为它接受一个原始指针，并且必须信任这个指针是有效的。原始指针上的 <code>add</code> 方法也是不安全的，因为它必须信任偏移位置也是一个有效的指针。因此，我们必须在调用 <code>slice::from_raw_parts_mut</code> 和 <code>add</code> 时将它们放在一个 <code>unsafe</code> 块中。通过查看代码并添加 <code>mid</code> 必须小于或等于 <code>len</code> 的断言，我们可以确定在 <code>unsafe</code> 块中使用的所有原始指针都是指向切片内数据的有效指针。这是一个合理且适当的 <code>unsafe</code> 用法。</p>
<p data-x-en="Note that we don’t need to mark the resultant split_at_mut function as unsafe, and we can call this function from safe Rust. We’ve created a safe abstraction to the unsafe code with an implementation of the function that uses unsafe code in a safe way, because it creates only valid pointers from the data this function has access to.">请注意，我们不需要将结果的 <code>split_at_mut</code> 函数标记为 <code>unsafe</code>，并且我们可以从安全的 Rust 代码中调用此函数。我们已经创建了一个安全的抽象，该抽象通过以安全方式使用 <code>unsafe</code> 代码的函数实现来实现，因为它仅从该函数可以访问的数据中创建有效的指针。</p>
<p data-x-en="In contrast, the use of slice::from_raw_parts_mut in Listing 20-7 would likely crash when the slice is used. This code takes an arbitrary memory location and creates a slice 10,000 items long.">相比之下，清单 20-7 中使用 <code>slice::from_raw_parts_mut</code> 很可能在使用切片时崩溃。此代码获取一个任意的内存位置并创建一个长度为 10,000 的切片。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
<figcaption>Listing 20-7: Creating a slice from an arbitrary memory location</figcaption>
</figure>
<p data-x-en="We don’t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid i32 values. Attempting to use values as though it’s a valid slice results in undefined behavior.">我们不拥有这个任意位置的内存，也没有保证这段代码创建的切片包含有效的<code>i32</code>值。尝试将<code>values</code>作为有效切片使用会导致未定义行为。</p>
<h4 id="using-extern-functions-to-call-external-code"><a class="header" href="#using-extern-functions-to-call-external-code">使用 <code>extern</code> 函数调用外部代码</a></h4>
<p data-x-en="Sometimes, your Rust code might need to interact with code written in another language. For this, Rust has the keyword extern that facilitates the creation and use of a Foreign Function Interface (FFI). An FFI is a way for a programming language to define functions and enable a different (foreign) programming language to call those functions.">有时，您的 Rust 代码可能需要与用其他语言编写的代码进行交互。为此，Rust 有关键字 <code>extern</code>，它有助于创建和使用 <em>Foreign Function Interface (FFI)</em>。FFI 是一种编程语言定义函数并使另一种（外部）编程语言能够调用这些函数的方式。</p>
<p data-x-en="Listing 20-8 demonstrates how to set up an integration with the abs function from the C standard library. Functions declared within extern blocks are generally unsafe to call from Rust code, so extern blocks must also be marked unsafe. The reason is that other languages don’t enforce Rust’s rules and guarantees, and Rust can’t check them, so responsibility falls on the programmer to ensure safety.">列表 20-8 展示了如何设置与 C 标准库中的 <code>abs</code> 函数的集成。在 <code>extern</code> 块中声明的函数通常从 Rust 代码调用时是不安全的，因此 <code>extern</code> 块也必须标记为 <code>unsafe</code>。原因是其他语言不会强制执行 Rust 的规则和保证，而 Rust 也无法检查它们，因此确保安全性的责任落在程序员身上。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">unsafe extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}</code></pre></pre>
<figcaption>Listing 20-8: Declaring and calling an <code>extern</code> function defined in another language</figcaption>
</figure>
<p data-x-en="Within the unsafe extern &quot;C&quot; block, we list the names and signatures of external functions from another language we want to call. The &quot;C&quot; part defines which application binary interface (ABI) the external function uses: the ABI defines how to call the function at the assembly level. The &quot;C&quot; ABI is the most common and follows the C programming language’s ABI. Information about all the ABIs Rust supports is available in the Rust Reference.">在 <code>unsafe extern "C"</code> 块中，我们列出想要调用的来自其他语言的外部函数的名称和签名。<code>"C"</code> 部分定义了外部函数使用的 <em>应用程序二进制接口 (ABI)</em>：ABI 定义了如何在汇编级别调用函数。<code>"C"</code> ABI 是最常见的一种，遵循 C 编程语言的 ABI。有关 Rust 支持的所有 ABI 的信息，请参阅 <a href="https://doc.rust-lang.org/reference/items/external-blocks.html#abi" target="_blank">Rust 参考手册</a>。</p>
<p data-x-en="Every item declared within an unsafe extern block is implicitly unsafe. However, some FFI functions are safe to call. For example, the abs function from C’s standard library does not have any memory safety considerations and we know it can be called with any i32. In cases like this, we can use the safe keyword to say that this specific function is safe to call even though it is in an unsafe extern block. Once we make that change, calling it no longer requires an unsafe block, as shown in Listing 20-9.">在 <code>unsafe extern</code> 块中声明的每个项都隐式地是 <code>unsafe</code> 的。
然而，一些 FFI 函数 <em>是</em> 安全调用的。例如，C 标准库中的 <code>abs</code> 函数没有任何内存安全问题，我们知道它可以使用任何 <code>i32</code> 调用。在这种情况下，我们可以使用 <code>safe</code> 关键字来说明这个特定的函数即使在 <code>unsafe extern</code> 块中也是安全调用的。一旦我们做了这个更改，调用它就不再需要 <code>unsafe</code> 块，如清单 20-9 所示。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">unsafe extern "C" {
    safe fn abs(input: i32) -&gt; i32;
}

fn main() {
    println!("Absolute value of -3 according to C: {}", abs(-3));
}</code></pre></pre>
<figcaption>Listing 20-9: Explicitly marking a function as <code>safe</code> within an <code>unsafe extern</code> block and calling it safely</figcaption>
</figure>
<p data-x-en="Marking a function as safe does not inherently make it safe! Instead, it is like a promise you are making to Rust that it is safe. It is still your responsibility to make sure that promise is kept!">将函数标记为<code>safe</code>并不会使其本身变得安全！相反，这像是你对Rust做出的一个承诺，即它是<em>安全的</em>。你仍然有责任确保这个承诺得以兑现！</p>
<section class="note" aria-role="note">
<h4 id="calling-rust-functions-from-other-languages"><a class="header" href="#calling-rust-functions-from-other-languages">从其他语言调用Rust函数</a></h4>
<p data-x-en="We can also use extern to create an interface that allows other languages to call Rust functions. Instead of creating a whole extern block, we add the extern keyword and specify the ABI to use just before the fn keyword for the relevant function. We also need to add an #[unsafe(no_mangle)] annotation to tell the Rust compiler not to mangle the name of this function. Mangling is when a compiler changes the name we’ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler’s name mangling. This is unsafe because there might be name collisions across libraries without the built-in mangling, so it is our responsibility to make sure the name we choose is safe to export without mangling.">我们还可以使用 <code>extern</code> 创建一个接口，允许其他语言调用 Rust 函数。我们不需要创建一个完整的 <code>extern</code> 块，而是在相关函数的 <code>fn</code> 关键字之前添加 <code>extern</code> 关键字并指定要使用的 ABI。我们还需要添加一个 <code>#[unsafe(no_mangle)]</code> 注解，以告诉 Rust 编译器不要对这个函数的名称进行名称修饰。名称修饰是指编译器将我们给定的函数名称更改为包含更多信息的另一个名称，这些信息供编译过程的其他部分使用，但可读性较差。每种编程语言的编译器对名称的修饰方式略有不同，因此为了让 Rust 函数能够被其他语言命名，我们必须禁用 Rust 编译器的名称修饰。这是不安全的，因为没有内置的名称修饰，库之间可能会发生名称冲突，因此我们必须确保选择的名称在不进行名称修饰的情况下是安全导出的。</p>
<p data-x-en="In the following example, we make the call_from_c function accessible from C code, after it’s compiled to a shared library and linked from C:">在以下示例中，我们将 <code>call_from_c</code> 函数编译为共享库并从 C 代码链接后，使其可以从 C 代码访问：</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[unsafe(no_mangle)]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
<span class="boring">}</span></code></pre></pre>
<p data-x-en="This usage of extern requires unsafe only in the attribute, not on the extern block.">这种 <code>extern</code> 的用法只需要在属性中使用 <code>unsafe</code>，而不需要在 <code>extern</code> 块上使用。</p>
</section>
<h3 id="accessing-or-modifying-a-mutable-static-variable"><a class="header" href="#accessing-or-modifying-a-mutable-static-variable">访问或修改可变静态变量</a></h3>
<p data-x-en="In this book, we’ve not yet talked about global variables, which Rust does support but can be problematic with Rust’s ownership rules. If two threads are accessing the same mutable global variable, it can cause a data race.">在本书中，我们还没有讨论<em>全局变量</em>，虽然 Rust 确实支持全局变量，但它们可能会与 Rust 的所有权规则产生冲突。如果两个线程访问同一个可变全局变量，可能会导致数据竞争。</p>
<p data-x-en="In Rust, global variables are called static variables. Listing 20-10 shows an example declaration and use of a static variable with a string slice as a value.">在 Rust 中，全局变量被称为 <em>静态</em> 变量。列表 20-10 显示了一个使用字符串切片作为值的静态变量的声明和使用示例。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">static HELLO_WORLD: &amp;str = "Hello, world!";

fn main() {
    println!("name is: {HELLO_WORLD}");
}</code></pre></pre>
<figcaption>Listing 20-10: Defining and using an immutable static variable</figcaption>
</figure>
<p data-x-en="Static variables are similar to constants, which we discussed in “Constants” in Chapter 3. The names of static variables are in SCREAMING_SNAKE_CASE by convention. Static variables can only store references with the 'static lifetime, which means the Rust compiler can figure out the lifetime and we aren’t required to annotate it explicitly. Accessing an immutable static variable is safe.">静态变量类似于我们在<a href="ch03-01-variables-and-mutability.html#constants">“常量”</a><!-- ignore -->中讨论的常量。按照惯例，静态变量的名称使用<code>SCREAMING_SNAKE_CASE</code>。静态变量只能存储具有<code>'static</code>生命周期的引用，这意味着Rust编译器可以推断出生命周期，我们不需要显式地标注它。访问不可变的静态变量是安全的。</p>
<p data-x-en="A subtle difference between constants and immutable static variables is that values in a static variable have a fixed address in memory. Using the value will always access the same data. Constants, on the other hand, are allowed to duplicate their data whenever they’re used. Another difference is that static variables can be mutable. Accessing and modifying mutable static variables is unsafe. Listing 20-11 shows how to declare, access, and modify a mutable static variable named COUNTER.">常量和不可变静态变量之间的一个细微差别是，静态变量中的值在内存中有一个固定的地址。使用该值将始终访问相同的数据。另一方面，常量在使用时允许复制其数据。另一个不同之处在于静态变量可以是可变的。访问和修改可变静态变量是<em>不安全的</em>。列表 20-11 显示了如何声明、访问和修改一个名为 <code>COUNTER</code> 的可变静态变量。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust edition2024">static mut COUNTER: u32 = 0;

/// SAFETY: Calling this from more than a single thread at a time is undefined
/// behavior, so you *must* guarantee you only call it from a single thread at
/// a time.
unsafe fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    unsafe {
        // SAFETY: This is only called from a single thread in `main`.
        add_to_count(3);
        println!("COUNTER: {}", *(&amp;raw const COUNTER));
    }
}</code></pre></pre>
<figcaption>Listing 20-11: Reading from or writing to a mutable static variable is unsafe</figcaption>
</figure>
<p data-x-en="As with regular variables, we specify mutability using the mut keyword. Any code that reads or writes from COUNTER must be within an unsafe block. This code compiles and prints COUNTER: 3 as we would expect because it’s single threaded. Having multiple threads access COUNTER would likely result in data races, so it is undefined behavior. Therefore, we need to mark the entire function as unsafe, and document the safety limitation, so anyone calling the function knows what they are and are not allowed to do safely.">与常规变量一样，我们使用 <code>mut</code> 关键字指定可变性。任何读取或写入 <code>COUNTER</code> 的代码都必须在 <code>unsafe</code> 块中。这段代码编译并打印 <code>COUNTER: 3</code>，正如我们所期望的那样，因为它是在单线程中运行的。如果多个线程访问 <code>COUNTER</code>，可能会导致数据竞争，因此这是未定义的行为。因此，我们需要将整个函数标记为 <code>unsafe</code>，并记录安全限制，以便调用该函数的任何人都知道他们可以和不可以安全地做什么。</p>
<p data-x-en="Whenever we write an unsafe function, it is idiomatic to write a comment starting with SAFETY and explaining what the caller needs to do to call the function safely. Likewise, whenever we perform an unsafe operation, it is idiomatic to write a comment starting with SAFETY to explain how the safety rules are upheld.">每当我们编写一个不安全的函数时，习惯上会写一个以 <code>SAFETY</code> 开头的注释，解释调用者需要做什么才能安全地调用该函数。同样，每当执行不安全操作时，习惯上也会写一个以 <code>SAFETY</code> 开头的注释，解释如何遵守安全规则。</p>
<p data-x-en="Additionally, the compiler will not allow you to create references to a mutable static variable. You can only access it via a raw pointer, created with one of the raw borrow operators. That includes in cases where the reference is created invisibly, as when it is used in the println! in this code listing. The requirement that references to static mutable variables can only be created via raw pointers helps make the safety requirements for using them more obvious.">此外，编译器不允许你创建指向可变静态变量的引用。你只能通过原始指针访问它，而原始指针是使用其中一个原始借用操作符创建的。这包括在引用被隐式创建的情况下，例如在本代码列表中的 <code>println!</code> 中使用时。要求只能通过原始指针创建对静态可变变量的引用，有助于使使用它们的安全要求更加明显。</p>
<p data-x-en="With mutable data that is globally accessible, it’s difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe. Where possible, it’s preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so the compiler checks that data access from different threads is done safely.">对于全局可访问的可变数据，很难确保没有数据竞争，这就是为什么 Rust 认为可变静态变量是不安全的。在可能的情况下，最好使用我们在第 16 章中讨论的并发技术和线程安全的智能指针，以便编译器检查从不同线程访问数据是否安全。</p>
<h3 id="implementing-an-unsafe-trait"><a class="header" href="#implementing-an-unsafe-trait">实现一个不安全的特质</a></h3>
<p data-x-en="We can use unsafe to implement an unsafe trait. A trait is unsafe when at least one of its methods has some invariant that the compiler can’t verify. We declare that a trait is unsafe by adding the unsafe keyword before trait and marking the implementation of the trait as unsafe too, as shown in Listing 20-12.">我们可以使用 <code>unsafe</code> 来实现一个不安全的特质。当特质的至少一个方法具有一些编译器无法验证的不变量时，该特质就是不安全的。我们通过在 <code>trait</code> 前添加 <code>unsafe</code> 关键字来声明一个特质是 <code>unsafe</code> 的，并且也将特质的实现标记为 <code>unsafe</code>，如清单 20-12 所示。</p>
<figure class="listing">
<pre><pre class="playground"><code class="language-rust edition2024">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<figcaption>Listing 20-12: Defining and implementing an unsafe trait</figcaption>
</figure>
<p data-x-en="By using unsafe impl, we’re promising that we’ll uphold the invariants that the compiler can’t verify.">通过使用 <code>unsafe impl</code>，我们承诺将维护编译器无法验证的不变性。</p>
<p data-x-en="As an example, recall the Sync and Send marker traits we discussed in “Extensible Concurrency with the Sync and Send Traits” in Chapter 16: the compiler implements these traits automatically if our types are composed entirely of other types that implement Send and Sync. If we implement a type that contains a type that does not implement Send or Sync, such as raw pointers, and we want to mark that type as Send or Sync, we must use unsafe. Rust can’t verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads; therefore, we need to do those checks manually and indicate as such with unsafe.">例如，回想我们在<a href="ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">“使用 <code>Sync</code> 和 <code>Send</code> 特性实现可扩展的并发”</a>中讨论的 <code>Sync</code> 和 <code>Send</code> 标记特性：如果我们的类型完全由实现了 <code>Send</code> 和 <code>Sync</code> 的其他类型组成，编译器会自动实现这些特性。如果我们实现的类型包含一个未实现 <code>Send</code> 或 <code>Sync</code> 的类型，例如原始指针，并且我们希望将该类型标记为 <code>Send</code> 或 <code>Sync</code>，我们必须使用 <code>unsafe</code>。Rust 无法验证我们的类型是否满足可以安全地跨线程发送或从多个线程访问的保证；因此，我们需要手动进行这些检查，并使用 <code>unsafe</code> 指示这一点。</p>
<h3 id="accessing-fields-of-a-union"><a class="header" href="#accessing-fields-of-a-union">访问联合体的字段</a></h3>
<p data-x-en="The final action that works only with unsafe is accessing fields of a union. A union is similar to a struct, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. Accessing union fields is unsafe because Rust can’t guarantee the type of the data currently being stored in the union instance. You can learn more about unions in the Rust Reference.">最后一种仅与 <code>unsafe</code> 一起使用的行为是访问 <em>联合体</em> 的字段。一个 <code>union</code> 类似于一个 <code>struct</code>，但在特定实例中一次只能使用一个声明的字段。联合体主要用于与 C 代码中的联合体进行接口。访问联合体字段是不安全的，因为 Rust 无法保证当前存储在联合体实例中的数据类型。您可以在 <a href="https://doc.rust-lang.org/reference/items/unions.html" target="_blank">Rust 参考手册</a> 中了解有关联合体的更多信息。</p>
<h3 id="using-miri-to-check-unsafe-code" data-x-en="Using Miri to Check Unsafe Code"><a class="header" href="#using-miri-to-check-unsafe-code">使用Miri检查不安全代码</a></h3>
<p data-x-en="When writing unsafe code, you might want to check that what you have written actually is safe and correct. One of the best ways to do that is to use Miri, an official Rust tool for detecting undefined behavior. Whereas the borrow checker is a static tool that works at compile time, Miri is a dynamic tool that works at runtime. It checks your code by running your program, or its test suite, and detecting when you violate the rules it understands about how Rust should work.">在编写不安全代码时，您可能希望检查您编写的内容实际上是安全和正确的。做到这一点的最好方法之一是使用Miri，这是一种官方的Rust工具，用于检测未定义行为。虽然借用检查器是一种在编译时工作的<em>静态</em>工具，但Miri是一种在运行时工作的<em>动态</em>工具。它通过运行您的程序或其测试套件，并检测您违反其理解的Rust应如何工作的规则来检查您的代码。</p>
<p data-x-en="Using Miri requires a nightly build of Rust (which we talk about more in Appendix G: How Rust is Made and “Nightly Rust”). You can install both a nightly version of Rust and the Miri tool by typing rustup +nightly component add miri. This does not change what version of Rust your project uses; it only adds the tool to your system so you can use it when you want to. You can run Miri on a project by typing cargo +nightly miri run or cargo +nightly miri test.">使用Miri需要Rust的夜间构建版本（我们将在<a href="appendix-07-nightly-rust.html">附录G：Rust的制作和“夜间Rust”</a>中详细讨论）。您可以通过键入<code>rustup +nightly component add miri</code>来安装Rust的夜间版本和Miri工具。这不会更改您的项目使用的Rust版本；它只是将工具添加到您的系统中，以便您在需要时可以使用它。
您可以通过键入<code>cargo +nightly miri run</code>或<code>cargo +nightly miri test</code>在项目上运行Miri。</p>
<p data-x-en="For an example of how helpful this can be, consider what happens when we run it against Listing 20-11.">为了举例说明这有多有帮助，考虑一下当我们将其运行在示例 20-11 上时会发生什么。</p>
<pre><code class="language-console">$ cargo +nightly miri run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `file:///home/.rustup/toolchains/nightly/bin/cargo-miri runner target/miri/debug/unsafe-example`
COUNTER: 3
</code></pre>
<p data-x-en="Miri correctly warns us that we have shared references to mutable data. Here, Miri issues only a warning because this is not guaranteed to be undefined behavior in this case, and it does not tell us how to fix the problem. but at least we know there is a risk of undefined behavior and can think about how to make the code safe. In some cases, Miri can also detect outright errors—code patterns that are sure to be wrong—and make recommendations about how to fix those errors.">Miri 正确地警告我们，我们对可变数据有共享引用。在这里，Miri 仅发出警告，因为在这种情况下这不一定是未定义行为，并且它没有告诉我们如何修复问题。但至少我们知道存在未定义行为的风险，并可以考虑如何使代码安全。在某些情况下，Miri 还可以检测出明显的错误——肯定是错误的代码模式——并提出关于如何修复这些错误的建议。<em>sure</em></p>
<p data-x-en="Miri doesn’t catch everything you might get wrong when writing unsafe code. Miri is a dynamic analysis tool, so it only catches problems with code that actually gets run. That means you will need to use it in conjunction with good testing techniques to increase your confidence about the unsafe code you have written. Miri also does not cover every possible way your code can be unsound.">Miri 并不能捕捉到你在编写不安全代码时可能犯的所有错误。Miri 是一个动态分析工具，因此它只能捕捉到实际运行的代码中的问题。这意味着你需要将其与良好的测试技术结合使用，以提高你对你编写的不安全代码的信心。Miri 也不能覆盖你的代码可能存在的所有不安全方式。</p>
<p data-x-en="Put another way: If Miri does catch a problem, you know there’s a bug, but just because Miri doesn’t catch a bug doesn’t mean there isn’t a problem. It can catch a lot, though. Try running it on the other examples of unsafe code in this chapter and see what it says!">换句话说：如果 MIRI <em>确实</em> 捕获到一个问题，你就知道有 bug，但
仅仅因为 MIRI <em>没有</em> 捕获到 bug 并不意味着没有问题。它
可以捕获很多问题。尝试在本章其他不安全代码示例上运行它，看看它怎么说！</p>
<p data-x-en="You can learn more about Miri at its GitHub repository.">您可以在<a href="https://github.com/rust-lang/miri">其 GitHub 仓库</a>了解更多关于 Miri 的信息。</p>
<h3 id="when-to-use-unsafe-code"><a class="header" href="#when-to-use-unsafe-code">何时使用不安全代码</a></h3>
<p data-x-en="Using unsafe to use one of the five superpowers just discussed isn’t wrong or even frowned upon, but it is trickier to get unsafe code correct because the compiler can’t help uphold memory safety. When you have a reason to use unsafe code, you can do so, and having the explicit unsafe annotation makes it easier to track down the source of problems when they occur. Whenever you write unsafe code, you can use Miri to help you be more confident that the code you have written upholds Rust’s rules.">使用 <code>unsafe</code> 来使用上述五个超级能力之一并不是错误的，甚至也不被反对，但要使 <code>unsafe</code> 代码正确会更棘手，因为编译器无法帮助维护内存安全。当你有理由使用 <code>unsafe</code> 代码时，你可以这样做，而显式的 <code>unsafe</code> 注解使得在出现问题时更容易追踪问题的来源。每当你编写不安全的代码时，你可以使用 Miri 来帮助你更有信心地确保你编写的代码符合 Rust 的规则。</p>
<p data-x-en="For a much deeper exploration of how to work effectively with unsafe Rust, read Rust’s official guide to the subject, the Rustonomicon.">对于如何有效地使用不安全的 Rust 进行更深入的探索，请阅读 Rust 的官方指南，<a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-00-advanced-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-02-advanced-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-00-advanced-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-02-advanced-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    

</body></html>