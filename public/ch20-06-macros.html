<!DOCTYPE html><html lang="zh-CN" class="light sidebar-visible" dir="ltr"><head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>宏 - 《Rust 编程语言》</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    <meta name="title" content="Rust 中文"><meta property="og:title" content="Rust 中文"><meta name="description" content="Rust 中文文档"><meta property="og:description" content="Rust 中文文档"><meta name="url" content="https://rust.xheldon.com"><meta property="og:url" content="https://rust.xheldon.com"><script src="https://www.googletagmanager.com/gtag/js?id=G-V7NE1X37EX"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-V7NE1X37EX')</script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486286026923411"></script><style>/* hover 显示原文 */
p[data-x-en],
li[data-x-en] {
  position: relative;
}
p[data-x-en]:hover::after,
li[data-x-en]:hover::after {
  visibility: visible;
  opacity: 1;
}
p[data-x-en]::after,
li[data-x-en]::after {
  content: attr(data-x-en);
  display: block;
  font-size: 12px;
  transition: all 0.2s 0.3s;
  visibility: hidden;
  opacity: 0;
  background: #cccccc;
  z-index: 99;
  border-radius: 4px;
  padding: 5px 10px;
  position: absolute;
  top: 100%;
  left: 0;
}
/* 译者注释内容 */
div[type='comment'] {
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  background: #eee;
}
div[type='comment']::before {
  content: '译者注: ';
  font-weight: 900;
}
header a.logo {
  position: relative;
}
header a.logo::after {
  content: '中文';
  position: absolute;
  left: calc(100% + 5px);
  font-size: 12px;
  width: 50px;
  top: -5px;
}
#banner-info {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  background: rgba(255, 255, 255, 0.9);
  font-size: 12px;
  padding: 0;
  z-index: 999;
}
#add-info {
  font-size: 14px;
}
blockquote {
  border-left: 5px solid #ccc;
  padding-left: 10px;
  margin-left: 0;
}
.content {
  overflow-y: unset !important;
}
</style></head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky"><div id="banner-info">本文档为 AI + 人工翻译，hover 可以显示原文。当前页翻译有问题？<a style="cursor: pointer;" href="https://github.com/Xheldon/rust-book-cn/blob/main/dict/ch20-06-macros.json" target="_blank">我来翻译！</a></div>
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    <a href="https://github.com/Xheldon/rust-book-cn" target="_blank"><i class="fa fa-language"></i></a><a href="https://www.xheldon.com" target="_blank"><i class="fa fa-id-card"></i></a></div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="macros"><a class="header" href="#macros">宏</a></h2>
<p data-x-en="We’ve used macros like println! throughout this book, but we haven’t fully explored what a macro is and how it works. The term macro refers to a family of features in Rust: declarative macros with macro_rules! and three kinds of procedural macros:">我们在这本书中使用了像 <code>println!</code> 这样的宏，但还没有完全探讨宏是什么以及它是如何工作的。术语 <em>宏</em> 指的是 Rust 中的一组特性：<em>声明式</em> 宏使用 <code>macro_rules!</code> 以及三种 <em>过程式</em> 宏：</p>
<ul>
<li data-x-en="Custom #[derive] macros that specify code added with the derive attribute used on structs and enums">自定义 <code>#[derive]</code> 宏，用于指定通过 <code>derive</code> 属性添加到结构体和枚举上的代码</li>
<li data-x-en="Attribute-like macros that define custom attributes usable on any item">定义可用于任何项的自定义属性的属性类宏</li>
<li data-x-en="Function-like macros that look like function calls but operate on the tokens specified as their argument">看起来像函数调用但操作其参数指定的标记的函数式宏</li>
</ul>
<p data-x-en="We’ll talk about each of these in turn, but first, let’s look at why we even need macros when we already have functions.">我们将逐一讨论这些内容，但首先，让我们看看为什么在已经有函数的情况下我们还需要宏。</p>
<h3 id="the-difference-between-macros-and-functions"><a class="header" href="#the-difference-between-macros-and-functions">宏和函数之间的区别</a></h3>
<p data-x-en="Fundamentally, macros are a way of writing code that writes other code, which is known as metaprogramming. In Appendix C, we discuss the derive attribute, which generates an implementation of various traits for you. We’ve also used the println! and vec! macros throughout the book. All of these macros expand to produce more code than the code you’ve written manually.">从根本上说，宏是一种编写生成其他代码的代码的方式，这被称为<em>元编程</em>。在附录C中，我们讨论了<code>derive</code>属性，它为你生成各种特征的实现。我们还在书中使用了<code>println!</code>和<code>vec!</code>宏。所有这些宏都会<em>扩展</em>以生成比你手动编写的代码更多的代码。</p>
<p data-x-en="Metaprogramming is useful for reducing the amount of code you have to write and maintain, which is also one of the roles of functions. However, macros have some additional powers that functions don’t.">元编程有助于减少你需要编写和维护的代码量，这也是函数的作用之一。然而，宏具有一些函数不具备的额外功能。</p>
<p data-x-en="A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: we can call println!(&quot;hello&quot;) with one argument or println!(&quot;hello {}&quot;, name) with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can’t, because it gets called at runtime and a trait needs to be implemented at compile time.">一个函数签名必须声明函数的参数数量和类型。另一方面，宏可以接受可变数量的参数：我们可以用一个参数调用<code>println!("hello")</code>，或者用两个参数调用<code>println!("hello {}", name)</code>。此外，宏在编译器解释代码含义之前就会展开，因此宏可以例如在给定类型上实现一个特征。函数则不能，因为函数是在运行时被调用的，而特征需要在编译时实现。</p>
<p data-x-en="The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you’re writing Rust code that writes Rust code. Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.">实现宏而不是函数的缺点是宏定义比函数定义更复杂，因为您编写的Rust代码会生成Rust代码。由于这种间接性，宏定义通常比函数定义更难以阅读、理解和维护。</p>
<p data-x-en="Another important difference between macros and functions is that you must define macros or bring them into scope before you call them in a file, as opposed to functions you can define anywhere and call anywhere.">宏和函数之间的另一个重要区别是，你必须在文件中<em>在调用它们之前</em>定义宏或将它们引入作用域，而函数则可以在任何地方定义并在任何地方调用。</p>
<h3 id="declarative-macros-with-macro_rules-for-general-metaprogramming"><a class="header" href="#declarative-macros-with-macro_rules-for-general-metaprogramming">使用 <code>macro_rules!</code> 进行通用元编程的声明式宏</a></h3>
<p data-x-en="The most widely used form of macros in Rust is the declarative macro. These are also sometimes referred to as “macros by example,” “macro_rules! macros,” or just plain “macros.” At their core, declarative macros allow you to write something similar to a Rust match expression. As discussed in Chapter 6, match expressions are control structures that take an expression, compare the resulting value of the expression to patterns, and then run the code associated with the matching pattern. Macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.">在 Rust 中最广泛使用的宏形式是<em>声明式宏</em>。这些宏有时也被称为“示例宏”，“<code>macro_rules!</code> 宏”，或简称为“宏”。在核心上，声明式宏允许你编写类似于 Rust <code>match</code> 表达式的内容。正如在第 6 章中讨论的，<code>match</code> 表达式是控制结构，它们接受一个表达式，将表达式的结果值与模式进行比较，然后运行与匹配模式相关联的代码。宏也对值进行模式匹配：在这种情况下，值是传递给宏的字面 Rust 源代码；模式与该源代码的结构进行比较；当匹配到模式时，与每个模式相关联的代码将替换传递给宏的代码。这一切都在编译期间发生。</p>
<p data-x-en="To define a macro, you use the macro_rules! construct. Let’s explore how to use macro_rules! by looking at how the vec! macro is defined. Chapter 8 covered how we can use the vec! macro to create a new vector with particular values. For example, the following macro creates a new vector containing three integers:">要定义一个宏，你使用 <code>macro_rules!</code> 构造。让我们通过查看 <code>vec!</code> 宏是如何定义的来探讨如何使用 <code>macro_rules!</code>。第 8 章介绍了我们如何使用 <code>vec!</code> 宏来创建具有特定值的新向量。例如，以下宏创建一个包含三个整数的新向量：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p data-x-en="We could also use the vec! macro to make a vector of two integers or a vector of five string slices. We wouldn’t be able to use a function to do the same because we wouldn’t know the number or type of values up front.">我们也可以使用 <code>vec!</code> 宏来创建包含两个整数的向量或包含五个字符串切片的向量。我们无法使用函数来完成相同的操作，因为我们在一开始不知道值的数量或类型。</p>
<p data-x-en="Listing 20-28 shows a slightly simplified definition of the vec! macro.">列表 20-28 显示了 <code>vec!</code> 宏的一个稍微简化的定义。</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}</code></pre>
<figcaption>Listing 20-28: A simplified version of the <code>vec!</code> macro definition</figcaption>
</figure>
<section class="note" aria-role="note">
<p data-x-en="Note: The actual definition of the vec! macro in the standard library includes code to preallocate the correct amount of memory up front. That code is an optimization that we don’t include here to make the example simpler.">注意：标准库中 <code>vec!</code> 宏的实际定义包括预先分配正确数量的内存的代码。这些代码是一种优化，我们在这里没有包含，以使示例更简单。</p>
</section>
<p data-x-en="The #[macro_export] annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. Without this annotation, the macro can’t be brought into scope."><code>#[macro_export]</code> 注解表示每当定义该宏的 crate 被引入作用域时，此宏也应被提供。如果没有这个注解，宏将无法被引入作用域。</p>
<p data-x-en="We then start the macro definition with macro_rules! and the name of the macro we’re defining without the exclamation mark. The name, in this case vec, is followed by curly brackets denoting the body of the macro definition.">然后我们用 <code>macro_rules!</code> 和我们定义的宏的名称（<em>不带</em>感叹号）开始宏定义。名称，在这个例子中为 <code>vec</code>，后面跟着表示宏定义主体的大括号。</p>
<p data-x-en="The structure in the vec! body is similar to the structure of a match expression. Here we have one arm with the pattern ( $( $x:expr ),* ), followed by => and the block of code associated with this pattern. If the pattern matches, the associated block of code will be emitted. Given that this is the only pattern in this macro, there is only one valid way to match; any other pattern will result in an error. More complex macros will have more than one arm."><code>vec!</code> 体内的结构类似于 <code>match</code> 表达式的结构。这里我们有一个带有模式 <code>( $( $x:expr ),* )</code> 的分支，后面跟着 <code>=&gt;</code> 和与此模式关联的代码块。如果模式匹配，将生成关联的代码块。鉴于这是此宏中唯一的模式，只有一种有效的匹配方式；任何其他模式都将导致错误。更复杂的宏将有多个分支。</p>
<p data-x-en="Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 19 because macro patterns are matched against Rust code structure rather than values. Let’s walk through what the pattern pieces in Listing 20-28 mean; for the full macro pattern syntax, see the Rust Reference.">有效的宏定义中的模式语法与第19章中介绍的模式语法不同，因为宏模式是与Rust代码结构匹配，而不是与值匹配。让我们来分析一下列表20-28中的模式片段的含义；有关完整的宏模式语法，请参阅<a href="../reference/macros-by-example.html">Rust参考手册</a>。</p>
<p data-x-en="First, we use a set of parentheses to encompass the whole pattern. We use a dollar sign ($) to declare a variable in the macro system that will contain the Rust code matching the pattern. The dollar sign makes it clear this is a macro variable as opposed to a regular Rust variable. Next comes a set of parentheses that captures values that match the pattern within the parentheses for use in the replacement code. Within $() is $x:expr, which matches any Rust expression and gives the expression the name $x.">首先，我们使用一组括号来包含整个模式。我们使用美元符号（<code>$</code>）在宏系统中声明一个变量，该变量将包含与模式匹配的Rust代码。美元符号明确表示这是一个宏变量，而不是普通的Rust变量。接下来是一组括号，用于捕获与括号内模式匹配的值，以便在替换代码中使用。在<code>$()</code>内是<code>$x:expr</code>，它匹配任何Rust表达式，并将该表达式命名为<code>$x</code>。</p>
<p data-x-en="The comma following $() indicates that a literal comma separator character could optionally appear after the code that matches the code in $(). The * specifies that the pattern matches zero or more of whatever precedes the *.">逗号跟随在 <code>$()</code> 之后表示一个字面上的逗号分隔符字符 可以选择性地出现在与 <code>$()</code> 中的代码匹配的代码之后。 <code>*</code> 指定模式匹配零个或多个 <code>*</code> 前面的任何内容。</p>
<p data-x-en="When we call this macro with vec![1, 2, 3];, the $x pattern matches three times with the three expressions 1, 2, and 3.">当我们用 <code>vec![1, 2, 3];</code> 调用这个宏时，<code>$x</code> 模式会与三个表达式 <code>1</code>、<code>2</code> 和 <code>3</code> 匹配三次。</p>
<p data-x-en="Now let’s look at the pattern in the body of the code associated with this arm: temp_vec.push() within $()* is generated for each part that matches $() in the pattern zero or more times depending on how many times the pattern matches. The $x is replaced with each expression matched. When we call this macro with vec![1, 2, 3];, the code generated that replaces this macro call will be the following:">现在让我们看看与此臂关联的代码主体中的模式：<code>temp_vec.push()</code> 在 <code>$()*</code> 中为每个匹配 <code>$()</code> 的部分生成，根据模式匹配的次数，可以是零次或多次。<code>$x</code> 被每个匹配的表达式替换。当我们用 <code>vec![1, 2, 3];</code> 调用这个宏时，替换此宏调用生成的代码将是以下内容：</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p data-x-en="We’ve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.">我们定义了一个宏，可以接受任意数量的任意类型的参数，并可以生成代码来创建包含指定元素的向量。</p>
<p data-x-en="To learn more about how to write macros, consult the online documentation or other resources, such as “The Little Book of Rust Macros” started by Daniel Keep and continued by Lukas Wirth.">要了解更多关于如何编写宏的信息，请查阅在线文档或其他资源，如 <a href="https://veykril.github.io/tlborm/">“Rust 宏小书”</a>，该书由 Daniel Keep 开始编写并由 Lukas Wirth 继续。</p>
<h3 id="procedural-macros-for-generating-code-from-attributes"><a class="header" href="#procedural-macros-for-generating-code-from-attributes">用于从属性生成代码的过程宏</a></h3>
<p data-x-en="The second form of macros is the procedural macro, which acts more like a function (and is a type of procedure). Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do. The three kinds of procedural macros are custom derive, attribute-like, and function-like, and all work in a similar fashion.">第二种宏的形式是<em>过程宏</em>，它更像一个函数（并且是一种过程）。过程宏接受一些代码作为输入，对这些代码进行操作，并生成一些代码作为输出，而不是像声明式宏那样通过匹配模式并用其他代码替换这些代码。过程宏的三种类型是自定义派生、属性样式的和函数样式的，它们都以类似的方式工作。</p>
<p data-x-en="When creating procedural macros, the definitions must reside in their own crate with a special crate type. This is for complex technical reasons that we hope to eliminate in the future. In Listing 20-29, we show how to define a procedural macro, where some_attribute is a placeholder for using a specific macro variety.">当创建过程宏时，定义必须位于具有特殊crate类型的独立crate中。这是出于复杂的技
术原因，我们希望将来能够消除。在清单20-29中，我们展示了如何定义一个过程宏，其中<code>some_attribute</code>是使用特定宏变体的占位符。</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
<figcaption>Listing 20-29: An example of defining a procedural macro</figcaption>
</figure>
<p data-x-en="The function that defines a procedural macro takes a TokenStream as an input and produces a TokenStream as an output. The TokenStream type is defined by the proc_macro crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: the source code that the macro is operating on makes up the input TokenStream, and the code the macro produces is the output TokenStream. The function also has an attribute attached to it that specifies which kind of procedural macro we’re creating. We can have multiple kinds of procedural macros in the same crate.">定义过程宏的函数以 <code>TokenStream</code> 作为输入，并生成一个 <code>TokenStream</code> 作为输出。 <code>TokenStream</code> 类型由 Rust 包含的 <code>proc_macro</code> crate 定义，表示一个令牌序列。这是宏的核心：宏操作的源代码构成了输入 <code>TokenStream</code>，而宏生成的代码是输出 <code>TokenStream</code>。该函数还附加了一个属性，指定了我们正在创建的过程宏的类型。我们可以在同一个 crate 中有多种类型的过程宏。</p>
<p data-x-en="Let’s look at the different kinds of procedural macros. We’ll start with a custom derive macro and then explain the small dissimilarities that make the other forms different.">让我们看看不同种类的过程宏。我们从自定义派生宏开始，然后解释使其他形式不同的细微差异。</p>
<h3 id="how-to-write-a-custom-derive-macro"><a class="header" href="#how-to-write-a-custom-derive-macro">如何编写自定义 <code>derive</code> 宏</a></h3>
<p data-x-en="Let’s create a crate named hello_macro that defines a trait named HelloMacro with one associated function named hello_macro. Rather than making our users implement the HelloMacro trait for each of their types, we’ll provide a procedural macro so users can annotate their type with #[derive(HelloMacro)] to get a default implementation of the hello_macro function. The default implementation will print Hello, Macro! My name is TypeName! where TypeName is the name of the type on which this trait has been defined. In other words, we’ll write a crate that enables another programmer to write code like Listing 20-30 using our crate.">让我们创建一个名为 <code>hello_macro</code> 的 crate，该 crate 定义了一个名为 <code>HelloMacro</code> 的 trait，其中有一个关联函数名为 <code>hello_macro</code>。我们不是让用户为每个类型实现 <code>HelloMacro</code> trait，而是提供一个过程宏，使用户可以通过 <code>#[derive(HelloMacro)]</code> 注解他们的类型来获得 <code>hello_macro</code> 函数的默认实现。默认实现将打印 <code>Hello, Macro! My name is TypeName!</code>，其中 <code>TypeName</code> 是定义此 trait 的类型的名称。换句话说，我们将编写一个 crate，使其他程序员能够使用我们的 crate 编写如清单 20-30 所示的代码。</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<figcaption>Listing 20-30: The code a user of our crate will be able to write when using our procedural macro</figcaption>
</figure>
<p data-x-en="This code will print Hello, Macro! My name is Pancakes! when we’re done. The first step is to make a new library crate, like this:">这段代码完成后将打印 <code>Hello, Macro! My name is Pancakes!</code>。第一步是创建一个新的库crate，如下所示：</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p data-x-en="Next, we’ll define the HelloMacro trait and its associated function:">接下来，我们将定义 <code>HelloMacro</code> 特性和其关联函数：</p>
<figure class="listing">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}</code></pre>
</figure>
<p data-x-en="We have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, like so:">我们有一个特质及其函数。此时，我们的 crate 用户可以实现该特质以实现所需的功能，如下所示：</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p data-x-en="However, they would need to write the implementation block for each type they wanted to use with hello_macro; we want to spare them from having to do this work.">但是，他们需要为每个想要与<code>hello_macro</code>一起使用的类型编写实现块；我们希望免除他们做这项工作的需要。</p>
<p data-x-en="Additionally, we can’t yet provide the hello_macro function with default implementation that will print the name of the type the trait is implemented on: Rust doesn’t have reflection capabilities, so it can’t look up the type’s name at runtime. We need a macro to generate code at compile time.">此外，我们还不能为 <code>hello_macro</code> 函数提供默认实现来打印实现该特征的类型的名称：Rust 没有反射功能，因此无法在运行时查找类型的名称。我们需要一个宏在编译时生成代码。</p>
<p data-x-en="The next step is to define the procedural macro. At the time of this writing, procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: for a crate named foo, a custom derive procedural macro crate is called foo_derive. Let’s start a new crate called hello_macro_derive inside our hello_macro project:">下一步是定义过程宏。在撰写本文时，
过程宏需要位于它们自己的 crate 中。最终，这一限制
可能会被取消。crate 和宏 crate 的结构约定如下：对于名为 <code>foo</code> 的 crate，自定义派生过程宏 crate
称为 <code>foo_derive</code>。让我们在 <code>hello_macro</code> 项目中
开始一个名为 <code>hello_macro_derive</code> 的新 crate：</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p data-x-en="Our two crates are tightly related, so we create the procedural macro crate within the directory of our hello_macro crate. If we change the trait definition in hello_macro, we’ll have to change the implementation of the procedural macro in hello_macro_derive as well. The two crates will need to be published separately, and programmers using these crates will need to add both as dependencies and bring them both into scope. We could instead have the hello_macro crate use hello_macro_derive as a dependency and re-export the procedural macro code. However, the way we’ve structured the project makes it possible for programmers to use hello_macro even if they don’t want the derive functionality.">我们的两个crate紧密相关，因此我们在<code>hello_macro</code> crate的目录内创建了过程宏crate。如果我们更改<code>hello_macro</code>中的trait定义，我们也需要更改<code>hello_macro_derive</code>中的过程宏实现。这两个crate需要分别发布，使用这些crate的程序员需要将它们都添加为依赖项并将它们都引入作用域。我们也可以让<code>hello_macro</code> crate将<code>hello_macro_derive</code>作为依赖项并重新导出过程宏代码。然而，我们构建项目的方式使得程序员即使不想要<code>derive</code>功能也可以使用<code>hello_macro</code>。</p>
<p data-x-en="We need to declare the hello_macro_derive crate as a procedural macro crate. We’ll also need functionality from the syn and quote crates, as you’ll see in a moment, so we need to add them as dependencies. Add the following to the Cargo.toml file for hello_macro_derive:">我们需要将<code>hello_macro_derive</code> crate 声明为过程宏 crate。
我们还需要从 <code>syn</code> 和 <code>quote</code> crate 中获取功能，你将在稍后看到，
因此我们需要将它们添加为依赖项。将以下内容添加到 <code>hello_macro_derive</code> 的 <em>Cargo.toml</em> 文件中：</p>
<figure class="listing">
<span class="file-name">Filename: hello_macro_derive/Cargo.toml</span>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = "2.0"
quote = "1.0"
</code></pre>
</figure>
<p data-x-en="To start defining the procedural macro, place the code in Listing 20-31 into your src/lib.rs file for the hello_macro_derive crate. Note that this code won’t compile until we add a definition for the impl_hello_macro function.">要开始定义过程宏，请将列表 20-31 中的代码放入 <em>src/lib.rs</em> 文件中，用于 <code>hello_macro_derive</code> crate。请注意，此代码在我们添加 <code>impl_hello_macro</code> 函数的定义之前无法编译。</p>
<figure class="listing">
<span class="file-name">Filename: hello_macro_derive/src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&amp;ast)
}</code></pre>
<figcaption>Listing 20-31: Code that most procedural macro crates will require in order to process Rust code</figcaption>
</figure>
<p data-x-en="Notice that we’ve split the code into the hello_macro_derive function, which is responsible for parsing the TokenStream, and the impl_hello_macro function, which is responsible for transforming the syntax tree: this makes writing a procedural macro more convenient. The code in the outer function (hello_macro_derive in this case) will be the same for almost every procedural macro crate you see or create. The code you specify in the body of the inner function (impl_hello_macro in this case) will be different depending on your procedural macro’s purpose.">注意，我们已经将代码拆分为 <code>hello_macro_derive</code> 函数，该函数负责解析 <code>TokenStream</code>，以及 <code>impl_hello_macro</code> 函数，该函数负责转换语法树：这使得编写过程宏更加方便。外部函数中的代码（在这种情况下为 <code>hello_macro_derive</code>）对于你看到或创建的几乎所有过程宏 crate 都是相同的。你在内部函数体中指定的代码（在这种情况下为 <code>impl_hello_macro</code>）将根据你的过程宏的目的而不同。</p>
<p data-x-en="We’ve introduced three new crates: proc_macro, syn, and quote. The proc_macro crate comes with Rust, so we didn’t need to add that to the dependencies in Cargo.toml. The proc_macro crate is the compiler’s API that allows us to read and manipulate Rust code from our code.">我们引入了三个新的crate：<code>proc_macro</code>，<a href="https://crates.io/crates/syn"><code>syn</code></a> 和 <a href="https://crates.io/crates/quote"><code>quote</code></a>。<code>proc_macro</code> crate 随 Rust 一起提供，因此我们不需要将其添加到 <em>Cargo.toml</em> 的依赖项中。<code>proc_macro</code> crate 是编译器的 API，允许我们从代码中读取和操作 Rust 代码。</p>
<p data-x-en="The syn crate parses Rust code from a string into a data structure that we can perform operations on. The quote crate turns syn data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task."><code>syn</code> crate 从字符串中解析 Rust 代码到我们可以操作的数据结构。<code>quote</code> crate 将 <code>syn</code> 数据结构转换回 Rust 代码。这些 crate 使解析我们可能需要处理的任何类型的 Rust 代码变得更加简单：编写一个完整的 Rust 代码解析器绝非易事。</p>
<p data-x-en="The hello_macro_derive function will be called when a user of our library specifies #[derive(HelloMacro)] on a type. This is possible because we’ve annotated the hello_macro_derive function here with proc_macro_derive and specified the name HelloMacro, which matches our trait name; this is the convention most procedural macros follow."><code>hello_macro_derive</code> 函数将在我们的库的用户在类型上指定 <code>#[derive(HelloMacro)]</code> 时被调用。这是因为我们在这里用 <code>proc_macro_derive</code> 注解了 <code>hello_macro_derive</code> 函数，并指定了名称 <code>HelloMacro</code>，这与我们的特征名称匹配；这是大多数过程宏遵循的惯例。</p>
<p data-x-en="The hello_macro_derive function first converts the input from a TokenStream to a data structure that we can then interpret and perform operations on. This is where syn comes into play. The parse function in syn takes a TokenStream and returns a DeriveInput struct representing the parsed Rust code. Listing 20-32 shows the relevant parts of the DeriveInput struct we get from parsing the struct Pancakes; string:"><code>hello_macro_derive</code> 函数首先将 <code>input</code> 从一个 <code>TokenStream</code> 转换为一个我们可以解释和执行操作的数据结构。这就是 <code>syn</code> 发挥作用的地方。<code>syn</code> 中的 <code>parse</code> 函数接受一个 <code>TokenStream</code> 并返回一个表示解析后的 Rust 代码的 <code>DeriveInput</code> 结构体。列表 20-32 显示了从解析 <code>struct Pancakes;</code> 字符串得到的 <code>DeriveInput</code> 结构体的相关部分：</p>
<figure class="listing">
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
<figcaption>Listing 20-32: The <code>DeriveInput</code> instance we get when parsing the code that has the macro’s attribute in Listing 20-30</figcaption>
</figure>
<p data-x-en="The fields of this struct show that the Rust code we’ve parsed is a unit struct with the ident (identifier, meaning the name) of Pancakes. There are more fields on this struct for describing all sorts of Rust code; check the syn documentation for DeriveInput for more information.">这个结构体的字段显示我们解析的 Rust 代码是一个单元结构体，其 <code>ident</code>（标识符，即名称）为 <code>Pancakes</code>。这个结构体还有更多字段用于描述各种 Rust 代码；有关更多信息，请参阅 <a href="https://docs.rs/syn/2.0/syn/struct.DeriveInput.html"><code>syn</code> 中 <code>DeriveInput</code> 的文档</a>。</p>
<p data-x-en="Soon we’ll define the impl_hello_macro function, which is where we’ll build the new Rust code we want to include. But before we do, note that the output for our derive macro is also a TokenStream. The returned TokenStream is added to the code that our crate users write, so when they compile their crate, they’ll get the extra functionality that we provide in the modified TokenStream.">很快我们将定义<code>impl_hello_macro</code>函数，这将是构建我们想要包含的新Rust代码的地方。但在我们这样做之前，请注意，我们的派生宏的输出也是一个<code>TokenStream</code>。返回的<code>TokenStream</code>将添加到我们的crate用户编写的代码中，因此当他们编译他们的crate时，他们将获得我们在修改后的<code>TokenStream</code>中提供的额外功能。</p>
<p data-x-en="You might have noticed that we’re calling unwrap to cause the hello_macro_derive function to panic if the call to the syn::parse function fails here. It’s necessary for our procedural macro to panic on errors because proc_macro_derive functions must return TokenStream rather than Result to conform to the procedural macro API. We’ve simplified this example by using unwrap; in production code, you should provide more specific error messages about what went wrong by using panic! or expect.">你可能已经注意到，我们在这里调用 <code>unwrap</code> 以使 <code>hello_macro_derive</code> 函数在 <code>syn::parse</code> 函数调用失败时引发 panic。我们的过程宏在遇到错误时必须 panic，因为 <code>proc_macro_derive</code> 函数必须返回 <code>TokenStream</code> 而不是 <code>Result</code> 以符合过程宏 API。我们通过使用 <code>unwrap</code> 简化了这个示例；在生产代码中，你应该使用 <code>panic!</code> 或 <code>expect</code> 提供更具体的错误信息。</p>
<p data-x-en="Now that we have the code to turn the annotated Rust code from a TokenStream into a DeriveInput instance, let’s generate the code that implements the HelloMacro trait on the annotated type, as shown in Listing 20-33.">现在我们有了将带有注解的 Rust 代码从 <code>TokenStream</code> 转换为 <code>DeriveInput</code> 实例的代码，让我们生成实现 <code>HelloMacro</code> 特性到带有注解的类型的代码，如清单 20-33 所示。</p>
<figure class="listing">
<span class="file-name">Filename: hello_macro_derive/src/lib.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construct a representation of Rust code as a syntax tree
</span><span class="boring">    // that we can manipulate
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Build the trait implementation
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}</code></pre>
<figcaption>Listing 20-33: Implementing the <code>HelloMacro</code> trait using the parsed Rust code</figcaption>
</figure>
<p data-x-en="We get an Ident struct instance containing the name (identifier) of the annotated type using ast.ident. The struct in Listing 20-32 shows that when we run the impl_hello_macro function on the code in Listing 20-30, the ident we get will have the ident field with a value of &quot;Pancakes&quot;. Thus, the name variable in Listing 20-33 will contain an Ident struct instance that, when printed, will be the string &quot;Pancakes&quot;, the name of the struct in Listing 20-30.">我们使用 <code>ast.ident</code> 获取一个包含注解类型名称（标识符）的 <code>Ident</code> 结构体实例。列表 20-32 中的结构体显示，当我们对列表 20-30 中的代码运行 <code>impl_hello_macro</code> 函数时，我们得到的 <code>ident</code> 将具有值为 <code>"Pancakes"</code> 的 <code>ident</code> 字段。因此，列表 20-33 中的 <code>name</code> 变量将包含一个 <code>Ident</code> 结构体实例，当打印时，它将是字符串 <code>"Pancakes"</code>，即列表 20-30 中结构体的名称。</p>
<p data-x-en="The quote! macro lets us define the Rust code that we want to return. The compiler expects something different to the direct result of the quote! macro’s execution, so we need to convert it to a TokenStream. We do this by calling the into method, which consumes this intermediate representation and returns a value of the required TokenStream type."><code>quote!</code> 宏让我们定义我们想要返回的 Rust 代码。编译器期望 <code>quote!</code> 宏执行的直接结果之外的某些内容，因此我们需要将其转换为 <code>TokenStream</code>。我们通过调用 <code>into</code> 方法来实现这一点，该方法消耗这个中间表示并返回所需 <code>TokenStream</code> 类型的值。</p>
<p data-x-en="The quote! macro also provides some very cool templating mechanics: we can enter #name, and quote! will replace it with the value in the variable name. You can even do some repetition similar to the way regular macros work. Check out the quote crate’s docs for a thorough introduction."><code>quote!</code> 宏还提供了一些非常酷的模板机制：我们可以输入 <code>#name</code>，<code>quote!</code> 会将其替换为变量 <code>name</code> 中的值。你甚至可以像普通宏那样进行一些重复操作。查看 <a href="https://docs.rs/quote">the <code>quote</code> crate’s docs</a> 以获得详细的介绍。</p>
<p data-x-en="We want our procedural macro to generate an implementation of our HelloMacro trait for the type the user annotated, which we can get by using #name. The trait implementation has the one function hello_macro, whose body contains the functionality we want to provide: printing Hello, Macro! My name is and then the name of the annotated type.">我们希望我们的过程宏为用户注解的类型生成一个<code>HelloMacro</code>特性的实现，我们可以通过使用<code>#name</code>来获取。该特性实现包含一个函数<code>hello_macro</code>，其函数体包含我们想要提供的功能：打印<code>Hello, Macro! My name is</code>，然后是注解类型的名称。</p>
<p data-x-en="The stringify! macro used here is built into Rust. It takes a Rust expression, such as 1 + 2, and at compile time turns the expression into a string literal, such as &quot;1 + 2&quot;. This is different than format! or println!, macros which evaluate the expression and then turn the result into a String. There is a possibility that the #name input might be an expression to print literally, so we use stringify!. Using stringify! also saves an allocation by converting #name to a string literal at compile time.">The <code>stringify!</code> 宏在这里是 Rust 内置的。它接受一个 Rust 表达式，例如 <code>1 + 2</code>，并在编译时将表达式转换为字符串字面量，例如 <code>"1 + 2"</code>。这与 <code>format!</code> 或 <code>println!</code> 宏不同，后者会先评估表达式，然后将结果转换为 <code>String</code>。有可能 <code>#name</code> 输入是一个需要字面打印的表达式，因此我们使用 <code>stringify!</code>。使用 <code>stringify!</code> 还可以通过在编译时将 <code>#name</code> 转换为字符串字面量来节省分配。</p>
<p data-x-en="At this point, cargo build should complete successfully in both hello_macro and hello_macro_derive. Let’s hook up these crates to the code in Listing 20-30 to see the procedural macro in action! Create a new binary project in your projects directory using cargo new pancakes. We need to add hello_macro and hello_macro_derive as dependencies in the pancakes crate’s Cargo.toml. If you’re publishing your versions of hello_macro and hello_macro_derive to crates.io, they would be regular dependencies; if not, you can specify them as path dependencies as follows:">此时，<code>cargo build</code> 应该在 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 中都成功完成。让我们将这些 crates 连接到列表 20-30 中的代码，看看过程宏如何工作！在 <em>projects</em> 目录中使用 <code>cargo new pancakes</code> 创建一个新的二进制项目。我们需要在 <code>pancakes</code> crate 的 <em>Cargo.toml</em> 中添加 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 作为依赖项。如果你将 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 的版本发布到 <a href="https://crates.io/">crates.io</a>，它们将是常规依赖项；如果不是，你可以将它们指定为 <code>path</code> 依赖项，如下所示：</p>
<pre><code class="language-toml">hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
</code></pre>
<p data-x-en="Put the code in Listing 20-30 into src/main.rs, and run cargo run: it should print Hello, Macro! My name is Pancakes! The implementation of the HelloMacro trait from the procedural macro was included without the pancakes crate needing to implement it; the #[derive(HelloMacro)] added the trait implementation.">将清单 20-30 中的代码放入 <em>src/main.rs</em>，并运行 <code>cargo run</code>：它应该打印 <code>Hello, Macro! My name is Pancakes!</code> 从过程宏实现的 <code>HelloMacro</code> 特性被包含进来，而无需 <code>pancakes</code> crate 自身实现它；<code>#[derive(HelloMacro)]</code> 添加了特性实现。</p>
<p data-x-en="Next, let’s explore how the other kinds of procedural macros differ from custom derive macros.">接下来，让我们探讨其他种类的过程宏与自定义派生宏有何不同。</p>
<h3 id="attribute-like-macros"><a class="header" href="#attribute-like-macros">类似属性的宏</a></h3>
<p data-x-en="Attribute-like macros are similar to custom derive macros, but instead of generating code for the derive attribute, they allow you to create new attributes. They’re also more flexible: derive only works for structs and enums; attributes can be applied to other items as well, such as functions. Here’s an example of using an attribute-like macro: say you have an attribute named route that annotates functions when using a web application framework:">属性宏类似于自定义派生宏，但它们不是为 <code>derive</code> 属性生成代码，而是允许你创建新的属性。它们也更灵活：<code>derive</code> 仅适用于结构体和枚举；属性可以应用于其他项目，例如函数。以下是一个使用属性宏的示例：假设你有一个名为 <code>route</code> 的属性，用于在使用 Web 应用程序框架时注解函数：</p>
<pre><code class="language-rust ignore">#[route(GET, "/")]
fn index() {</code></pre>
<p data-x-en="This #[route] attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:">这个 <code>#[route]</code> 属性将由框架定义为过程宏。宏定义函数的签名将如下所示：</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p data-x-en="Here, we have two parameters of type TokenStream. The first is for the contents of the attribute: the GET, &quot;/&quot; part. The second is the body of the item the attribute is attached to: in this case, fn index() {} and the rest of the function’s body.">这里，我们有两个类型为<code>TokenStream</code>的参数。第一个是属性的内容：<code>GET, "/"</code> 部分。第二个是属性附加到的项的主体：在这种情况下，<code>fn index() {}</code> 和函数主体的其余部分。</p>
<p data-x-en="Other than that, attribute-like macros work the same way as custom derive macros: you create a crate with the proc-macro crate type and implement a function that generates the code you want!">除此之外，属性宏的工作方式与自定义派生宏相同：您创建一个类型为 <code>proc-macro</code> 的 crate 并实现一个生成所需代码的函数！</p>
<h3 id="function-like-macros"><a class="header" href="#function-like-macros">函数式宏</a></h3>
<p data-x-en="Function-like macros define macros that look like function calls. Similarly to macro_rules! macros, they’re more flexible than functions; for example, they can take an unknown number of arguments. However, macro_rules! macros can be defined only using the match-like syntax we discussed in the section “Declarative Macros with macro_rules! for General Metaprogramming” earlier. Function-like macros take a TokenStream parameter and their definition manipulates that TokenStream using Rust code as the other two types of procedural macros do. An example of a function-like macro is an sql! macro that might be called like so:">函数式宏定义了看起来像函数调用的宏。类似于<code>macro_rules!</code>宏，它们比函数更灵活；例如，它们可以接受未知数量的参数。然而，<code>macro_rules!</code>宏只能使用我们在<a href="#declarative-macros-with-macro_rules-for-general-metaprogramming">“使用<code>macro_rules!</code>的声明式宏进行通用元编程”</a><!-- ignore -->部分讨论的匹配语法来定义。函数式宏接受一个<code>TokenStream</code>参数，并且它们的定义使用Rust代码来操作这个<code>TokenStream</code>，就像其他两种过程宏一样。一个函数式宏的例子是<code>sql!</code>宏，它可能被这样调用：</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p data-x-en="This macro would parse the SQL statement inside it and check that it’s syntactically correct, which is much more complex processing than a macro_rules! macro can do. The sql! macro would be defined like this:">这个宏会解析其内部的 SQL 语句并检查其语法是否正确，这比 <code>macro_rules!</code> 宏能做的处理要复杂得多。<code>sql!</code> 宏的定义如下：</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p data-x-en="This definition is similar to the custom derive macro’s signature: we receive the tokens that are inside the parentheses and return the code we wanted to generate.">这个定义与自定义派生宏的签名类似：我们接收括号内的标记并返回我们想要生成的代码。</p>
<h2 id="summary"><a class="header" href="#summary">摘要</a></h2>
<p data-x-en="Whew! Now you have some Rust features in your toolbox that you likely won’t use often, but you’ll know they’re available in very particular circumstances. We’ve introduced several complex topics so that when you encounter them in error message suggestions or in other peoples’ code, you’ll be able to recognize these concepts and syntax. Use this chapter as a reference to guide you to solutions.">呼！现在你已经掌握了一些你可能不常使用，但在特定情况下会知道它们可用的 Rust 特性。我们介绍了几个复杂的话题，这样当你在错误消息建议或其他人的代码中遇到它们时，你能够识别这些概念和语法。将本章用作参考，以引导你找到解决方案。</p>
<p data-x-en="Next, we’ll put everything we’ve discussed throughout the book into practice and do one more project!">接下来，我们将把本书中讨论的所有内容付诸实践，并再做一个项目！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-05-advanced-functions-and-closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch21-00-final-project-a-web-server.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-05-advanced-functions-and-closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch21-00-final-project-a-web-server.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    

</body></html>